<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!--
      Tag Title Utama untuk tab browser
    -->
    <title>fire123-game: FPS Web Game</title>

    <!--
      Meta Description untuk deskripsi di hasil pencarian Google
    -->
    <meta name="description" content="Mainkan Fire123, game tembak-tembakan FPS sederhana berbasis web dengan grafis 3D dan kontrol responsif. Targetkan musuh dan raih skor tertinggi!" />
    
    <!--
      Keywords (opsional, tapi bisa membantu)
    -->
    <meta name="keywords" content="FPS game, web game, three.js game, fire123, shooting game, game tembak-tembakan, game online gratis, 3D game, WebGL" />
    
    <!--
      Penulis/Kredit (opsional)
    -->
    <meta name="author" content="Tim Pengembang Game Fire123" />

    <!--
      Open Graph Meta Tags untuk Facebook, LinkedIn, WhatsApp, dll.
      Ini membuat tautan Anda terlihat bagus saat dibagikan.
    -->
    <meta property="og:type" content="game.website" />
    <meta property="og:url" content="https://fire123-game.vercel.app/" />
    <meta property="og:title" content="fire123-game: Game Tembak-tembakan FPS Web 3D" />
    <meta property="og:description" content="Mainkan Fire123, game tembak-tembakan FPS sederhana berbasis web dengan grafis 3D dan kontrol responsif. Targetkan musuh dan raih skor tertinggi!" />
    <meta property="og:image" content="https://placehold.co/1200x630/000/FFF?text=Fire123%20Game%20Preview" /> 
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <!--
      Twitter Card Meta Tags untuk pratinjau di Twitter
    -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://fire123-game.vercel.app/" />
    <meta property="twitter:title" content="fire123-game: Game Tembak-tembakan FPS Web 3D" />
    <meta property="twitter:description" content="Mainkan Fire123, game tembak-tembakan FPS sederhana berbasis web dengan grafis 3D dan kontrol responsif. Targetkan musuh dan raih skor tertinggi!" />
    <meta property="twitter:image" content="https://placehold.co/1200x630/000/FFF?text=Fire123%20Game%20Preview" /> 
    <meta property="twitter:creator" content="@yourtwitterhandle" /> 
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Latar belakang gelap */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Mencegah scrolling */
            position: relative; /* Untuk posisi kotak pesan */
            width: 100vw;
            height: 100vh;
        }
        #gameCanvas3D {
            background-color: #000; /* Latar belakang game */
            display: block;
            touch-action: none; /* Nonaktifkan tindakan sentuh default seperti scrolling/zooming */
            width: 100%;
            height: 100%;
            border-radius: 0; /* Hapus border-radius untuk layar penuh */
            box-shadow: none; /* Hapus bayangan untuk layar penuh */
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 0; /* Hapus padding untuk konten edge-to-edge */
            margin: 0; /* Hapus margin */
            overflow: hidden; /* Pastikan konten tidak meluap */
            position: relative; /* Untuk crosshair */
            width: 100vw;
            height: 100vh;
            max-width: 100vw; /* Pastikan mengambil lebar penuh */
            background-color: #2d3748; /* Latar belakang kontainer lebih gelap */
        }
        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            color: #e2e8f0;
            font-weight: bold;
            z-index: 10; /* Di atas kanvas */
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 1rem;
            padding: 0 1rem;
            font-size: 1.8rem; /* Ukuran font lebih besar */
            text-shadow: 0 0 8px #0ff, 0 0 12px #0ff; /* Cahaya neon untuk teks */
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            border: 2px solid #0ff;
            box-shadow: 0 0 20px #0ff;
            z-index: 1000;
            display: none; /* Tersembunyi secara default */
        }
        .message-box button {
            margin-top: 1rem;
            padding: 0.75rem 1.5rem;
            background-color: #0ff;
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: bold;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 10px #0ff;
        }
        .message-box button:hover {
            background-color: #0cc;
            transform: scale(1.05);
        }

        /* Kontrol Mobile */
        .mobile-controls {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 1rem;
            gap: 0.5rem;
            z-index: 10; /* Di atas kanvas */
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            right: 1rem;
            padding: 0 1rem;
        }
        .mobile-controls button {
            flex: 1;
            padding: 1rem;
            background-color: #4a5568;
            color: #e2e8f0;
            border: none;
            border-radius: 8px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        .mobile-controls button:active {
            background-color: #0ff;
            color: #000;
            transform: scale(0.95);
        }
        .mobile-controls .left-right-buttons {
            display: flex;
            gap: 0.5rem;
            flex: 2;
        }
        .mobile-controls .shoot-button {
            flex: 1;
        }

        @media (min-width: 768px) {
            .mobile-controls {
                display: none; /* Sembunyikan di desktop */
            }
        }

        /* Crosshair */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 1px solid #0ff;
            border-radius: 50%;
            box-shadow: 0 0 5px #0ff;
            pointer-events: none; /* Memungkinkan klik melewati */
            z-index: 5;
        }
        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background-color: #0ff;
        }
        .crosshair::before {
            width: 2px;
            height: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .crosshair::after {
            width: 10px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Main Menu Styles */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #e2e8f0;
            z-index: 2000;
        }
        .menu-screen h1 {
            font-size: 4rem;
            margin-bottom: 2rem;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
        }
        .menu-screen button {
            padding: 1rem 2.5rem;
            margin: 0.75rem 0;
            background-color: #0ff;
            color: #000;
            border: none;
            border-radius: 12px;
            font-size: 1.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            box-shadow: 0 0 15px #0ff;
        }
        .menu-screen button:hover {
            background-color: #0cc;
            transform: scale(1.05);
            box-shadow: 0 0 25px #0cc;
        }

        /* Player HUD Bars */
        .player-hud {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            width: 200px; /* Lebar default untuk desktop */
        }
        .health-bar, .shield-bar {
            width: 100%;
            height: 25px;
            background-color: #333;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #e2e8f0;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            position: relative;
        }
        .health-bar-fill, .shield-bar-fill {
            height: 100%;
            width: 100%; /* Default to full */
            transition: width 0.2s ease-out, background-color 0.2s ease-out;
            border-radius: 6px;
            position: absolute;
            top: 0;
            left: 0;
        }
        .health-bar-fill {
            background-color: #0F0; /* Green */
        }
        .shield-bar-fill {
            background-color: #00F; /* Blue */
        }
        .bar-label {
            position: absolute;
            width: 100%;
            text-align: center;
            color: #fff;
            font-weight: bold;
            line-height: 25px; /* Vertically center text */
            text-shadow: 0 0 5px #000;
            font-size: 0.9rem;
        }

        /* Responsive adjustments for HUD */
        @media (max-width: 767px) {
            .player-hud {
                width: 150px; /* Lebih kecil di mobile */
                bottom: 0.5rem;
                left: 0.5rem;
            }
            .health-bar, .shield-bar {
                height: 20px;
            }
            .bar-label {
                font-size: 0.8rem;
                line-height: 20px;
            }
            .game-info {
                font-size: 1.2rem;
                top: 0.5rem;
                left: 0.5rem;
                right: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-info">
            <div id="score">Skor: 0</div>
            <div id="lives">Nyawa: 3</div>
        </div>
        <div class="crosshair"></div>
        <canvas id="gameCanvas3D"></canvas>

        <div class="mobile-controls">
            <div class="left-right-buttons">
                <button id="leftButton" class="rounded-lg"><i class="fas fa-arrow-left"></i></button>
                <button id="rightButton" class="rounded-lg"><i class="fas fa-arrow-right"></i></button>
            </div>
            <button id="forwardButton" class="rounded-lg"><i class="fas fa-arrow-up"></i></button>
            <button id="backwardButton" class="rounded-lg"><i class="fas fa-arrow-down"></i></button>
            <button id="shootButton" class="shoot-button rounded-lg"><i class="fas fa-crosshairs"></i> Tembak</button>
        </div>

        <div class="player-hud">
            <div class="health-bar">
                <div id="healthBarFill" class="health-bar-fill"></div>
                <span class="bar-label" id="healthLabel">Kesehatan: 100</span>
            </div>
            <div class="shield-bar">
                <div id="shieldBarFill" class="shield-bar-fill"></div>
                <span class="bar-label" id="shieldLabel">Perisai: 50</span>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="restartButton">Mulai Ulang</button>
    </div>

    <div id="mainMenuScreen" class="menu-screen">
        <h1>fire123-game</h1>
        <button id="startGameButton">Mulai Game</button>
        <button id="characterSelectButton">Pilih Karakter</button>
        <button id="settingsButton">Pengaturan</button>
    </div>

    <div id="characterSelectScreen" class="menu-screen" style="display: none;">
        <h1>Pilih Karakter</h1>
        <p>Fitur ini akan segera hadir!</p>
        <button id="backToMainMenuFromCharacter">Kembali ke Menu Utama</button>
    </div>

    <div id="settingsScreen" class="menu-screen" style="display: none;">
        <h1>Pengaturan</h1>
        <p>Atur opsi game di sini.</p>
        <button id="backToMainMenuFromSettings">Kembali ke Menu Utama</button>
    </div>

    <script>
        // Get info elements
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives'); // Keep for now, but health/shield are primary

        // Get message box elements
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');

        // Get main menu elements
        const mainMenuScreen = document.getElementById('mainMenuScreen');
        const startGameButton = document.getElementById('startGameButton');
        const characterSelectButton = document.getElementById('characterSelectButton');
        const settingsButton = document.getElementById('settingsButton');

        // Get character select elements
        const characterSelectScreen = document.getElementById('characterSelectScreen');
        const backToMainMenuFromCharacterButton = document.getElementById('backToMainMenuFromCharacter');

        // Get settings elements
        const settingsScreen = document.getElementById('settingsScreen');
        const backToMainMenuFromSettingsButton = document.getElementById('backToMainMenuFromSettings');

        // Get mobile controls
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const forwardButton = document.getElementById('forwardButton');
        const backwardButton = document.getElementById('backwardButton');
        const shootButton = document.getElementById('shootButton');

        // Get player HUD elements
        const healthBarFill = document.getElementById('healthBarFill');
        const healthLabel = document.getElementById('healthLabel');
        const shieldBarFill = document.getElementById('shieldBarFill');
        const shieldLabel = document.getElementById('shieldLabel');
        const playerHud = document.querySelector('.player-hud');

        // Three.js variables
        let scene, camera, renderer;
        let playerYawObject; // Object to handle horizontal rotation (yaw)
        let playerCapsule; // Invisible mesh for player collision and position (child of playerYawObject)
        let bullets = []; // Array of { mesh, velocity }
        let enemies = []; // Array of { mesh, speed }
        let obstacles = []; // Array of obstacle meshes
        let playerGunModel; // Variable to hold the gun model (FBX)
        let playerModel; // Variable to hold the player model (FBX)

        // Game variables
        let score = 0;
        let lives = 3; // Kept for now, but health/shield are primary damage absorption
        let playerHealth = 100;
        let playerMaxHealth = 100;
        let playerShield = 50;
        let playerMaxShield = 50;
        let gameOver = false;
        let gameState = 'menu'; // 'menu', 'playing', 'gameOver', 'characterSelect', 'settings'

        // Timing variables for frame-rate independence
        let lastFrameTime = 0;

        // Debugging flag - SET THIS TO TRUE TO SEE COLLISION BOXES
        const DEBUG_COLLISIONS = false; // Dimatikan untuk tampilan yang lebih bersih

        // Player properties (in Three.js units)
        const PLAYER_HEIGHT_OFFSET = 0.5; // How high the camera is from the ground
        const PLAYER_RADIUS = 0.3; // For simple cylindrical collision
        const PLAYER_BASE_SPEED = 2.0; // Adjusted to be slower, similar to Valorant's walking speed
        const PLAYER_COLOR = 0x00FFFF; // Cyan (not visible, but for conceptual player body)

        // Bullet properties (in Three.js units)
        const BULLET_WIDTH = 0.05;
        const BULLET_HEIGHT = 0.8;
        const BULLET_SPEED = 15; // Speed units per second (will be multiplied by deltaTime)
        const BULLET_COLOR = 0xFF00FF; // Magenta
        const BULLET_DAMAGE = 10;
        const ZOOMED_BULLET_DAMAGE = 25;

        // Pre-rotated bullet geometry (length along Z-axis)
        const BULLET_GEOMETRY = new THREE.CylinderGeometry(BULLET_WIDTH, BULLET_WIDTH, BULLET_HEIGHT, 8).rotateX(Math.PI / 2);

        // Enemy properties (in Three.js units)
        const ENEMY_SIZE = 0.7; // Base size for enemy scaling
        const ENEMY_BODY_HEIGHT = 0.8;
        const ENEMY_HEAD_RADIUS = 0.2;
        const ENEMY_ARM_LENGTH = 0.5;
        const ENEMY_LEG_LENGTH = 0.5;
        const ENEMY_SPEED_MIN = 0.5; // Speed units per second
        const ENEMY_SPEED_MAX = 1.5; // Speed units per second
        const ENEMY_COLOR = 0xFF0000; // Red
        const ENEMY_SPAWN_INTERVAL = 1500; // milliseconds (diperpanjang untuk debugging)
        let lastEnemySpawnTime = 0; // Akan diinisialisasi dengan Date.now() saat game dimulai
        const ENEMY_DAMAGE_TO_PLAYER = 20; // Damage an enemy deals to player on collision

        // Game world dimensions (in Three.js units)
        const WORLD_SCALE_FACTOR = 3.5; // New scale factor for the map
        const ORIGINAL_WORLD_WIDTH = 10;
        const ORIGINAL_WORLD_DEPTH = 15;
        const WORLD_WIDTH = ORIGINAL_WORLD_WIDTH * WORLD_SCALE_FACTOR;
        const WORLD_DEPTH = ORIGINAL_WORLD_DEPTH * WORLD_SCALE_FACTOR;
        const WORLD_HEIGHT = 5;

        // FOV for zoom
        const ORIGINAL_FOV = 75;
        const ZOOM_FACTOR = 1.5;
        const ZOOM_FOV = ORIGINAL_FOV / ZOOM_FACTOR;
        let isZoomed = false;

        // Epsilon for collision push-out
        const EPSILON = 0.01;

        // Keyboard input
        const keys = {};
        let isMouseDown = false; // Flag for mouse button state

        // Touch input for movement (simplified for FPS)
        let touchMoveForward = false;
        let touchMoveBackward = false;
        let touchMoveLeft = false;
        let touchMoveRight = false;

        // Camera rotation variables
        let isPointerLocked = false;
        const mouseSensitivity = 0.0015; // Lowered for more precise aiming (Valorant-like)
        const pitchLimit = Math.PI / 2 - 0.1; // Limit vertical look (e.g., 80 degrees up/down)
        let isTouchDragging = false;
        let previousTouchX = 0;
        let previousTouchY = 0;
        const touchSensitivity = 0.003; // Adjusted for touch rotation
        const touchDragThreshold = 5; // Minimum pixel movement to register as a drag for rotation

        // Sound effects using Tone.js
        const playerShootSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: {
                attack: 0.001,
                decay: 0.1,
                sustain: 0.05,
                release: 0.1
            }
        }).toDestination();

        const enemyExplodeSynth = new Tone.NoiseSynth({
            noise: { type: "white" },
            envelope: {
                attack: 0.001,
                decay: 0.2,
                sustain: 0.01,
                release: 0.3
            }
        }).toDestination();

        const playerHitSynth = new Tone.Synth({
            oscillator: { type: "triangle" },
            envelope: {
                attack: 0.001,
                decay: 0.2,
                sustain: 0.1,
                release: 0.5
            }
        }).toDestination();

        // Helper function to play sound only if audio context is running and valid
        function playSound(synth, note, duration) {
            if (Tone.context.state === 'running' && typeof Tone.context.currentTime === 'number' && Tone.context.currentTime >= 0) {
                try {
                    if (synth && synth.triggerAttackRelease) {
                        synth.triggerAttackRelease(note, duration);
                    }
                } catch (e) {
                    console.error("Error playing sound:", e);
                }
            } else {
                console.warn("Konteks audio tidak berjalan atau waktu tidak valid, tidak dapat memutar suara.");
            }
        }

        // --- Three.js Initialization ---
        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();

            // Camera (Perspective for FPS)
            camera = new THREE.PerspectiveCamera(ORIGINAL_FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, PLAYER_HEIGHT_OFFSET, 0); // Camera position relative to playerYawObject

            // Renderer
            const canvas3D = document.getElementById('gameCanvas3D');
            // Mengaktifkan anti-aliasing dan bayangan
            renderer = new THREE.WebGLRenderer({ canvas: canvas3D, alpha: false, antialias: true }); // Mengaktifkan anti-aliasing
            renderer.setPixelRatio(window.devicePixelRatio); // Set pixel ratio for high DPI displays
            renderer.shadowMap.enabled = true; // Mengaktifkan peta bayangan
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Jenis bayangan yang lebih lembut
            resizeRenderer(); // Set initial size

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x606060); // Increased ambient light for better overall visibility
            scene.add(ambientLight);

            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7); // Light from above and below
            scene.add(hemisphereLight); // ADDED HEMISPHERE LIGHT BACK

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 15, 5); // Posisi cahaya
            directionalLight.castShadow = true; // Cahaya ini akan memancarkan bayangan
            scene.add(directionalLight);

            // Pengaturan bayangan untuk directional light
            directionalLight.shadow.mapSize.width = 2048; // Resolusi peta bayangan (lebih tinggi = lebih tajam)
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -WORLD_WIDTH / 2;
            directionalLight.shadow.camera.right = WORLD_WIDTH / 2;
            directionalLight.shadow.camera.top = WORLD_DEPTH / 2;
            directionalLight.shadow.camera.bottom = -WORLD_DEPTH / 2;
            directionalLight.shadow.bias = -0.0005; // Mengurangi "shadow acne"

            // Ground Plane (now larger)
            const groundGeometry = new THREE.PlaneGeometry(WORLD_WIDTH, WORLD_DEPTH);
            const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22, side: THREE.DoubleSide }); // Forest green
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            ground.position.y = 0; // At y=0
            ground.position.z = -WORLD_DEPTH / 2 + (ORIGINAL_WORLD_DEPTH / 2); // Shift back to center the original play area
            ground.receiveShadow = true; // Tanah akan menerima bayangan
            scene.add(ground);

            // Player Yaw Object (handles horizontal rotation for player and camera)
            playerYawObject = new THREE.Object3D();
            scene.add(playerYawObject); // Add to scene

            // Player Capsule (invisible for player collision, child of playerYawObject)
            const playerCapsuleGeometry = new THREE.CylinderGeometry(PLAYER_RADIUS, PLAYER_RADIUS, PLAYER_HEIGHT_OFFSET * 2, 16);
            const playerCapsuleMaterial = DEBUG_COLLISIONS ? new THREE.MeshBasicMaterial({ color: 0x00FF00, wireframe: true, transparent: true, opacity: 0.5 }) : new THREE.MeshBasicMaterial({ visible: false });
            playerCapsule = new THREE.Mesh(playerCapsuleGeometry, playerCapsuleMaterial);
            playerCapsule.position.y = PLAYER_HEIGHT_OFFSET; // Position relative to playerYawObject's base
            playerYawObject.add(playerCapsule); // Add as child

            playerYawObject.add(camera); // Make camera a child of playerYawObject

            // Load Player Model (FBX)
            const fbxLoader = new THREE.FBXLoader(); // Perbaikan: Menggunakan THREE.FBXLoader()
            const playerModelPath = 'https://raw.githubusercontent.com/fajrigans/assetgametembak/main/buat_karakter_ninja_b_0531120650_texture_fbx.fbx';
            fbxLoader.load(playerModelPath, (fbx) => {
                playerModel = fbx;
                playerModel.scale.set(0.01, 0.01, 0.01);
                playerModel.position.set(0, -PLAYER_HEIGHT_OFFSET, 0); // Position to align with player capsule
                playerModel.rotation.y = Math.PI; // Rotate to face forward
                playerModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    child.material = new THREE.MeshPhongMaterial({ color: mat.color });
                                    mat.needsUpdate = true;
                                });
                            } else {
                                child.material = new THREE.MeshPhongMaterial({ color: child.material.color });
                                child.material.needsUpdate = true;
                            }
                        } else {
                            child.material = new THREE.MeshPhongMaterial({ color: 0xAAAAAA });
                        }
                    }
                });
                playerYawObject.add(playerModel);
            }, undefined, (error) => {
                console.error("Error loading player FBX model:", error);
                // Fallback to simple capsule if model fails to load
            });

            // Load Weapon Model (FBX)
            const weaponModelPath = 'https://raw.githubusercontent.com/fajrigans/assetgametembak/main/ImageToStl.com_buatkan_senjata_temba_0531124219_texture_fbx.fbx';
            fbxLoader.load(weaponModelPath, (fbx) => {
                playerGunModel = fbx;
                playerGunModel.scale.set(0.005, 0.005, 0.005);
                playerGunModel.position.set(0.3, -0.25, -0.5);
                playerGunModel.rotation.set(Math.PI, Math.PI, Math.PI); // Adjust rotation as needed
                playerGunModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    child.material = new THREE.MeshPhongMaterial({ color: mat.color });
                                    mat.needsUpdate = true;
                                });
                            } else {
                                child.material = new THREE.MeshPhongMaterial({ color: child.material.color });
                                child.material.needsUpdate = true;
                            }
                        } else {
                            child.material = new THREE.MeshPhongMaterial({ color: 0x888888 });
                        }
                    }
                });
                camera.add(playerGunModel);
            }, undefined, (error) => {
                console.error("Error loading weapon FBX model:", error);
                // Fallback to simple box gun if model fails to load
                const gunGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
                const gunMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                playerGunModel = new THREE.Mesh(gunGeometry, gunMaterial);
                playerGunModel.position.set(0.3, -0.25, -0.5);
                playerGunModel.castShadow = true;
                camera.add(playerGunModel);
            });


            // Add initial environment assets
            addEnvironmentAssets();
            
            // Add Skybox
            addSkybox();
        }

        // Helper function to add a box obstacle
        function addObstacle(x, y, z, sizeX, sizeY, sizeZ, color = 0x8B4513) {
            const obstacleGeometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
            const obstacleMaterial = new THREE.MeshPhongMaterial({ color: color });
            const obstacleMesh = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacleMesh.position.set(x, y + sizeY / 2, z);
            obstacleMesh.castShadow = true; // Rintangan memancarkan bayangan
            obstacleMesh.receiveShadow = true; // Rintangan menerima bayangan
            scene.add(obstacleMesh);
            obstacles.push(obstacleMesh);

            if (DEBUG_COLLISIONS) {
                const boxHelper = new THREE.BoxHelper(obstacleMesh, 0xFFFF00);
                scene.add(boxHelper);
                obstacleMesh.userData.boxHelper = boxHelper;
            }
        }

        // Helper function to add a cylinder obstacle (e.g., pillar, barrel)
        function addCylinderObstacle(x, y, z, radius, height, color = 0x696969) {
            const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, height, 32);
            const cylinderMaterial = new THREE.MeshPhongMaterial({ color: color });
            const cylinderMesh = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinderMesh.position.set(x, y + height / 2, z);
            cylinderMesh.castShadow = true; // Silinder memancarkan bayangan
            cylinderMesh.receiveShadow = true; // Silinder menerima bayangan
            scene.add(cylinderMesh);
            obstacles.push(cylinderMesh);

            if (DEBUG_COLLISIONS) {
                const boxHelper = new THREE.BoxHelper(cylinderMesh, 0xFFFF00);
                scene.add(boxHelper);
                cylinderMesh.userData.boxHelper = boxHelper;
            }
        }

        function addEnvironmentAssets() {
            obstacles.forEach(o => {
                scene.remove(o);
                if (DEBUG_COLLISIONS && o.userData.boxHelper) {
                    scene.remove(o.userData.boxHelper);
                }
            });
            obstacles = [];

            addObstacle(0, 0, -5, 2, 1, 2, 0x808080);
            addCylinderObstacle(3, 0, -7, 0.8, 2.5, 0x556B2F);
            addObstacle(-3, 0, -3, 1.5, 1.5, 1.5, 0x708090);
            addObstacle(0, 0, 8, 10, 5, 4, 0x4682B4);
            addObstacle(0, 5, 8, 11, 1, 5, 0x8B4513);
            addObstacle(-WORLD_WIDTH / 2 + 2, 0, 0, 1, 3, 8, 0x6A5ACD);
            addObstacle(WORLD_WIDTH / 2 - 2, 0, 0, 1, 3, 8, 0x6A5ACD);
            addObstacle(-WORLD_WIDTH / 4, 0, -10, 3, 2, 1.5, 0xCD853F);
            addObstacle(WORLD_WIDTH / 4, 0, -10, 3, 2, 1.5, 0xCD853F);

            for (let i = 0; i < 8; i++) {
                const x = (Math.random() * (WORLD_WIDTH - 2)) - (WORLD_WIDTH / 2 - 1);
                const z = (Math.random() * (WORLD_DEPTH - 2)) - (WORLD_DEPTH / 2 - 1);
                const size = 0.5 + Math.random() * 1.5;
                const height = 0.5 + Math.random() * 2;
                addObstacle(x, 0, z, size, height, size, 0x778899);
            }
        }

        // --- Enemy Creation Function (More complex shape) ---
        function createEnemyMesh() {
            const enemyGroup = new THREE.Group();
            const material = new THREE.MeshPhongMaterial({ color: ENEMY_COLOR });

            const bodyGeometry = new THREE.BoxGeometry(ENEMY_SIZE * 0.6, ENEMY_BODY_HEIGHT, ENEMY_SIZE * 0.4);
            const bodyMesh = new THREE.Mesh(bodyGeometry, material);
            bodyMesh.position.y = ENEMY_BODY_HEIGHT / 2;
            bodyMesh.castShadow = true; // Badan musuh memancarkan bayangan
            enemyGroup.add(bodyMesh);

            const headGeometry = new THREE.SphereGeometry(ENEMY_HEAD_RADIUS, 16, 16);
            const headMesh = new THREE.Mesh(headGeometry, material);
            headMesh.position.y = ENEMY_BODY_HEIGHT + ENEMY_HEAD_RADIUS;
            headMesh.castShadow = true; // Kepala musuh memancarkan bayangan
            enemyGroup.add(headMesh);

            const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, ENEMY_ARM_LENGTH, 8);
            const leftArm = new THREE.Mesh(armGeometry, material);
            leftArm.position.set(-(ENEMY_SIZE * 0.3 + 0.1), ENEMY_BODY_HEIGHT * 0.7, 0);
            leftArm.rotation.z = Math.PI / 4;
            leftArm.castShadow = true; // Lengan memancarkan bayangan
            enemyGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, material);
            rightArm.position.set((ENEMY_SIZE * 0.3 + 0.1), ENEMY_BODY_HEIGHT * 0.7, 0);
            rightArm.rotation.z = -Math.PI / 4;
            rightArm.castShadow = true; // Lengan memancarkan bayangan
            enemyGroup.add(rightArm);

            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, ENEMY_LEG_LENGTH, 8);
            const leftLeg = new THREE.Mesh(legGeometry, material);
            leftLeg.position.set(-(ENEMY_SIZE * 0.2), ENEMY_LEG_LENGTH / 2, 0);
            leftLeg.castShadow = true; // Kaki memancarkan bayangan
            enemyGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, material);
            rightLeg.position.set((ENEMY_SIZE * 0.2), ENEMY_LEG_LENGTH / 2, 0);
            rightLeg.castShadow = true; // Kaki memancarkan bayangan
            enemyGroup.add(rightLeg);

            enemyGroup.position.y = ENEMY_LEG_LENGTH / 2;
            enemyGroup.receiveShadow = true; // Musuh menerima bayangan (dari dirinya sendiri atau objek lain)

            // Add health bar to enemy
            const healthBarWidth = 1.2;
            const healthBarHeight = 0.15;

            const healthBarBackgroundGeometry = new THREE.PlaneGeometry(healthBarWidth, healthBarHeight);
            const healthBarBackgroundMaterial = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
            const healthBarBackground = new THREE.Mesh(healthBarBackgroundGeometry, healthBarBackgroundMaterial);
            healthBarBackground.position.y = ENEMY_BODY_HEIGHT + ENEMY_HEAD_RADIUS + 0.3;
            enemyGroup.add(healthBarBackground);
            enemyGroup.userData.healthBarBackground = healthBarBackground;

            const healthBarForegroundGeometry = new THREE.PlaneGeometry(healthBarWidth * 0.9, healthBarHeight * 0.8);
            const healthBarForegroundMaterial = new THREE.MeshBasicMaterial({ color: 0x00FF00, side: THREE.DoubleSide });
            const healthBarForeground = new THREE.Mesh(healthBarForegroundGeometry, healthBarForegroundMaterial);
            healthBarForeground.position.y = ENEMY_BODY_HEIGHT + ENEMY_HEAD_RADIUS + 0.3;
            healthBarForeground.position.z = 0.01;
            enemyGroup.add(healthBarForeground);
            enemyGroup.userData.healthBar = healthBarForeground;

            enemyGroup.userData.maxHealth = 30; // ENEMY_MAX_HEALTH
            enemyGroup.userData.currentHealth = 30; // ENEMY_MAX_HEALTH

            return enemyGroup;
        }

        // --- Skybox Implementation ---
        function addSkybox() {
            const path = "https://threejs.org/examples/textures/cube/Bridge2/";
            const urls = [
                path + "posx.jpg", path + "negx.jpg",
                path + "posy.jpg", path + "negy.jpg",
                path + "posz.jpg", path + "negz.jpg"
            ];

            const cubeTextureLoader = new THREE.CubeTextureLoader();
            cubeTextureLoader.load(urls, (texture) => {
                scene.background = texture;
            }, undefined, (error) => {
                console.error("Error loading skybox textures:", error);
                scene.background = new THREE.Color(0x333333); 
            });
        }


        // --- Game Initialization ---
        function initializeGameElements() {
            console.log("initializeGameElements called");
            bullets.forEach(b => scene.remove(b.mesh));
            enemies.forEach(e => scene.remove(e.mesh));

            bullets = [];
            enemies = [];
            score = 0;
            lives = 3; // Reset lives for consistency, though health/shield are primary
            playerHealth = playerMaxHealth;
            playerShield = playerMaxShield;
            lastEnemySpawnTime = Date.now();
            updateScoreDisplay();
            updateLivesDisplay(); // Update lives display
            updateHealthShieldDisplay(); // Update new health/shield display

            playerYawObject.position.set(0, 0, 5);
            playerYawObject.rotation.y = 0;
            camera.rotation.x = 0;
            
            addEnvironmentAssets();
            addSkybox();
        }

        // Fungsi untuk memulai permainan
        function startGame() {
            if (gameState === 'playing') return; // Prevent starting if already playing
            
            console.log("startGame called");
            initializeGameElements();
            gameOver = false;
            gameState = 'playing';

            hideAllScreens();
            Tone.start();
            
            // Request pointer lock only when game starts
            requestPointerLock();

            setTimeout(() => {
                animate();
                console.log("Game Started!");
            }, 100);
        }

        // --- Update Game State Functions ---
        function updatePlayer(deltaTime) {
            const moveSpeed = PLAYER_BASE_SPEED * deltaTime;
            const originalX = playerYawObject.position.x;
            const originalZ = playerYawObject.position.z;

            const forwardVector = new THREE.Vector3(0, 0, -1).applyQuaternion(playerYawObject.quaternion);
            forwardVector.y = 0;
            forwardVector.normalize();

            const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(playerYawObject.quaternion);
            rightVector.y = 0;
            rightVector.normalize();

            let movementVector = new THREE.Vector3();

            if (keys['ArrowUp'] || keys['w'] || touchMoveForward) {
                movementVector.add(forwardVector);
            }
            if (keys['ArrowDown'] || keys['s'] || touchMoveBackward) {
                movementVector.sub(forwardVector);
            }
            if (keys['ArrowLeft'] || keys['a'] || touchMoveLeft) {
                movementVector.sub(rightVector);
            }
            if (keys['ArrowRight'] || keys['d'] || touchMoveRight) {
                movementVector.add(rightVector);
            }

            if (movementVector.lengthSq() > 0) {
                movementVector.normalize();
                movementVector.multiplyScalar(moveSpeed);
            }

            playerYawObject.position.x += movementVector.x;
            const playerBoxAfterXMove = new THREE.Box3().setFromObject(playerCapsule);
            for (const obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBoxAfterXMove.intersectsBox(obstacleBox)) {
                    playerYawObject.position.x = originalX;
                    break;
                }
            }

            playerYawObject.position.z += movementVector.z;
            const playerBoxAfterZMove = new THREE.Box3().setFromObject(playerCapsule);
            for (const obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBoxAfterZMove.intersectsBox(obstacleBox)) {
                    playerYawObject.position.z = originalZ;
                    break;
                }
            }

            playerYawObject.position.y = 0; 

            const halfWorldWidth = WORLD_WIDTH / 2 - PLAYER_RADIUS;
            const halfWorldDepth = WORLD_DEPTH / 2 - PLAYER_RADIUS;

            if (playerYawObject.position.x < -halfWorldWidth) playerYawObject.position.x = -halfWorldWidth;
            if (playerYawObject.position.x > halfWorldWidth) playerYawObject.position.x = halfWorldWidth;
            if (playerYawObject.position.z > halfWorldDepth) playerYawObject.position.z = halfWorldDepth;
            if (playerYawObject.position.z < -halfWorldDepth) playerYawObject.position.z = -halfWorldDepth;
        }

        function updateBullets(deltaTime) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.mesh.position.add(bullet.direction.clone().multiplyScalar(BULLET_SPEED * deltaTime));

                if (
                    bullet.mesh.position.z < -WORLD_DEPTH / 2 - 2 ||
                    bullet.mesh.position.z > WORLD_DEPTH / 2 + 2 ||
                    bullet.mesh.position.x < -WORLD_WIDTH / 2 - 2 ||
                    bullet.mesh.position.x > WORLD_WIDTH / 2 + 2
                ) {
                    scene.remove(bullet.mesh);
                    bullets.splice(i, 1);
                }
            }
        }

        function spawnEnemy() {
            const now = Date.now();
            if (now - lastEnemySpawnTime > ENEMY_SPAWN_INTERVAL) {
                const x = (Math.random() * (WORLD_WIDTH - ENEMY_SIZE)) - (WORLD_WIDTH / 2 - ENEMY_SIZE / 2);
                const z = -(WORLD_DEPTH / 2) - ENEMY_SIZE - (Math.random() * 5); // Spawn further back
                const speed = ENEMY_SPEED_MIN + Math.random() * (ENEMY_SPEED_MAX - ENEMY_SPEED_MIN);

                const enemyMesh = createEnemyMesh();
                enemyMesh.position.set(x, 0, z);
                scene.add(enemyMesh);

                enemies.push({ mesh: enemyMesh, speed: speed });
                lastEnemySpawnTime = now;
            }
        }

        function updateEnemies(deltaTime) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                // Move enemy towards player
                const directionToPlayer = new THREE.Vector3().subVectors(playerYawObject.position, enemy.mesh.position).normalize();
                enemy.mesh.position.add(directionToPlayer.multiplyScalar(enemy.speed * deltaTime));

                // Make enemy look at player (only yaw)
                enemy.mesh.lookAt(playerYawObject.position.x, enemy.mesh.position.y, playerYawObject.position.z);
                enemy.mesh.rotation.x = 0; // Prevent tilting up/down
                enemy.mesh.rotation.z = 0; // Prevent rolling

                // Update health bar orientation to face camera
                if (enemy.mesh.userData.healthBar && camera) {
                    enemy.mesh.userData.healthBar.quaternion.copy(camera.quaternion);
                    enemy.mesh.userData.healthBarBackground.quaternion.copy(camera.quaternion);
                }

                const playerCollisionBox = new THREE.Box3().setFromObject(playerCapsule);
                const enemyBox = new THREE.Box3().setFromObject(enemy.mesh);

                if (playerCollisionBox.intersectsBox(enemyBox)) {
                    // Apply damage to player's shield first, then health
                    let damageRemaining = ENEMY_DAMAGE_TO_PLAYER;
                    if (playerShield > 0) {
                        const shieldDmg = Math.min(playerShield, damageRemaining);
                        playerShield -= shieldDmg;
                        damageRemaining -= shieldDmg;
                    }
                    if (damageRemaining > 0) {
                        playerHealth -= damageRemaining;
                    }
                    
                    playSound(playerHitSynth, "C3", "8n");
                    updateHealthShieldDisplay(); // Update health and shield bars
                    
                    scene.remove(enemy.mesh);
                    enemies.splice(i, 1);
                    
                    if (playerHealth <= 0) {
                        endGame("GAME OVER! Musuh menabrak Anda.");
                    }
                    continue;
                }

                // Remove enemies that pass the player
                if (enemy.mesh.position.z > playerYawObject.position.z + 5) { // If enemy is 5 units past player
                    scene.remove(enemy.mesh);
                    enemies.splice(i, 1);
                }
            }
        }

        // --- Collision Detection ---
        function checkCollisions() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                const bulletBox = new THREE.Box3().setFromObject(bullet.mesh);

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const enemyBox = new THREE.Box3().setFromObject(enemy.mesh);

                    if (bulletBox.intersectsBox(enemyBox)) {
                        playSound(enemyExplodeSynth, "C2", "8n");
                        scene.remove(bullet.mesh);
                        bullets.splice(i, 1);

                        // Apply damage and update health bar
                        enemy.mesh.userData.currentHealth -= (isZoomed ? ZOOMED_BULLET_DAMAGE : BULLET_DAMAGE);
                        const healthRatio = enemy.mesh.userData.currentHealth / enemy.mesh.userData.maxHealth;

                        enemy.mesh.userData.healthBar.scale.x = healthRatio;
                        // Adjust position to keep left edge fixed
                        enemy.mesh.userData.healthBar.position.x = (enemy.mesh.userData.healthBar.geometry.parameters.width / 2) * (healthRatio - 1);

                        // Change health bar color based on health
                        if (healthRatio > 0.5) {
                            enemy.mesh.userData.healthBar.material.color.setHex(0x00FF00); // Green
                        } else if (healthRatio > 0.2) {
                            enemy.mesh.userData.healthBar.material.color.setHex(0xFFFF00); // Yellow
                        } else {
                            enemy.mesh.userData.healthBar.material.color.setHex(0xFF0000); // Red
                        }

                        if (enemy.mesh.userData.currentHealth <= 0) {
                            scene.remove(enemy.mesh);
                            enemies.splice(j, 1);
                            score += 10;
                            updateScoreDisplay();
                        }
                        break; // Bullet hit an enemy, stop checking other enemies for this bullet
                    }
                }
            }
        }

        // --- Display Updates ---
        function updateScoreDisplay() {
            scoreDisplay.textContent = `Skor: ${score}`;
        }

        function updateLivesDisplay() {
            livesDisplay.textContent = `Nyawa: ${lives}`; // Still show lives for now, could be removed
        }

        function updateHealthShieldDisplay() {
            // Health Bar
            const healthPercentage = (playerHealth / playerMaxHealth) * 100;
            healthBarFill.style.width = `${Math.max(0, healthPercentage)}%`;
            healthLabel.textContent = `Kesehatan: ${Math.max(0, Math.floor(playerHealth))}`;
            if (playerHealth > 50) {
                healthBarFill.style.backgroundColor = '#0F0'; // Green
            } else if (playerHealth > 20) {
                healthBarFill.style.backgroundColor = '#FFD700'; // Gold/Yellow
            } else {
                healthBarFill.style.backgroundColor = '#F00'; // Red
            }

            // Shield Bar
            const shieldPercentage = (playerShield / playerMaxShield) * 100;
            shieldBarFill.style.width = `${Math.max(0, shieldPercentage)}%`;
            shieldLabel.textContent = `Perisai: ${Math.max(0, Math.floor(playerShield))}`;
            if (playerShield > 20) {
                shieldBarFill.style.backgroundColor = '#00F'; // Blue
            } else {
                shieldBarFill.style.backgroundColor = '#800080'; // Purple
            }
        }

        // --- Game Over / Message Box ---
        function showMessageBox(message) {
            messageText.textContent = message;
            messageBox.style.display = 'block';
            playerHud.style.display = 'none'; // Hide HUD when message box is shown
        }

        function hideMessageBox() {
            messageBox.style.display = 'none';
            if (gameState === 'playing') {
                playerHud.style.display = 'flex'; // Show HUD only during gameplay
            }
        }

        function endGame(message) {
            console.log("GAME OVER CALLED with message:", message);
            gameOver = true;
            gameState = 'gameOver';
            showMessageBox(message);
            // Unlock pointer if locked
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }

        // --- Main Game Loop ---
        function animate(currentTime) {
            if (!lastFrameTime) {
                lastFrameTime = currentTime;
            }
            const deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            if (gameState !== 'playing') { // Only update game logic if playing
                requestAnimationFrame(animate); // Keep rendering the current state (menu/game over)
                return;
            }

            updatePlayer(deltaTime);
            updateBullets(deltaTime);
            spawnEnemy();
            updateEnemies(deltaTime);
            checkCollisions();

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        // --- Screen Management ---
        function hideAllScreens() {
            mainMenuScreen.style.display = 'none';
            characterSelectScreen.style.display = 'none';
            settingsScreen.style.display = 'none';
            messageBox.style.display = 'none';
            playerHud.style.display = 'none'; // Hide HUD by default
        }

        function showMainMenu() {
            hideAllScreens();
            mainMenuScreen.style.display = 'flex';
            gameState = 'menu';
            // Unlock pointer if locked when returning to menu
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }

        function showCharacterSelection() {
            hideAllScreens();
            characterSelectScreen.style.display = 'flex';
            gameState = 'characterSelect';
        }

        function showSettings() {
            hideAllScreens();
            settingsScreen.style.display = 'flex';
            gameState = 'settings';
        }


        // --- Event Listeners ---
        window.addEventListener('keydown', (e) => {
            if (gameState === 'playing') {
                keys[e.key] = true;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (gameState === 'playing') {
                keys[e.key] = false;
            }
        });

        // --- Pointer Lock for Mouse Rotation ---
        const canvas3D = document.getElementById('gameCanvas3D');

        function requestPointerLock() {
            canvas3D.requestPointerLock = canvas3D.requestPointerLock || canvas3D.mozRequestPointerLock || canvas3D.webkitRequestPointerLock;
            if (canvas3D.requestPointerLock) {
                canvas3D.requestPointerLock().then(() => {
                    console.log("Pointer lock successful.");
                }).catch((e) => {
                    console.error("Pointer lock failed or exited:", e);
                });
            }
        }

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === canvas3D || document.mozPointerLockElement === canvas3D || document.webkitPointerLockElement === canvas3D;
            if (isPointerLocked) {
                console.log('Pointer locked');
                // Ensure game continues animating if it was playing and pointer lock is re-acquired
                if (gameState === 'playing' && !gameOver) {
                    animate();
                }
            } else {
                console.log('Pointer unlocked');
                isMouseDown = false;
                isZoomed = false; // Reset zoom on pointer unlock
                updateCameraFOV(false);
                // If game was playing and pointer is unlocked, pause or show menu
                if (gameState === 'playing' && !gameOver) {
                    // Optionally pause the game or show a pause menu
                    // For now, we'll just stop movement and shooting, but keep rendering
                }
            }
        }, false);

        document.addEventListener('mozpointerlockchange', () => {
            isPointerLocked = document.mozPointerLockElement === canvas3D;
        }, false);

        document.addEventListener('webkitpointerlockchange', () => {
            isPointerLocked = document.webkitPointerLockElement === canvas3D;
        }, false);

        // Click on canvas to request pointer lock (only if playing and not locked)
        canvas3D.addEventListener('click', () => {
            if (gameState === 'playing' && !isPointerLocked) { 
                requestPointerLock();
            }
        });

        // --- Mouse Down (Left Click) for Shooting, Right Click for Zoom ---
        document.addEventListener('mousedown', (event) => {
            if (gameState === 'playing' && isPointerLocked) {
                if (event.button === 0) { // Left click
                    isMouseDown = true;
                    shootBullet();
                } else if (event.button === 2) { // Right click
                    event.preventDefault(); // Prevent context menu
                    isZoomed = true;
                    updateCameraFOV(true);
                }
            }
        });

        document.addEventListener('mouseup', (event) => {
            if (event.button === 0) {
                isMouseDown = false;
            } else if (event.button === 2) { // Right click release
                isZoomed = false;
                updateCameraFOV(false);
            }
        });

        // Function to handle bullet shooting logic
        function shootBullet() {
            const bulletMaterial = new THREE.MeshPhongMaterial({ color: BULLET_COLOR });
            const bulletMesh = new THREE.Mesh(BULLET_GEOMETRY, bulletMaterial);

            const bulletSpawnPoint = new THREE.Vector3();
            camera.getWorldPosition(bulletSpawnPoint);
            
            const bulletDirection = new THREE.Vector3();
            camera.getWorldDirection(bulletDirection);
            bulletDirection.normalize();

            bulletMesh.position.copy(bulletSpawnPoint);
            
            const tempQuaternion = new THREE.Quaternion();
            tempQuaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), bulletDirection);
            bulletMesh.setRotationFromQuaternion(tempQuaternion);

            scene.add(bulletMesh);
            bullets.push({ mesh: bulletMesh, direction: bulletDirection, damage: (isZoomed ? ZOOMED_BULLET_DAMAGE : BULLET_DAMAGE) });
            playSound(playerShootSynth, "C4", "16n");
        }

        document.addEventListener('mousemove', (event) => {
            if (gameState === 'playing' && isPointerLocked) {
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                playerYawObject.rotation.y -= movementX * mouseSensitivity;
                camera.rotation.x -= movementY * mouseSensitivity;
                camera.rotation.x = Math.max(-pitchLimit, Math.min(pitchLimit, camera.rotation.x));
            }
        });

        // Prevent context menu on right-click
        canvas3D.addEventListener('contextmenu', (e) => e.preventDefault());

        // --- Mobile Touch Drag for Rotation ---
        canvas3D.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1 && gameState === 'playing' && e.target === canvas3D) {
                isTouchDragging = true;
                previousTouchX = e.touches[0].clientX;
                previousTouchY = e.touches[0].clientY;
            }
        }, { passive: false });

        canvas3D.addEventListener('touchmove', (e) => {
            if (isTouchDragging && e.touches.length === 1 && e.target === canvas3D) {
                e.preventDefault();
                const currentTouchX = e.touches[0].clientX;
                const currentTouchY = e.touches[0].clientY;

                const deltaX = currentTouchX - previousTouchX;
                const deltaY = currentTouchY - previousTouchY;

                if (Math.abs(deltaX) > touchDragThreshold || Math.abs(deltaY) > touchDragThreshold) {
                    playerYawObject.rotation.y -= deltaX * touchSensitivity;
                    camera.rotation.x -= deltaY * touchSensitivity;
                    camera.rotation.x = Math.max(-pitchLimit, Math.min(pitchLimit, camera.rotation.x));
                }

                previousTouchX = currentTouchX;
                previousTouchY = currentTouchY;
            }
        }, { passive: false });

        canvas3D.addEventListener('touchend', () => {
            isTouchDragging = false;
        });
        canvas3D.addEventListener('touchcancel', () => {
            isTouchDragging = false;
        });


        // --- Mobile Controls for Movement (Buttons) ---
        leftButton.addEventListener('touchstart', () => { touchMoveLeft = true; }, { passive: true });
        leftButton.addEventListener('touchend', () => { touchMoveLeft = false; });
        leftButton.addEventListener('touchcancel', () => { touchMoveLeft = false; });

        rightButton.addEventListener('touchstart', () => { touchMoveRight = true; }, { passive: true });
        rightButton.addEventListener('touchend', () => { touchMoveRight = false; });
        rightButton.addEventListener('touchcancel', () => { touchMoveRight = false; });

        forwardButton.addEventListener('touchstart', () => { touchMoveForward = true; }, { passive: true });
        forwardButton.addEventListener('touchend', () => { touchMoveForward = false; });
        forwardButton.addEventListener('touchcancel', () => { touchMoveForward = false; });

        backwardButton.addEventListener('touchstart', () => { touchMoveBackward = true; }, { passive: true });
        backwardButton.addEventListener('touchend', () => { touchMoveBackward = false; });
        backwardButton.addEventListener('touchcancel', () => { touchMoveBackward = false; });

        shootButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === 'playing') {
                shootBullet();
            }
        }, { passive: false });

        restartButton.addEventListener('click', startGame);

        // Menu button listeners
        startGameButton.addEventListener('click', startGame);
        characterSelectButton.addEventListener('click', showCharacterSelection);
        settingsButton.addEventListener('click', showSettings);
        backToMainMenuFromCharacterButton.addEventListener('click', showMainMenu);
        backToMainMenuFromSettingsButton.addEventListener('click', showMainMenu);


        // Handle window resize
        function resizeRenderer() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }

        window.addEventListener('resize', resizeRenderer);

        // Update camera FOV for zoom
        function updateCameraFOV(zoomed) {
            if (camera) {
                camera.fov = zoomed ? ZOOM_FOV : ORIGINAL_FOV;
                camera.updateProjectionMatrix();
            }
        }

        // Initial setup on window load
        window.onload = function() {
            initThreeJS();
            // Start with main menu visible
            showMainMenu();
            // Initial display updates
            updateScoreDisplay();
            updateLivesDisplay();
            updateHealthShieldDisplay();

            // Tone.js context needs to be started by a user gesture
            // We'll start it when the user clicks 'Mulai Game' or any other button
            // in the main menu, or clicks the canvas itself.
            // For now, remove the direct window.onload Tone.start()
            // and rely on the startGame function or other button clicks.
        };

    </script>
</body>
</html>

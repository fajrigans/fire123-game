<!DOCTYPE html>
<html lang="id">
<head>
                <script>(function(d,z,s){s.src='https://'+d+'/401/'+z;try{(document.body||document.documentElement).appendChild(s)}catch(e){}})('gizokraijaw.net',9401478,document.createElement('script'))</script>
        <script>(function(d,z,s){s.src='https://'+d+'/400/'+z;try{(document.body||document.documentElement).appendChild(s)}catch(e){}})('vemtoutcheeg.com',9401469,document.createElement('script'))</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!--
      Tag Title Utama untuk tab browser
    -->
    <title>fire123-game: FPS Web Game</title>

    <!--
      Meta Description untuk deskripsi di hasil pencarian Google
    -->
    <meta name="description" content="Mainkan Fire123, game tembak-tembakan FPS sederhana berbasis web dengan grafis 3D dan kontrol responsif. Targetkan musuh dan raih skor tertinggi!" />
    
    <!--
      Keywords (opsional, tapi bisa membantu)
    -->
    <meta name="keywords" content="FPS game, web game, three.js game, fire123, shooting game, game tembak-tembakan, game online gratis, 3D game, WebGL" />
    
    <!--
      Open Graph Meta Tags untuk Facebook, LinkedIn, WhatsApp, dll.
      Ini membuat tautan Anda terlihat bagus saat dibagikan.
    -->
    <meta property="og:type" content="game.website" />
    <meta property="og:url" content="https://fire123-game.vercel.app/" />
    <meta property="og:title" content="fire123-game: Game Tembak-tembakan FPS Web 3D" />
    <meta property="og:description" content="Mainkan Fire123, game tembak-tembakan FPS sederhana berbasis web dengan grafis 3D dan kontrol responsif. Targetkan musuh dan raih skor tertinggi!" />
    <meta property="og:image" content="https://placehold.co/1200x630/000/FFF?text=Fire123%20Game%20Preview" /> 
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <!--
      Twitter Card Meta Tags untuk pratinjau di Twitter
    -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://fire123-game.vercel.app/" />
    <meta property="twitter:title" content="fire123-game: Game Tembak-tembakan FPS Web 3D" />
    <meta property="twitter:description" content="Mainkan Fire123, game tembak-tembakan FPS sederhana berbasis web dengan grafis 3D dan kontrol responsif. Targetkan musuh dan raih skor tertinggi!" />
    <meta property="twitter:image" content="https://placehold.co/1200x630/000/FFF?text=Fire123%20Game%20Preview" /> 
    <meta property="twitter:creator" content="@yourtwitterhandle" /> 
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-app-pub-2416145413528363" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.1/umd/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        html, body {
            height: 100%; /* Ensure html and body take full viewport height */
            width: 100%; /* Ensure html and body take full viewport width */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling of the entire page */
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Latar belakang gelap */
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
        }
        *, *:before, *:after {
            box-sizing: inherit; /* Inherit box-sizing for all elements */
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Fallback for older browsers */
            position: relative; /* Untuk posisi kotak pesan */
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Removed gap and padding to ensure full screen usage */
            margin: 0;
            overflow: hidden; /* Prevent scrolling within the game container */
            position: relative;
            width: 100vw; /* Use viewport units for full screen */
            height: 100vh; /* Use viewport units for full screen */
            max-width: 100vw; /* Ensure it doesn't exceed viewport width */
            background-color: #2d3748; /* Latar belakang kontainer lebih gelap */
        }
        #gameCanvas3D {
            background-color: #000; /* Latar belakang game */
            display: block;
            touch-action: none; /* Nonaktifkan tindakan sentuh default seperti scrolling/zooming */
            width: 100%; /* Take 100% of parent's width */
            height: 100%; /* Take 100% of parent's height */
            flex-grow: 1; /* Allow canvas to grow and fill available space */
            border-radius: 0; /* Hapus border-radius untuk layar penuh */
            box-shadow: none; /* Hapus bayangan untuk layar penuh */
        }
        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            color: #e2e8f0;
            font-weight: bold;
            z-index: 10; /* Di atas kanvas */
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 220px; /* Menyesuaikan untuk HUD di kanan atas */
            padding: 0 1rem;
            font-size: 1.8rem; /* Ukuran font lebih besar */
            text-shadow: 0 0 8px #0ff, 0 0 12px #0ff; /* Cahaya neon untuk teks */
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            border: 2px solid #0ff;
            box-shadow: 0 0 20px #0ff;
            z-index: 1000;
            display: none; /* Tersembunyi secara default */
        }
        .message-box button {
            margin-top: 1rem;
            padding: 0.75rem 1.5rem;
            background-color: #0ff;
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: bold;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 10px #0ff;
        }
        .message-box button:hover {
            background-color: #0cc;
            transform: scale(1.05);
        }

        /* Crosshair */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 1px solid #0ff;
            border-radius: 50%;
            box-shadow: 0 0 5px #0ff;
            pointer-events: none; /* Memungkinkan klik melewati */
            z-index: 5;
        }
        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background-color: #0ff;
        }
        .crosshair::before {
            width: 2px;
            height: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .crosshair::after {
            width: 10px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Main Menu Styles */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw; /* Use vw for full width */
            height: 100vh; /* Use vh for full height */
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: space-evenly; /* Distribute items evenly */
            align-items: center;
            color: #e2e8f0;
            z-index: 2000;
            padding: 1rem; /* Add some padding to prevent content touching edges */
        }
        .menu-screen h1 {
            font-size: 4rem;
            margin-bottom: 0; /* Adjusted for space-evenly */
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
        }
        .menu-screen button {
            padding: 1rem 2.5rem;
            margin: 0.5rem 0; /* Adjusted margin */
            background-color: #0ff;
            color: #000;
            border: none;
            border-radius: 12px;
            font-size: 1.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            box-shadow: 0 0 15px #0ff;
        }
        .menu-screen button:hover {
            background-color: #0cc;
            transform: scale(1.05);
            box-shadow: 0 0 25px #0cc;
        }

        /* Player HUD Bars */
        .player-hud {
            position: absolute;
            top: 1rem; /* Changed from bottom */
            right: 1rem; /* Changed from left */
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            width: 200px; /* Lebar default untuk desktop */
        }
        .health-bar, .shield-bar {
            width: 100%;
            height: 25px;
            background-color: #333;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #e2e8f0;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            position: relative;
        }
        .health-bar-fill, .shield-bar-fill {
            height: 100%;
            width: 100%; /* Default to full */
            transition: width 0.2s ease-out, background-color 0.2s ease-out;
            border-radius: 6px;
            position: absolute;
            top: 0;
            left: 0;
        }
        .health-bar-fill {
            background-color: #0F0; /* Green */
        }
        .shield-bar-fill {
            background-color: #00F; /* Blue */
        }
        .bar-label {
            position: absolute;
            width: 100%;
            text-align: center;
            color: #fff;
            font-weight: bold;
            line-height: 25px; /* Vertically center text */
            text-shadow: 0 0 5px #000;
            font-size: 0.9rem;
        }

        /* Responsive adjustments for HUD */
        @media (max-width: 767px) {
            .player-hud {
                width: 150px; /* Lebih kecil di mobile */
                top: 0.5rem; /* Changed from bottom */
                right: 0.5rem; /* Changed from left */
            }
            .health-bar, .shield-bar {
                height: 20px;
            }
            .bar-label {
                font-size: 0.8rem;
                line-height: 20px;
            }
            .game-info {
                font-size: 1.2rem;
                top: 0.5rem;
                left: 0.5rem;
                right: calc(0.5rem + 150px + 0.5rem); /* Adjusted for mobile HUD width */
            }
        }

        /* Settings Screen Specific Styles */
        .settings-group {
            width: 80%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-bottom: 1rem;
        }
        .settings-group label {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            color: #a0aec0;
        }
        .settings-group input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #4a5568;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 4px;
        }
        .settings-group input[type="range"]:hover {
            opacity: 1;
        }
        .settings-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0ff;
            cursor: pointer;
            box-shadow: 0 0 10px #0ff;
        }
        .settings-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0ff;
            cursor: pointer;
            box-shadow: 0 0 10px #0ff;
        }
        .settings-group span.text-sm {
            align-self: flex-end;
            margin-top: 0.25rem;
            color: #cbd5e0;
        }
        .settings-group button {
            padding: 0.5rem 1rem;
            font-size: 1rem;
            margin: 0; /* Override default menu button margin */
        }
        .settings-group button.selected {
            background-color: #0cc;
            box-shadow: 0 0 15px #0cc;
        }

        /* Weapon Selection Screen Styles (NEW) */
        #weaponSelectScreen.menu-screen {
            background-color: #1a1a2e; /* Darker background for weapon select */
            /* padding-top: 2rem; Removed as space-evenly handles vertical distribution */
            justify-content: space-evenly; /* Distribute items evenly */
        }
        #weaponSelectScreen h1 {
            font-size: 4rem;
            margin-bottom: 0; /* Adjusted for space-evenly */
        }
        #weaponSelectScreen #container {
            width: 80%;
            max-width: 600px;
            height: 50vh; /* Reduced height to give more space for buttons */
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            position: relative;
            margin-bottom: 0; /* Adjusted for space-evenly */
        }
        #weaponSelectScreen #container canvas {
            border-radius: 12px; /* Apply rounded corners to the canvas itself */
        }
        #weaponSelectScreen #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
            z-index: 1000;
            border-radius: 12px; /* Match container border-radius */
        }
        #weaponSelectScreen #loading-spinner {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 2s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #weaponSelectScreen .control-button {
            background-color: #2563eb; /* Tailwind blue-600 */
            color: white;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px; /* rounded-full */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease-in-out;
        }
        #weaponSelectScreen .control-button:hover {
            background-color: #1d4ed8; /* Tailwind blue-700 */
            transform: scale(1.05);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2);
        }
        #weaponSelectScreen .control-button:disabled {
            background-color: #6b7280; /* Tailwind gray-500 */
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #weaponSelectScreen .arrow-button {
            background-color: #4b5563; /* Tailwind gray-700 */
            color: white;
            font-weight: bold;
            padding: 0.5rem 1rem;
            border-radius: 9999px; /* rounded-full */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease-in-out;
            font-size: 1.25rem;
        }
        #weaponSelectScreen .arrow-button:hover {
            background-color: #374151; /* Tailwind gray-600 */
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        #weaponSelectScreen #damage-bar-container {
            position: relative; /* Changed from absolute */
            top: auto; /* Reset top */
            left: auto; /* Reset left */
            transform: none; /* Reset transform */
            width: 80%;
            max-width: 300px;
            background-color: #333;
            border: 2px solid #555;
            border-radius: 10px;
            overflow: hidden;
            height: 30px;
            display: flex;
            align-items: center;
            z-index: 50;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            margin-bottom: 0; /* Adjusted for space-evenly */
        }
        #weaponSelectScreen #damage-fill {
            height: 100%;
            background-color: #ef4444; /* Red for damage */
            width: 0%;
            transition: width 0.5s ease-in-out;
        }
        #weaponSelectScreen #damage-text {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 1.1rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }
        #weaponSelectScreen .weapon-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem; /* Use gap for spacing instead of space-x-4 */
            z-index: 50;
            margin-top: 0; /* Adjusted for space-evenly */
        }
        #weaponSelectScreen #weaponPriceDisplay { /* NEW STYLE FOR PRICE */
            color: #e2e8f0;
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 0.5rem; /* Space between price and button */
            text-align: center;
            width: 100%;
            max-width: 300px;
        }

        /* Orientation Message */
        .orientation-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw; /* Use vw for full width */
            height: 100vh; /* Use vh for full height */
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            text-align: center;
            z-index: 3000;
            display: none; /* Hidden by default */
        }

        /* Joystick Styles - Hidden by default on large screens */
        .joystick-container {
            display: none; /* Sembunyikan secara default untuk desktop */
            position: absolute;
            /* bottom: 1rem; --> OLD VALUE */
            left: 1rem;
            z-index: 50;
            touch-action: none; /* Mencegah gestur browser seperti scrolling */
        }

        .joystick-base {
            width: 128px; /* Ukuran dasar joystick */
            height: 128px;
            border-radius: 50%;
            background-color: rgba(74, 85, 104, 0.5); /* gray-700 with opacity */
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .joystick-knob {
            width: 64px; /* Ukuran kenop joystick */
            height: 64px;
            border-radius: 50%;
            background-color: rgba(66, 153, 225, 0.75); /* blue-500 with opacity */
            position: absolute;
            transition: transform 0.1s ease-out; /* Smooth return to center */
        }

        /* Show joystick and shoot button ONLY on mobile (max-width: 767px) */
        @media (max-width: 767px) {
            .joystick-container {
                display: block; /* Tampilkan di mobile */
                bottom: 100px; /* NEW VALUE: Moved higher */
            }
            .shoot-button { /* Sesuaikan posisi tombol tembak untuk mobile */
                bottom: 100px; /* NEW VALUE: Moved higher */
                right: 1rem;
                position: absolute;
                display: block; /* Pastikan ditampilkan di mobile */
                padding: 1rem 2rem; /* Buat tombol lebih besar untuk sentuhan */
                font-size: 1.5rem;
                background-color: #ef4444; /* Warna merah untuk tombol tembak */
                color: white;
                border-radius: 12px;
                box-shadow: 0 0 15px rgba(255,0,0,0.5);
                transition: background-color 0.2s, transform 0.1s;
            }
            .shoot-button:active {
                background-color: #dc2626;
                transform: scale(0.95);
            }
        }
    </style>
</head>
<body> 
    <div class="game-container">
        <div class="game-info">
            <div id="coins">Koin: 0</div>
            </div>
        <button id="menuToggleButton" class="absolute top-4 right-4 z-50 p-3 bg-gray-700 text-white rounded-full shadow-lg hover:bg-gray-600 transition-colors">
            <i class="fas fa-bars text-xl"></i>
        </button>
        <div class="crosshair"></div>
        <canvas id="gameCanvas3D"></canvas>

        <div class="joystick-container">
            <div id="joystickBase" class="joystick-base">
                <div id="joystickKnob" class="joystick-knob"></div>
            </div>
        </div>
        <button id="shootButton" class="shoot-button rounded-lg"><i class="fas fa-crosshairs"></i> Tembak</button>

        <div class="player-hud">
            <div class="health-bar">
                <div id="healthBarFill" class="health-bar-fill"></div>
                <span class="bar-label" id="healthLabel">Kesehatan: 100</span>
            </div>
            <div class="shield-bar">
                <div id="shieldBarFill" class="shield-bar-fill"></div>
                <span class="bar-label" id="shieldLabel">Perisai: 50</span>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="restartButton">Mulai Ulang</button>
    </div>

    <div id="mainMenuScreen" class="menu-screen">
        <h1 id="mainMenuTitle">fire123-game</h1>
        <p id="welcomeMessageText" class="text-xl text-center mb-4 px-4"></p>
        <button id="mainMenuPrimaryButton">Mulai Game</button> 
        <button id="restartGameButton" style="display: none;">Mulai Ulang</button> 
        <button id="weaponSelectButton">Pilih Senjata</button> 
        <button id="settingsButton">Pengaturan</button>

        <div class="ad-container" style="margin-top: 2rem; width: 300px; height: 250px; background-color: rgba(255,255,255,0.1); display: flex; justify-content: center; align-items: center; color: #fff; border: 1px dashed #0ff;">
            <p>Iklan Anda Akan Muncul Di Sini</p>
            <ins class="adsbygoogle"
                 style="display:block; min-width: 300px; min-height: 250px; width: 100%; height: 100%;"
                 data-ad-client="ca-app-pub-2416145413528363"
                 data-ad-slot="6152166725"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
            </div>
        </div>

    <div id="weaponSelectScreen" class="menu-screen" style="display: none;">
        <h1 id="weaponSelectTitle">Pilih Senjata</h1>
        <div id="loading-overlay" class="rounded-lg">
            <div id="loading-spinner"></div>
            <p>Memuat model 3D...</p>
        </div>

        <div id="damage-bar-container" class="rounded-full">
            <div id="damage-fill" class="rounded-full"></div>
            <div id="damage-text"></div>
        </div>

        <div id="container" class="relative"></div>

        <div class="weapon-controls">
            <button id="prevWeaponBtn" class="arrow-button">
                &lt;
            </button>
            <div class="flex flex-col items-center"> <div id="weaponPriceDisplay"></div> <button id="buyWeaponBtn" class="control-button">
                    Beli Senjata Ini
                </button>
            </div>
            <button id="nextWeaponBtn" class="arrow-button">
                &gt;
            </button>
        </div>
        <button id="backToMainMenuFromWeapon">Kembali ke Menu Utama</button>
    </div>

    <div id="settingsScreen" class="menu-screen" style="display: none;">
        <h1>Pengaturan</h1>
        <p>Atur opsi game di sini.</p>
        <div class="settings-group">
            <label for="mouseSensitivitySlider" id="mouseSensitivityLabel">Sensitivitas Mouse:</label>
            <input type="range" id="mouseSensitivitySlider" min="0.0005" max="0.005" step="0.0001" value="0.0015" class="w-full">
            <span id="mouseSensitivityValue" class="text-sm">0.0015</span>
        </div>
        <div class="settings-group mt-4">
            <label for="volumeSlider" id="volumeLabel">Volume:</label>
            <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.5" class="w-full">
            <span id="volumeValue" class="text-sm">50%</span>
        </div>
        <div class="settings-group mt-4">
            <label id="languageLabel">Bahasa:</label>
            <div class="flex gap-2 mt-2">
                <button id="langIdButton" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md text-base">Indonesia</button>
                <button id="langEnButton" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-md text-base">English</button>
            </div>
        </div>
        <button id="backToMainMenuFromSettings" class="mt-8">Kembali ke Menu Utama</button>
    </div>

    <div id="orientationMessage" class="orientation-message">
        <p>Untuk pengalaman bermain terbaik, harap putar perangkat Anda ke mode lanskap.</p>
        <p>For the best experience, please rotate your device to landscape mode.</p>
    </div>

    <script>
        // Get info elements
        const coinsDisplay = document.getElementById('coins'); // Changed from score

        // Get message box elements
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton'); // This is for Game Over screen

        // Get main menu elements
        const mainMenuScreen = document.getElementById('mainMenuScreen');
        const mainMenuTitle = document.getElementById('mainMenuTitle');
        const welcomeMessageText = document.getElementById('welcomeMessageText');
        const mainMenuPrimaryButton = document.getElementById('mainMenuPrimaryButton');
        const restartGameButton = document.getElementById('restartGameButton'); // This is for pause menu restart
        const weaponSelectButton = document.getElementById('weaponSelectButton'); // Renamed
        const settingsButton = document.getElementById('settingsButton');

        // Get weapon select elements (NEW)
        const weaponSelectScreen = document.getElementById('weaponSelectScreen');
        const weaponSelectTitle = document.getElementById('weaponSelectTitle');
        const backToMainMenuFromWeaponButton = document.getElementById('backToMainMenuFromWeapon');
        
        // NEW 3D PREVIEW ELEMENTS
        const loadingOverlay = document.getElementById('loading-overlay');
        const damageFill = document.getElementById('damage-fill');
        const damageText = document.getElementById('damage-text');
        const buyWeaponBtn = document.getElementById('buyWeaponBtn');
        const prevWeaponBtn = document.getElementById('prevWeaponBtn');
        const nextWeaponBtn = document.getElementById('nextWeaponBtn');
        const weaponPreviewContainer = document.getElementById('container'); // Renamed from weaponPreviewContainer
        const weaponPriceDisplay = document.getElementById('weaponPriceDisplay'); // NEW: Price display element

        // Get settings elements
        const settingsScreen = document.getElementById('settingsScreen');
        const backToMainMenuFromSettingsButton = document.getElementById('backToMainMenuFromSettings');
        const mouseSensitivitySlider = document.getElementById('mouseSensitivitySlider');
        const mouseSensitivityValueDisplay = document.getElementById('mouseSensitivityValue');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValueDisplay = document.getElementById('volumeValue');
        const langIdButton = document.getElementById('langIdButton');
        const langEnButton = document.getElementById('langEnButton');

        // Get mobile controls
        const joystickContainer = document.querySelector('.joystick-container');
        const shootButton = document.getElementById('shootButton'); 

        // Get player HUD elements
        const healthBarFill = document.getElementById('healthBarFill');
        const healthLabel = document.getElementById('healthLabel');
        const shieldBarFill = document.getElementById('shieldBarFill');
        const shieldLabel = document.getElementById('shieldLabel');
        const playerHud = document.querySelector('.player-hud');

        // Get menu toggle button
        const menuToggleButton = document.getElementById('menuToggleButton');

        // Three.js variables
        let scene, camera, renderer;
        let playerYawObject; // Object to handle horizontal rotation (yaw)
        let playerCapsule; // Invisible mesh for player collision and position (child of playerYawObject)
        let bullets = []; // Array of { mesh, velocity }
        let enemies = []; // Array of { mesh, speed }
        let obstacles = []; // Array of obstacle meshes
        let playerGunModel; // Variable to hold the gun model (FBX)
        let playerModel; // Variable to hold the player model (FBX)

        // Game variables
        let coins = 0; // Changed from score
        let playerHealth = 100;
        let playerMaxHealth = 100;
        let playerShield = 50;
        let playerMaxShield = 50;
        let gameOver = false;
        // 'menu': main menu, can be initial or pause state
        // 'playing': game is active
        // 'gameOver': game has ended
        // 'weaponSelect': weapon selection screen
        // 'settings': settings screen
        let gameState = 'menu'; 
        let gameStartedAtLeastOnce = false; // Flag to track if game has been started from main menu

        // Timing variables for frame-rate independence
        let lastFrameTime = 0;

        // Debugging flag - SET THIS TO TRUE TO SEE COLLISION BOXES
        const DEBUG_COLLISIONS = false; // Dimatikan untuk tampilan yang lebih bersih

        // Player properties (in Three.js units)
        const PLAYER_HEIGHT_OFFSET = 0.5; // How high the camera is from the ground
        const PLAYER_RADIUS = 0.3; // For simple cylindrical collision
        const PLAYER_BASE_SPEED = 2.0; // Adjusted to be slower, similar to Valorant's walking speed
        const PLAYER_COLOR = 0x00FFFF; // Cyan (not visible, but for conceptual player body)

        // Bullet properties (in Three.js units)
        const BULLET_WIDTH = 0.05;
        const BULLET_HEIGHT = 0.8;
        const BULLET_SPEED = 15; // Speed units per second (will be multiplied by deltaTime)
        const BULLET_COLOR = 0xFF00FF; // Magenta
        let BULLET_DAMAGE = 10; // This will change based on selected weapon
        const ZOOMED_BULLET_DAMAGE_MULTIPLIER = 2.5; // Zoomed damage is this much more than base weapon damage

        // Pre-rotated bullet geometry (length along Z-axis)
        const BULLET_GEOMETRY = new THREE.CylinderGeometry(BULLET_WIDTH, BULLET_WIDTH, BULLET_HEIGHT, 8).rotateX(Math.PI / 2);

        // Enemy properties (in Three.js units)
        const ENEMY_SIZE = 0.7; // Base size for enemy scaling
        const ENEMY_BODY_HEIGHT = 0.8;
        const ENEMY_HEAD_RADIUS = 0.2;
        const ENEMY_ARM_LENGTH = 0.5;
        const ENEMY_LEG_LENGTH = 0.5;
        const ENEMY_SPEED_MIN = 1.0; // Speed units per second (Increased for faster AI)
        const ENEMY_SPEED_MAX = 3.0; // Speed units per second (Increased for faster AI)
        const ENEMY_COLOR = 0xFF0000; // Red
        const ENEMY_SPAWN_INTERVAL = 1500; // milliseconds (diperpanjang untuk debugging)
        let lastEnemySpawnTime = 0; // Akan diinisialisasi dengan Date.now() saat game dimulai
        const ENEMY_DAMAGE_TO_PLAYER = 20; // Damage an enemy deals to player on collision
        const ENEMY_AVOIDANCE_RADIUS = 2.0; // How close enemy needs to be to react to an obstacle
        const ENEMY_AVOIDANCE_FORCE_MULTIPLIER = 10.0; // How strong the push away is

        // Game world dimensions (in Three.js units)
        const WORLD_SCALE_FACTOR = 3.5; // New scale factor for the map
        const ORIGINAL_WORLD_WIDTH = 10;
        const ORIGINAL_WORLD_DEPTH = 15;
        const WORLD_WIDTH = ORIGINAL_WORLD_WIDTH * WORLD_SCALE_FACTOR;
        const WORLD_DEPTH = ORIGINAL_WORLD_DEPTH * WORLD_SCALE_FACTOR;
        const WORLD_HEIGHT = 5;

        // FOV for zoom
        const ORIGINAL_FOV = 75;
        const ZOOM_FACTOR = 1.5;
        const ZOOM_FOV = ORIGINAL_FOV / ZOOM_FACTOR;
        let isZoomed = false;

        // Epsilon for collision push-out
        const EPSILON = 0.01;

        // Keyboard input
        const keys = {};
        let isMouseDown = false; // Flag for mouse button state

        // Touch input for movement (simplified for FPS)
        let touchMoveForward = false;
        let touchMoveBackward = false;
        let touchMoveLeft = false;
        let touchMoveRight = false;

        // Camera rotation variables
        let isPointerLocked = false;
        // mouseSensitivity is now a global variable controlled by settings
        let mouseSensitivity = 0.0015; // Default value, can be changed in settings
        const pitchLimit = Math.PI / 2 - 0.1; // Limit vertical look (e.g., 80 degrees up/down)
        let isTouchDragging = false;
        let previousTouchX = 0;
        let previousTouchY = 0;
        const touchSensitivity = 0.003; // Adjusted for touch rotation
        const touchDragThreshold = 5; // Minimum pixel movement to register as a drag for rotation

        // Sound effects using Tone.js
        const playerShootSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: {
                attack: 0.001,
                decay: 0.1,
                sustain: 0.05,
                release: 0.1
            }
        }).toDestination();

        const enemyExplodeSynth = new Tone.NoiseSynth({
            noise: { type: "white" },
            envelope: {
                attack: 0.001,
                decay: 0.2,
                sustain: 0.01,
                release: 0.3
            }
        }).toDestination();

        const playerHitSynth = new Tone.Synth({
            oscillator: { type: "triangle" },
            envelope: {
                attack: 0.001,
                decay: 0.2,
                sustain: 0.1,
                release: 0.5
            }
        }).toDestination();

        // masterVolume is now a global variable controlled by settings
        let masterVolume = 0.5; // Default volume (0.0 to 1.0)
        let currentLanguage = 'id'; // 'id' for Indonesian, 'en' for English

        // Weapon data (Combined and adapted from provided code)
        // Note: The 'name' property here is for internal use/translation key.
        // The display name will come from translations[currentLanguage].weaponNames.
        const allWeaponsData = [
            { id: 'pistol', name: 'Pistol', damage: 15, price: 0, modelPath: 'https://raw.githubusercontent.com/fajrigans/assetgametembak/main/ImageToStl.com_buatkan_senjata_temba_0531174819_texture_fbx.fbx' },
            { id: 'ar15', name: 'AR-15 Style Rifle', damage: 20, price: 1500, modelPath: 'https://raw.githubusercontent.com/fajrigans/assetgametembak/main/ImageToStl.com_buatkan_senjata_temba_0531124219_texture_fbx.fbx' }
        ];
        let weapons = []; // This will store the game's weapon state (owned, current)
        let currentWeapon; // Will be set after loading weapons

        // Weapon Preview 3D variables (renamed for clarity)
        let previewScene, previewCamera, previewRenderer, previewControls;
        let currentPreviewModel = null;
        let currentWeaponIndex = 0; // Index for weaponModels array

        const translations = {
            'id': {
                'gameTitle': 'fire123-game',
                'startGame': 'Mulai Game',
                'continueGame': 'Lanjutkan', // New
                'restartGame': 'Mulai Ulang', // New
                'selectWeapon': 'Pilih Senjata', // Changed from characterSelect
                'settings': 'Pengaturan',
                'backToMainMenu': 'Kembali ke Menu Utama',
                'weaponSelectTitle': 'Pilih Senjata',
                'weaponDamage': 'Kerusakan:', // New
                'buyButton': 'Beli Senjata Ini', // New
                'equipButton': 'Pilih', // New
                'currentWeapon': 'Terpilih', // New
                'ownedButton': 'Miliki', // NEW TRANSLATION
                'settingsTitle': 'Pengaturan',
                'settingsPlaceholder': 'Atur opsi game di sini.',
                'mouseSensitivityLabel': 'Sensitivitas Mouse:',
                'volumeLabel': 'Volume:',
                'languageLabel': 'Bahasa:',
                'coins': 'Koin:', // Changed from score
                'health': 'Kesehatan:',
                'shield': 'Perisai:',
                'gameOverMessage': 'GAME OVER! Musuh menabrak Anda.',
                'restartButton': 'Mulai Ulang', // For game over screen
                'welcomeMessage': "Selamat datang! Gunakan ESC atau tombol menu untuk membuka/menutup menu. Klik di dalam area game untuk mengaktifkan kontrol kamera.",
                'shootButton': 'Tembak',
                'gamePaused': 'Game Dijeda.',
                'weaponPreviewNoModel': 'Model senjata tidak tersedia.', // New
                'loadingModel': 'Memuat model 3D...', // New
                'failedToLoadModel': 'Gagal memuat model. Periksa konsol untuk detail.', // New
                'weaponBought': 'Senjata berhasil dibeli!', // New
                'notEnoughCoins': 'Koin tidak cukup!', // New
                'orientationMessage': 'Untuk pengalaman bermain terbaik, harap putar perangkat Anda ke mode lanskap.',
                'weaponNames': { // New nested object for weapon names
                    'ar15': 'Senapan Gaya AR-15',
                    'pistol': 'Pistol'
                }
            },
            'en': {
                'gameTitle': 'fire123-game',
                'startGame': 'Start Game',
                'continueGame': 'Continue', // New
                'restartGame': 'Restart', // New
                'selectWeapon': 'Select Weapon', // Changed from characterSelect
                'settings': 'Settings',
                'backToMainMenu': 'Back to Main Menu',
                'weaponSelectTitle': 'Select Weapon',
                'weaponDamage': 'Damage:', // New
                'buyButton': 'Buy This Weapon', // New
                'equipButton': 'Equip', // New
                'currentWeapon': 'Equipped', // New
                'ownedButton': 'Owned', // NEW TRANSLATION
                'settingsTitle': 'Settings',
                'settingsPlaceholder': 'Adjust game options here.',
                'mouseSensitivityLabel': 'Mouse Sensitivity:',
                'volumeLabel': 'Volume:',
                'languageLabel': 'Language:',
                'coins': 'Coins:', // Changed from score
                'health': 'Health:',
                'shield': 'Shield:',
                'gameOverMessage': 'GAME OVER! Enemy collided with you.',
                'restartButton': 'Restart', // For game over screen
                'welcomeMessage': "Welcome! Use ESC or the menu button to open/close the menu. Click inside the game area to activate camera controls.",
                'shootButton': 'Shoot',
                'gamePaused': 'Game Paused.',
                'weaponPreviewNoModel': 'Weapon model not available.', // New
                'loadingModel': 'Loading 3D model...', // New
                'failedToLoadModel': 'Failed to load model. Check console for details.', // New
                'weaponBought': 'Weapon successfully purchased!', // New
                'notEnoughCoins': 'Not enough coins!', // New
                'orientationMessage': 'For the best experience, please rotate your device to landscape mode.',
                'weaponNames': { // New nested object for weapon names
                    'ar15': 'AR-15 Style Rifle',
                    'pistol': 'Pistol'
                }
            }
        };

        // Helper function to play sound only if audio context is running and valid
        function playSound(synth, note, duration) {
            // Ensure Tone.js context is running and current time is a valid finite number
            if (Tone.context.state === 'running' && typeof Tone.context.currentTime === 'number' && Number.isFinite(Tone.context.currentTime)) {
                try {
                    if (synth && synth.triggerAttackRelease) {
                        synth.triggerAttackRelease(note, duration);
                    } else {
                        console.warn("Synth or triggerAttackRelease method is not available.");
                    }
                } catch (e) {
                    console.error("Error playing sound during triggerAttackRelease:", e);
                    // Optionally, try to resume context if it's suspended, though startGame already calls Tone.start()
                    if (Tone.context.state === 'suspended') {
                        Tone.context.resume().then(() => {
                            console.log("AudioContext resumed after error.");
                        });
                    }
                }
            } else {
                console.warn("Audio context is not running or current time is invalid, cannot play sound. State:", Tone.context.state, "Current Time:", Tone.context.currentTime);
                // Attempt to start/resume Tone.js if it's not running
                if (Tone.context.state !== 'running') {
                    Tone.start().then(() => {
                        console.log("AudioContext started/resumed from playSound fallback.");
                    });
                }
            }
        }

        // --- Three.js Initialization ---
        function initThreeJS() {
            // Scene
            scene = new THREE.Scene(); 

            // Camera (Perspective for FPS)
            camera = new THREE.PerspectiveCamera(ORIGINAL_FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, PLAYER_HEIGHT_OFFSET, 0); // Camera position relative to playerYawObject

            // Renderer
            const canvas3D = document.getElementById('gameCanvas3D');
            if (!canvas3D) {
                console.error("Canvas element with ID 'gameCanvas3D' not found.");
                return false; // Indicate failure
            }
            try {
                renderer = new THREE.WebGLRenderer({ canvas: canvas3D, alpha: false, antialias: true }); // Initialize renderer here
                renderer.setPixelRatio(window.devicePixelRatio); // Set pixel ratio for high DPI displays
                renderer.shadowMap.enabled = true; // Mengaktifkan peta bayangan
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Jenis bayangan yang lebih lembut
                resizeRenderer(); // Set initial size
            } catch (e) {
                console.error("Error creating WebGLRenderer:", e);
                // Display a user-friendly message about WebGL failure
                messageBox.style.display = 'block';
                messageText.textContent = "Gagal menginisialisasi grafis 3D. Browser Anda mungkin tidak mendukung WebGL atau ada masalah lain. Coba perbarui browser atau perangkat Anda.";
                restartButton.style.display = 'none'; // Hide restart button for this specific error
                return false; // Indicate failure
            }

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x606060); // Increased ambient light for better overall visibility
            scene.add(ambientLight);

            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7); // Light from above and below
            scene.add(hemisphereLight); // ADDED HEMISPHERE LIGHT BACK

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 15, 5); // Posisi cahaya
            directionalLight.castShadow = true; // Cahaya ini akan memancarkan bayangan
            scene.add(directionalLight);

            // Pengaturan bayangan untuk directional light
            directionalLight.shadow.mapSize.width = 2048; // Resolusi peta bayangan (lebih tinggi = lebih tajam)
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -WORLD_WIDTH / 2;
            directionalLight.shadow.camera.right = WORLD_WIDTH / 2;
            directionalLight.shadow.camera.top = WORLD_DEPTH / 2;
            directionalLight.shadow.camera.bottom = -WORLD_DEPTH / 2;
            directionalLight.shadow.bias = -0.0005; // Mengurangi "shadow acne"

            // Ground Plane (now larger)
            const groundGeometry = new THREE.PlaneGeometry(WORLD_WIDTH, WORLD_DEPTH);
            const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22, side: THREE.DoubleSide }); // Forest green
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            ground.position.y = 0; // At y=0
            ground.position.z = -WORLD_DEPTH / 2 + (ORIGINAL_WORLD_DEPTH / 2); // Shift back to center the original play area
            ground.receiveShadow = true; // Tanah akan menerima bayangan
            scene.add(ground);

            // Player Yaw Object (handles horizontal rotation for player and camera)
            playerYawObject = new THREE.Object3D(); // Initialize playerYawObject here
            scene.add(playerYawObject); // Add to scene

            // Player Capsule (invisible for player collision and position (child of playerYawObject)
            const playerCapsuleGeometry = new THREE.CylinderGeometry(PLAYER_RADIUS, PLAYER_RADIUS, PLAYER_HEIGHT_OFFSET * 2, 16);
            const playerCapsuleMaterial = DEBUG_COLLISIONS ? new THREE.MeshBasicMaterial({ color: 0x00FF00, wireframe: true, transparent: true, opacity: 0.5 }) : new THREE.MeshBasicMaterial({ visible: false });
            playerCapsule = new THREE.Mesh(playerCapsuleGeometry, playerCapsuleMaterial);
            playerCapsule.position.y = PLAYER_HEIGHT_OFFSET; // Position relative to playerYawObject's base
            playerYawObject.add(playerCapsule); // Add as child

            playerYawObject.add(camera); // Make camera a child of playerYawObject


            // Add initial environment assets
            addEnvironmentAssets();
            
            // Add Skybox
            addSkybox();

            return true; // Indicate success
        }

        // Function to load the in-game weapon model
        function loadInGameWeaponModel(modelPath) {
            if (playerGunModel) {
                camera.remove(playerGunModel);
                playerGunModel = null;
            }

            if (!modelPath) {
                console.warn("No model path for in-game weapon. Using fallback.");
                const gunGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
                const gunMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                playerGunModel = new THREE.Mesh(gunGeometry, gunMaterial);
                playerGunModel.position.set(0.3, -0.25, -0.5);
                playerGunModel.castShadow = true;
                camera.add(playerGunModel);
                return;
            }

            const fbxLoader = new THREE.FBXLoader();
            fbxLoader.load(modelPath, (fbx) => {
                playerGunModel = fbx;
                playerGunModel.scale.set(0.005, 0.005, 0.005);
                playerGunModel.position.set(0.3, -0.25, -0.5);
                playerGunModel.rotation.set(Math.PI, Math.PI, Math.PI); // Adjust rotation as needed
                playerGunModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    // Ensure material is a PhongMaterial for lighting
                                    child.material = new THREE.MeshPhongMaterial({ color: mat.color });
                                    mat.needsUpdate = true;
                                });
                            } else {
                                child.material = new THREE.MeshPhongMaterial({ color: child.material.color });
                                child.material.needsUpdate = true;
                            }
                        } else {
                            child.material = new THREE.MeshPhongMaterial({ color: 0x888888 });
                        }
                    }
                });
                camera.add(playerGunModel);
            }, undefined, (error) => {
                console.error("Error loading in-game weapon FBX model:", error);
                // Fallback to simple box gun if model fails to load
                const gunGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
                const gunMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                playerGunModel = new THREE.Mesh(gunGeometry, gunMaterial);
                playerGunModel.position.set(0.3, -0.25, -0.5);
                playerGunModel.castShadow = true;
                camera.add(playerGunModel);
            });
        }


        // Helper function to add a box obstacle
        function addObstacle(x, y, z, sizeX, sizeY, sizeZ, color = 0x8B4513) {
            const obstacleGeometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
            const obstacleMaterial = new THREE.MeshPhongMaterial({ color: color });
            const obstacleMesh = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacleMesh.position.set(x, y + sizeY / 2, z);
            obstacleMesh.castShadow = true; // Rintangan memancarkan bayangan
            obstacleMesh.receiveShadow = true; // Rintangan menerima bayangan
            scene.add(obstacleMesh);
            // Store bounding box for obstacles
            obstacleMesh.userData.boundingBox = new THREE.Box3().setFromObject(obstacleMesh);
            obstacles.push(obstacleMesh);

            if (DEBUG_COLLISIONS) {
                const boxHelper = new THREE.BoxHelper(obstacleMesh, 0xFFFF00);
                scene.add(boxHelper);
                obstacleMesh.userData.boxHelper = boxHelper;
            }
        }

        // Helper function to add a cylinder obstacle (e.g., pillar, barrel)
        function addCylinderObstacle(x, y, z, radius, height, color = 0x696969) {
            const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, height, 32);
            const cylinderMaterial = new THREE.MeshPhongMaterial({ color: color });
            const cylinderMesh = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinderMesh.position.set(x, y + height / 2, z);
            cylinderMesh.castShadow = true; // Silinder memancarkan bayangan
            cylinderMesh.receiveShadow = true; // Silinder menerima bayangan
            scene.add(cylinderMesh);
            // Store bounding box for obstacles
            cylinderMesh.userData.boundingBox = new THREE.Box3().setFromObject(cylinderMesh);
            obstacles.push(cylinderMesh);

            if (DEBUG_COLLISIONS) {
                const boxHelper = new THREE.BoxHelper(cylinderMesh, 0xFFFF00);
                scene.add(boxHelper);
                cylinderMesh.userData.boxHelper = boxHelper;
            }
        }

        function addEnvironmentAssets() {
            obstacles.forEach(o => {
                scene.remove(o);
                if (DEBUG_COLLISIONS && o.userData.boxHelper) {
                    scene.remove(o.userData.boxHelper);
                }
            });
            obstacles = [];

            addObstacle(0, 0, -5, 2, 1, 2, 0x808080);
            addCylinderObstacle(3, 0, -7, 0.8, 2.5, 0x556B2F);
            addObstacle(-3, 0, -3, 1.5, 1.5, 1.5, 0x708090);
            addObstacle(0, 0, 8, 10, 5, 4, 0x4682B4);
            addObstacle(0, 5, 8, 11, 1, 5, 0x8B4513);
            addObstacle(-WORLD_WIDTH / 2 + 2, 0, 0, 1, 3, 8, 0x6A5ACD);
            addObstacle(WORLD_WIDTH / 2 - 2, 0, 0, 1, 3, 8, 0x6A5ACD);
            addObstacle(-WORLD_WIDTH / 4, 0, -10, 3, 2, 1.5, 0xCD853F);
            addCylinderObstacle(WORLD_WIDTH / 4, 0, -10, 0.6, 2, 0xCD853F);

            for (let i = 0; i < 8; i++) {
                const x = (Math.random() * (WORLD_WIDTH - 2)) - (WORLD_WIDTH / 2 - 1);
                const z = (Math.random() * (WORLD_DEPTH - 2)) - (WORLD_DEPTH / 2 - 1);
                const size = 0.5 + Math.random() * 1.5;
                const height = 0.5 + Math.random() * 2;
                addObstacle(x, 0, z, size, height, size, 0x778899);
            }
        }

        // --- Enemy Creation Function (More complex shape) ---
        function createEnemyMesh() {
            const enemyGroup = new THREE.Group();
            const material = new THREE.MeshPhongMaterial({ color: ENEMY_COLOR });

            const bodyGeometry = new THREE.BoxGeometry(ENEMY_SIZE * 0.6, ENEMY_BODY_HEIGHT, ENEMY_SIZE * 0.4);
            const bodyMesh = new THREE.Mesh(bodyGeometry, material);
            bodyMesh.position.y = ENEMY_BODY_HEIGHT / 2;
            bodyMesh.castShadow = true; // Badan musuh memancarkan bayangan
            enemyGroup.add(bodyMesh);

            const headGeometry = new THREE.SphereGeometry(ENEMY_HEAD_RADIUS, 16, 16);
            const headMesh = new THREE.Mesh(headGeometry, material);
            headMesh.position.y = ENEMY_BODY_HEIGHT + ENEMY_HEAD_RADIUS;
            headMesh.castShadow = true; // Kepala musuh memancarkan bayangan
            enemyGroup.add(headMesh);

            const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, ENEMY_ARM_LENGTH, 8);
            const leftArm = new THREE.Mesh(armGeometry, material);
            leftArm.position.set(-(ENEMY_SIZE * 0.3 + 0.1), ENEMY_BODY_HEIGHT * 0.7, 0);
            leftArm.rotation.z = Math.PI / 4;
            leftArm.castShadow = true; // Lengan memancarkan bayangan
            enemyGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, material);
            rightArm.position.set((ENEMY_SIZE * 0.3 + 0.1), ENEMY_BODY_HEIGHT * 0.7, 0);
            rightArm.rotation.z = -Math.PI / 4;
            rightArm.castShadow = true; // Lengan memancarkan bayangan
            enemyGroup.add(rightArm);

            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, ENEMY_LEG_LENGTH, 8);
            const leftLeg = new THREE.Mesh(legGeometry, material);
            leftLeg.position.set(-(ENEMY_SIZE * 0.2), ENEMY_LEG_LENGTH / 2, 0);
            leftLeg.castShadow = true; // Kaki memancarkan bayangan
            enemyGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, material);
            rightLeg.position.set((ENEMY_SIZE * 0.2), ENEMY_LEG_LENGTH / 2, 0);
            rightLeg.castShadow = true; // Kaki memancarkan bayangan
            enemyGroup.add(rightLeg);

            enemyGroup.position.y = ENEMY_LEG_LENGTH / 2;
            enemyGroup.receiveShadow = true; // Musuh menerima bayangan (dari dirinya sendiri atau objek lain)

            // Add health bar to enemy
            const healthBarWidth = 1.2;
            const healthBarHeight = 0.15;

            const healthBarBackgroundGeometry = new THREE.PlaneGeometry(healthBarWidth, healthBarHeight);
            const healthBarBackgroundMaterial = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
            const healthBarBackground = new THREE.Mesh(healthBarBackgroundGeometry, healthBarBackgroundMaterial);
            healthBarBackground.position.y = ENEMY_BODY_HEIGHT + ENEMY_HEAD_RADIUS + 0.3;
            enemyGroup.add(healthBarBackground);
            enemyGroup.userData.healthBarBackground = healthBarBackground;

            const healthBarForegroundGeometry = new THREE.PlaneGeometry(healthBarWidth * 0.9, healthBarHeight * 0.8);
            const healthBarForegroundMaterial = new THREE.MeshBasicMaterial({ color: 0x00FF00, side: THREE.DoubleSide });
            const healthBarForeground = new THREE.Mesh(healthBarForegroundGeometry, healthBarForegroundMaterial);
            healthBarForeground.position.y = ENEMY_BODY_HEIGHT + ENEMY_HEAD_RADIUS + 0.3;
            healthBarForeground.position.z = 0.01;
            enemyGroup.add(healthBarForeground);
            enemyGroup.userData.healthBar = healthBarForeground;

            // --- PERUBAHAN DI SINI: Kesehatan musuh ditingkatkan menjadi 60 ---
            enemyGroup.userData.maxHealth = 60; 
            enemyGroup.userData.currentHealth = 60; 
            // Store bounding box for enemy
            enemyGroup.userData.boundingBox = new THREE.Box3();

            return enemyGroup;
        }

        // --- Skybox Implementation ---
        function addSkybox() {
            const path = "https://threejs.org/examples/textures/cube/Bridge2/";
            const urls = [
                path + "posx.jpg", path + "negx.jpg",
                path + "posy.jpg", path + "negy.jpg",
                path + "posz.jpg", path + "negz.jpg"
            ];

            const cubeTextureLoader = new THREE.CubeTextureLoader();
            cubeTextureLoader.load(urls, (texture) => {
                scene.background = texture;
            }, undefined, (error) => {
                console.error("Error loading skybox textures:", error);
                scene.background = new THREE.Color(0x333333); 
            });
        }

        // Function to save weapon data to localStorage
        function saveWeaponsToLocalStorage() {
            localStorage.setItem('ownedWeapons', JSON.stringify(weapons));
        }

        // --- Game Initialization ---
        function initializeGameElements() {
            console.log("initializeGameElements called");
            // Only attempt to clear scene elements if scene is defined
            if (scene) {
                bullets.forEach(b => scene.remove(b.mesh));
                enemies.forEach(e => scene.remove(e.mesh));
            }

            bullets = [];
            enemies = [];
            
            // Load coins from localStorage, default to 0 if not found
            const savedCoins = localStorage.getItem('gameCoins');
            coins = savedCoins ? parseInt(savedCoins) : 0;
            
            // 1. Initialize weapons with all default data, setting all to not owned/not current initially
            // This ensures 'weapons' always contains all possible weapon IDs from 'allWeaponsData'
            weapons = allWeaponsData.map(weapon => ({ ...weapon, owned: false, current: false }));

            // 2. Load saved weapon states from localStorage and merge
            const savedWeapons = localStorage.getItem('ownedWeapons');
            if (savedWeapons) {
                try {
                    const loadedWeapons = JSON.parse(savedWeapons);
                    loadedWeapons.forEach(loadedWeapon => {
                        const existingWeapon = weapons.find(w => w.id === loadedWeapon.id);
                        if (existingWeapon) {
                            // Update owned and current status from saved data
                            existingWeapon.owned = loadedWeapon.owned;
                            existingWeapon.current = loadedWeapon.current;
                            // Other properties (damage, modelPath, price) are always taken from allWeaponsData
                        }
                    });
                } catch (e) {
                    console.error("Error parsing saved weapons from localStorage:", e);
                    // If parsing fails, proceed with default initialization
                }
            }

            // 3. Ensure pistol is always owned and current if no other weapon is explicitly current
            const pistol = weapons.find(w => w.id === 'pistol');
            if (pistol) {
                pistol.owned = true; // Pistol is always owned

                // Check if any weapon is currently equipped
                const currentlyEquipped = weapons.find(w => w.current);

                if (!currentlyEquipped) {
                    // If no weapon is currently equipped, equip pistol
                    pistol.current = true;
                } else if (currentlyEquipped.id !== 'pistol' && !currentlyEquipped.owned) {
                    // This is a safeguard: if a non-pistol is marked as current but not owned (data inconsistency),
                    // deselect it and equip the pistol.
                    console.warn(`Weapon ${currentlyEquipped.id} was current but not owned. Defaulting to pistol.`);
                    currentlyEquipped.current = false;
                    pistol.current = true;
                }
                // If currentlyEquipped exists and is owned, keep it as is.
            } else {
                // Fallback if pistol is somehow not in allWeaponsData (should not happen, but for robustness)
                console.error("Pistol not found in allWeaponsData. Equipping first available weapon.");
                if (weapons.length > 0) {
                    weapons[0].owned = true;
                    weapons[0].current = true;
                }
            }
            
            // 4. Save the synchronized state back to localStorage
            saveWeaponsToLocalStorage();

            // Set currentWeapon based on the finalized 'weapons' array
            currentWeapon = weapons.find(w => w.current);
            if (!currentWeapon) {
                // Final fallback: if somehow no weapon is current, pick the first one
                console.error("No current weapon found after initialization. Defaulting to first weapon.");
                currentWeapon = weapons[0];
                currentWeapon.current = true;
                saveWeaponsToLocalStorage();
            }

            BULLET_DAMAGE = currentWeapon.damage; // Set initial damage based on loaded weapon
            loadInGameWeaponModel(currentWeapon.modelPath); // Load the in-game model

            if (playerYawObject) { // Defensive check
                playerYawObject.position.set(0, 0, 5);
                playerYawObject.rotation.y = 0;
            }
            if (camera) { // Defensive check
                camera.rotation.x = 0;
            }
            
            playerHealth = playerMaxHealth;
            playerShield = playerMaxShield;
            lastEnemySpawnTime = Date.now();
            updateCoinsDisplay();
            updateHealthShieldDisplay();
            
            // Only add environment assets and skybox if scene is defined
            if (scene) {
                addEnvironmentAssets();
                addSkybox();
            }
        }

        // Fungsi untuk memulai permainan (dari awal)
        function startGame() { // This function is for a full restart
            console.log("startGame called (full restart)");
            initializeGameElements(); // Resets coins, health, enemies, player position, and loads weapons
            gameOver = false;
            gameState = 'playing';
            gameStartedAtLeastOnce = true;

            hideAllScreens(); // Hide all menus first

            // Show mobile controls only if screen width is mobile
            if (window.innerWidth < 768) { 
                joystickContainer.style.display = 'block';
                shootButton.style.display = 'block';
                console.log(`startGame: Mobile controls displayed. window.innerWidth: ${window.innerWidth}`);
            } else {
                joystickContainer.style.display = 'none';
                shootButton.style.display = 'none';
                console.log(`startGame: Desktop detected. Mobile controls remain hidden. window.innerWidth: ${window.innerWidth}`);
            }
            playerHud.style.display = 'flex';
            menuToggleButton.style.display = 'block';

            Tone.start();
            requestPointerLock();
            console.log("New Game Started!");
        }

        // New function to resume the game without resetting
        function resumeGame() {
            console.log("resumeGame called");
            gameOver = false; // Ensure game is not in game over state
            gameState = 'playing';
            hideAllScreens(); // Hide all menus first

            // Show mobile controls only if screen width is mobile
            if (window.innerWidth < 768) { 
                joystickContainer.style.display = 'block';
                shootButton.style.display = 'block';
                console.log(`resumeGame: Mobile controls displayed. window.innerWidth: ${window.innerWidth}`);
            } else {
                joystickContainer.style.display = 'none';
                shootButton.style.display = 'none';
                console.log(`resumeGame: Desktop detected. Mobile controls remain hidden. window.innerWidth: ${window.innerWidth}`);
            }
            playerHud.style.display = 'flex';
            menuToggleButton.style.display = 'block';

            requestPointerLock();
            // No need to call animate() here, it's already running.
            console.log("Game Resumed!");
        }


        // --- Update Game State Functions ---
        function updatePlayer(deltaTime) {
            // Only update player if playerYawObject is defined
            if (!playerYawObject) return;

            const moveSpeed = PLAYER_BASE_SPEED * deltaTime;
            const originalX = playerYawObject.position.x;
            const originalZ = playerYawObject.position.z;

            const forwardVector = new THREE.Vector3(0, 0, -1).applyQuaternion(playerYawObject.quaternion);
            forwardVector.y = 0;
            forwardVector.normalize();

            const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(playerYawObject.quaternion);
            rightVector.y = 0;
            rightVector.normalize();

            let movementVector = new THREE.Vector3();

            if (keys['ArrowUp'] || keys['w'] || touchMoveForward) {
                movementVector.add(forwardVector);
            }
            if (keys['ArrowDown'] || keys['s'] || touchMoveBackward) {
                movementVector.sub(forwardVector);
            }
            if (keys['ArrowLeft'] || keys['a'] || touchMoveLeft) {
                movementVector.sub(rightVector);
            }
            if (keys['ArrowRight'] || keys['d'] || touchMoveRight) {
                movementVector.add(rightVector);
            }

            if (movementVector.lengthSq() > 0) {
                movementVector.normalize();
                movementVector.multiplyScalar(moveSpeed);
            }

            playerYawObject.position.x += movementVector.x;
            const playerBoxAfterXMove = new THREE.Box3().setFromObject(playerCapsule);
            for (const obstacle of obstacles) {
                const obstacleBox = obstacle.userData.boundingBox; // Use pre-calculated bounding box
                if (playerBoxAfterXMove.intersectsBox(obstacleBox)) {
                    playerYawObject.position.x = originalX;
                    break;
                }
            }

            playerYawObject.position.z += movementVector.z;
            const playerBoxAfterZMove = new THREE.Box3().setFromObject(playerCapsule);
            for (const obstacle of obstacles) {
                const obstacleBox = obstacle.userData.boundingBox; // Use pre-calculated bounding box
                if (playerBoxAfterZMove.intersectsBox(obstacleBox)) {
                    playerYawObject.position.z = originalZ;
                    break;
                }
            }

            playerYawObject.position.y = 0; 

            const halfWorldWidth = WORLD_WIDTH / 2 - PLAYER_RADIUS;
            const halfWorldDepth = WORLD_DEPTH / 2 - PLAYER_RADIUS;

            if (playerYawObject.position.x < -halfWorldWidth) playerYawObject.position.x = -halfWorldWidth;
            if (playerYawObject.position.x > halfWorldWidth) playerYawObject.position.x = halfWorldWidth;
            if (playerYawObject.position.z > halfWorldDepth) playerYawObject.position.z = halfWorldDepth;
            if (playerYawObject.position.z < -halfWorldDepth) playerYawObject.position.z = -halfWorldDepth;
        }

        function updateBullets(deltaTime) {
            // Only update bullets if scene is defined
            if (!scene) return;

            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.mesh.position.add(bullet.direction.clone().multiplyScalar(BULLET_SPEED * deltaTime));

                if (
                    bullet.mesh.position.z < -WORLD_DEPTH / 2 - 2 ||
                    bullet.mesh.position.z > WORLD_DEPTH / 2 + 2 ||
                    bullet.mesh.position.x < -WORLD_WIDTH / 2 - 2 ||
                    bullet.mesh.position.x > WORLD_WIDTH / 2 + 2
                ) {
                    scene.remove(bullet.mesh);
                    bullets.splice(i, 1);
                }
            }
        }

        function spawnEnemy() {
            // Only spawn enemy if scene is defined
            if (!scene) return;

            const now = Date.now();
            if (now - lastEnemySpawnTime > ENEMY_SPAWN_INTERVAL) {
                const x = (Math.random() * (WORLD_WIDTH - ENEMY_SIZE)) - (WORLD_WIDTH / 2 - ENEMY_SIZE / 2);
                const z = -(WORLD_DEPTH / 2) - ENEMY_SIZE - (Math.random() * 5); // Spawn further back
                const speed = ENEMY_SPEED_MIN + Math.random() * (ENEMY_SPEED_MAX - ENEMY_SPEED_MIN);

                const enemyMesh = createEnemyMesh();
                enemyMesh.position.set(x, 0, z);
                scene.add(enemyMesh);

                enemies.push({ mesh: enemyMesh, speed: speed });
                lastEnemySpawnTime = now;
            }
        }

        function updateEnemies(deltaTime) {
            // Only update enemies if playerYawObject is defined
            if (!playerYawObject) return;

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                // Update enemy's bounding box to its current position
                enemy.mesh.userData.boundingBox.setFromObject(enemy.mesh);

                // Calculate direction to player
                const directionToPlayer = new THREE.Vector3().subVectors(playerYawObject.position, enemy.mesh.position).normalize();
                let finalMovementVector = directionToPlayer.clone();

                // Obstacle avoidance logic
                for (const obstacle of obstacles) {
                    const obstacleBox = obstacle.userData.boundingBox;
                    const enemyBox = enemy.mesh.userData.boundingBox;

                    // Create a temporary bounding box for the enemy's predicted future position
                    // Predict slightly ahead to react before actual collision
                    const predictedEnemyBox = enemyBox.clone();
                    predictedEnemyBox.translate(finalMovementVector.clone().multiplyScalar(enemy.speed * deltaTime * 2)); // Predict 2 frames ahead

                    if (predictedEnemyBox.intersectsBox(obstacleBox)) {
                        const overlapVector = new THREE.Vector3();
                        // Calculate vector from obstacle center to enemy center
                        enemyBox.getCenter(overlapVector).sub(obstacleBox.getCenter(new THREE.Vector3()));
                        overlapVector.y = 0; // Only consider horizontal avoidance

                        // If centers are identical or very close, provide a random small nudge to avoid division by zero
                        if (overlapVector.lengthSq() < 0.001) { // Use a small epsilon for comparison
                            overlapVector.set(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                        } else {
                            overlapVector.normalize();
                        }
                        
                        // Add an avoidance force, stronger when closer to the obstacle
                        const distance = enemy.mesh.position.distanceTo(obstacle.position);
                        // Using a simple inverse distance for force, capped to avoid extreme values
                        const forceMagnitude = ENEMY_AVOIDANCE_FORCE_MULTIPLIER / (distance + 0.1); // Add 0.1 to prevent division by zero
                        finalMovementVector.add(overlapVector.multiplyScalar(forceMagnitude));
                        // No break here, allow multiple avoidance forces to combine
                    }
                }

                // Re-normalize the final movement vector after adding avoidance forces
                if (finalMovementVector.lengthSq() > 0) {
                    finalMovementVector.normalize();
                }
                
                // Apply movement
                enemy.mesh.position.add(finalMovementVector.multiplyScalar(enemy.speed * deltaTime));

                // Make enemy look at player (only yaw)
                enemy.mesh.lookAt(playerYawObject.position.x, enemy.mesh.position.y, playerYawObject.position.z);
                enemy.mesh.rotation.x = 0; // Prevent tilting up/down
                enemy.mesh.rotation.z = 0; // Prevent rolling

                // Update health bar orientation to face camera
                if (enemy.mesh.userData.healthBar && camera) {
                    enemy.mesh.userData.healthBar.quaternion.copy(camera.quaternion);
                    enemy.mesh.userData.healthBarBackground.quaternion.copy(camera.quaternion);
                }

                const playerCollisionBox = new THREE.Box3().setFromObject(playerCapsule);
                const enemyBox = enemy.mesh.userData.boundingBox; // Use updated bounding box

                if (playerCollisionBox.intersectsBox(enemyBox)) {
                    // Apply damage to player's shield first, then health
                    let damageRemaining = ENEMY_DAMAGE_TO_PLAYER;
                    if (playerShield > 0) {
                        const shieldDmg = Math.min(playerShield, damageRemaining);
                        playerShield -= shieldDmg;
                        damageRemaining -= shieldDmg;
                    }
                    if (damageRemaining > 0) {
                        playerHealth -= damageRemaining;
                    }
                    
                    playSound(playerHitSynth, "C3", "8n");
                    updateHealthShieldDisplay(); // Update health and shield bars
                    
                    scene.remove(enemy.mesh);
                    enemies.splice(i, 1);
                    
                    if (playerHealth <= 0) {
                        endGame(translations[currentLanguage].gameOverMessage);
                    }
                    continue;
                }

                // Remove enemies that pass the player
                if (enemy.mesh.position.z > playerYawObject.position.z + 5) { // If enemy is 5 units past player
                    scene.remove(enemy.mesh);
                    enemies.splice(i, 1);
                }
            }
        }

        // --- Collision Detection ---
        function checkCollisions() {
            // Only check collisions if scene is defined
            if (!scene) return;

            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                const bulletBox = new THREE.Box3().setFromObject(bullet.mesh);

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const enemyBox = enemy.mesh.userData.boundingBox; // Use pre-calculated bounding box

                    if (bulletBox.intersectsBox(enemyBox)) {
                        playSound(enemyExplodeSynth, "C2", "8n");
                        scene.remove(bullet.mesh);
                        bullets.splice(i, 1);

                        // Apply damage and update health bar
                        enemy.mesh.userData.currentHealth -= (isZoomed ? (BULLET_DAMAGE * ZOOMED_BULLET_DAMAGE_MULTIPLIER) : BULLET_DAMAGE);
                        
                        // --- Efek Kilatan (Flash Effect) pada Musuh ---
                        enemy.mesh.traverse((child) => {
                            if (child.isMesh && child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => mat.color.setHex(0xFFFFFF)); // Kilat putih
                                } else {
                                    child.material.color.setHex(0xFFFFFF); // Kilat putih
                                }
                            }
                        });

                        setTimeout(() => {
                            enemy.mesh.traverse((child) => {
                                if (child.isMesh && child.material) {
                                    if (Array.isArray(child.material)) {
                                        child.material.forEach(mat => mat.color.setHex(ENEMY_COLOR)); // Kembali ke warna merah asli
                                    } else {
                                        child.material.color.setHex(ENEMY_COLOR); // Kembali ke warna merah asli
                                    }
                                }
                            });
                        }, 100); // Kilat selama 100ms
                        // --- Akhir Efek Kilatan ---

                        const healthRatio = enemy.mesh.userData.currentHealth / enemy.mesh.userData.maxHealth;

                        enemy.mesh.userData.healthBar.scale.x = healthRatio;
                        // Adjust position to keep left edge fixed
                        enemy.mesh.userData.healthBar.position.x = (enemy.mesh.userData.healthBar.geometry.parameters.width / 2) * (healthRatio - 1);

                        // Change health bar color based on health
                        if (healthRatio > 0.5) {
                            enemy.mesh.userData.healthBar.material.color.setHex(0x00FF00); // Green
                        } else if (healthRatio > 0.2) {
                            enemy.mesh.userData.healthBar.material.color.setHex(0xFFFF00); // Yellow
                        } else {
                            enemy.mesh.userData.healthBar.material.color.setHex(0xFF0000); // Red
                        }

                        if (enemy.mesh.userData.currentHealth <= 0) {
                            scene.remove(enemy.mesh);
                            enemies.splice(j, 1);
                            coins += 10; // Changed from score
                            updateCoinsDisplay(); // Changed from updateScoreDisplay
                        }
                        break; // Bullet hit an enemy, stop checking other enemies for this bullet
                    }
                }
            }
        }

        // --- Display Updates ---
        function updateCoinsDisplay() { // Changed from updateScoreDisplay
            coinsDisplay.textContent = `${translations[currentLanguage].coins} ${coins}`; // Changed from score
            localStorage.setItem('gameCoins', coins); // Save coins to localStorage
        }

        function updateHealthShieldDisplay() {
            // Health Bar
            const healthPercentage = (playerHealth / playerMaxHealth) * 100;
            healthBarFill.style.width = `${Math.max(0, healthPercentage)}%`;
            healthLabel.textContent = `${translations[currentLanguage].health} ${Math.max(0, Math.floor(playerHealth))}`;
            if (playerHealth > 50) {
                healthBarFill.style.backgroundColor = '#0F0'; // Green
            } else if (playerHealth > 20) {
                healthBarFill.style.backgroundColor = '#FFD700'; // Gold/Yellow
            } else {
                healthBarFill.style.backgroundColor = '#F00'; // Red
            }

            // Shield Bar
            const shieldPercentage = (playerShield / playerMaxShield) * 100;
            shieldBarFill.style.width = `${Math.max(0, shieldPercentage)}%`;
            shieldLabel.textContent = `${translations[currentLanguage].shield} ${Math.max(0, Math.floor(playerShield))}`;
            if (playerShield > 20) {
                shieldBarFill.style.backgroundColor = '#00F'; // Blue
            } else {
                shieldBarFill.style.backgroundColor = '#800080'; // Purple
            }
        }

        // Function to update settings UI elements based on current values
        function updateSettingsDisplay() {
            mouseSensitivitySlider.value = mouseSensitivity;
            mouseSensitivityValueDisplay.textContent = mouseSensitivity.toFixed(4);

            volumeSlider.value = masterVolume;
            volumeValueDisplay.textContent = `${Math.floor(masterVolume * 100)}%`;

            // Update language button selection
            if (currentLanguage === 'id') {
                langIdButton.classList.add('selected');
                langEnButton.classList.remove('selected');
                langIdButton.style.backgroundColor = '#2563eb'; // Tailwind blue-600
                langEnButton.style.backgroundColor = '#4b5563'; // Tailwind gray-600
            } else {
                langIdButton.classList.remove('selected');
                langEnButton.classList.add('selected');
                langIdButton.style.backgroundColor = '#4b5563'; // Tailwind gray-600
                langEnButton.style.backgroundColor = '#2563eb'; // Tailwind blue-600
            }
        }

        // Function to change the game language
        function updateLanguage(lang) {
            currentLanguage = lang;
            updateLanguageDisplay();
            // Re-render weapon list to update language
            if (gameState === 'weaponSelect') {
                updateWeaponPreviewUI(); // Update UI elements on weapon select screen
            }
        }

        // --- Game Over / Message Box ---
        // This message box is now only for Game Over messages.
        function showMessageBox(message) {
            messageText.textContent = message;
            messageText.dataset.originalMessage = message; // Store original message for language changes
            messageBox.style.display = 'block';
            playerHud.style.display = 'none'; // Hide HUD when message box is shown
            menuToggleButton.style.display = 'none'; // Hide menu button
            
            // Sembunyikan kontrol mobile saat kotak pesan ditampilkan
            joystickContainer.style.display = 'none';
            shootButton.style.display = 'none';
            console.log("MessageBox shown: Mobile controls hidden.");
        }

        function hideMessageBox() {
            messageBox.style.display = 'none';
            // HUD and menu button visibility is now managed by hideAllScreens and then explicitly shown when gameState is 'playing'.
        }

        function endGame(message) {
            console.log("GAME OVER CALLED with message:", message);
            gameOver = true;
            gameState = 'gameOver';
            showMessageBox(message);
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }

        // --- Main Game Loop ---
        function animate(currentTime) {
            if (!lastFrameTime) {
                lastFrameTime = currentTime;
            }
            const deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            if (gameState !== 'playing') { // Only update game logic if playing
                if (renderer && scene && camera) { // Defensive check for renderer
                    renderer.render(scene, camera); // Still render the scene even if paused/menu
                }
                requestAnimationFrame(animate); // Keep rendering the current state (menu/game over)
                return;
            }

            updatePlayer(deltaTime);
            updateBullets(deltaTime);
            spawnEnemy();
            updateEnemies(deltaTime);
            checkCollisions();

            if (renderer && scene && camera) { // Defensive check for renderer
                renderer.render(scene, camera);
            }
            requestAnimationFrame(animate);
        }

        // --- Screen Management ---
        function hideAllScreens() {
            mainMenuScreen.style.display = 'none';
            weaponSelectScreen.style.display = 'none'; // Changed from characterSelectScreen
            settingsScreen.style.display = 'none';
            messageBox.style.display = 'none'; // Always hide message box when changing screens
            playerHud.style.display = 'none'; // Hide HUD by default
            menuToggleButton.style.display = 'none'; // Hide menu button by default
            
            // Sembunyikan kontrol mobile secara eksplisit
            joystickContainer.style.display = 'none';
            shootButton.style.display = 'none';
            console.log("All screens hidden, including mobile controls.");
        }

        // Global flag to track if AdSense has been loaded for the main menu slot
        let adLoaded = false; // NEW

        function showMainMenu() {
            hideAllScreens();
            mainMenuScreen.style.display = 'flex'; // Ensure menu is visible first
            gameState = 'menu';
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }

            // Adjust button visibility and text based on game state
            if (gameStartedAtLeastOnce && !gameOver) {
                mainMenuPrimaryButton.textContent = translations[currentLanguage].continueGame;
                restartGameButton.style.display = 'block'; // Show restart button
            } else {
                mainMenuPrimaryButton.textContent = translations[currentLanguage].startGame;
                restartGameButton.style.display = 'none'; // Hide restart button if not paused game
            }
            welcomeMessageText.textContent = translations[currentLanguage].welcomeMessage;

            // Load AdSense when main menu is shown, but only once.
            if (typeof adsbygoogle !== 'undefined' && !adLoaded) {
                const adContainer = mainMenuScreen.querySelector('.ad-container');
                const insElement = adContainer.querySelector('ins.adsbygoogle'); // Get the ins element directly

                // Use a more generous delay to ensure the container is rendered and has dimensions
                setTimeout(() => {
                    console.log("Inside setTimeout for ad loading.");
                    console.log("mainMenuScreen offsetWidth:", mainMenuScreen.offsetWidth, "offsetHeight:", mainMenuScreen.offsetHeight);
                    console.log("Ad container offsetWidth:", adContainer.offsetWidth, "offsetHeight:", adContainer.offsetHeight);
                    console.log("Ins element offsetWidth:", insElement.offsetWidth, "offsetHeight:", insElement.offsetHeight);

                    // Re-check adLoaded flag and container dimensions inside the timeout
                    if (adContainer && adContainer.offsetWidth > 0 && adContainer.offsetHeight > 0 && !adLoaded) {
                        console.log("Ad container is ready. Attempting to load AdSense for main menu...");
                        (adsbygoogle = window.adsbygoogle || []).push({});
                        adLoaded = true;
                        console.log("AdSense push initiated.");
                    } else {
                        console.log("Ad container still not ready or ad already loaded, skipping AdSense push.");
                        // Optional: if still not ready, could try another delayed attempt or log a warning
                        if (adContainer.offsetWidth === 0 || adContainer.offsetHeight === 0) {
                            console.warn("Ad container still has zero dimensions after 3 seconds. Ad might not load.");
                        }
                    }
                }, 3000); // Increased to 3000ms (3 seconds)
            } else if (adLoaded) {
                console.log("AdSense already loaded for main menu, skipping push.");
            } else {
                console.log("adsbygoogle not defined or adLoaded is true, skipping AdSense push.");
            }
        }

        function showWeaponSelection() {
            hideAllScreens();
            weaponSelectScreen.style.display = 'flex';
            gameState = 'weaponSelect';
            // Ensure preview canvas is correctly sized when it becomes visible
            resizeRenderer(); // This will resize both main and preview renderers
            initWeaponPreview3D(); // Initialize weapon preview scene
            loadWeaponForPreview(currentWeaponIndex); // Load the current weapon for preview
        }

        function showSettings() {
            hideAllScreens();
            settingsScreen.style.display = 'flex';
            gameState = 'settings';
            updateSettingsDisplay(); // Update settings UI when shown
        }

        // --- Weapon Selection Logic (NEW) ---
        /**
         * Fungsi untuk menginisialisasi scene 3D untuk pratinjau senjata
         */
        function initWeaponPreview3D() {
            // Hanya inisialisasi jika belum ada
            if (previewScene) return;

            const previewCanvas = document.createElement('canvas');
            previewCanvas.id = 'weaponPreviewCanvas'; // Assign an ID for easier reference
            weaponPreviewContainer.appendChild(previewCanvas); // Append to the new container

            previewScene = new THREE.Scene();
            previewScene.background = new THREE.Color(0x1a1a2e); // Latar belakang scene

            previewCamera = new THREE.PerspectiveCamera(75, weaponPreviewContainer.clientWidth / weaponPreviewContainer.clientHeight, 0.1, 1000);
            previewCamera.position.set(0, 0, 5);

            previewRenderer = new THREE.WebGLRenderer({ canvas: previewCanvas, antialias: true, alpha: true });
            previewRenderer.setSize(weaponPreviewContainer.clientWidth, weaponPreviewContainer.clientHeight);
            previewRenderer.setPixelRatio(window.devicePixelRatio);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            previewScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            previewScene.add(directionalLight);

            previewControls = new THREE.OrbitControls(previewCamera, previewRenderer.domElement);
            previewControls.enableDamping = true;
            previewControls.dampingFactor = 0.05;
            previewControls.screenSpacePanning = false;
            previewControls.minDistance = 1;
            previewControls.maxDistance = 10;
            previewControls.maxPolarAngle = Math.PI / 2;

            // Start the preview animation loop
            animateWeaponPreview();
        }

        /**
         * Fungsi untuk memuat model senjata untuk pratinjau
         * @param {number} index - Indeks model senjata dalam array allWeaponsData
         */
        function loadWeaponForPreview(index) {
            loadingOverlay.style.display = 'flex';
            loadingOverlay.querySelector('p').textContent = translations[currentLanguage].loadingModel;

            if (currentPreviewModel) {
                previewScene.remove(currentPreviewModel);
                currentPreviewModel.traverse(function (child) {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    }
                });
                currentPreviewModel = null;
            }

            const weaponData = allWeaponsData[index];
            const fbxModelUrl = weaponData.modelPath;
            const loader = new THREE.FBXLoader();
            loader.load(
                fbxModelUrl,
                function (object) {
                    loadingOverlay.style.display = 'none';

                    object.scale.set(0.01, 0.01, 0.01); 
                    object.position.set(0, 0, 0);

                    currentPreviewModel = object;
                    previewScene.add(object);

                    updateDamageBar(weaponData.damage);
                    updateBuyButtonState(weaponData);

                    const box = new THREE.Box3().setFromObject(object);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = previewCamera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                    cameraZ *= 1.5;

                    previewCamera.position.set(center.x, center.y, center.z + cameraZ);
                    previewControls.target.copy(center);
                    previewControls.update();
                },
                function (xhr) {
                    const progress = (xhr.loaded / xhr.total) * 100;
                    loadingOverlay.querySelector('p').textContent = `${translations[currentLanguage].loadingModel} ${progress.toFixed(0)}%`;
                },
                function (error) {
                    console.error('Terjadi kesalahan saat memuat model FBX:', error);
                    loadingOverlay.innerHTML = `<p class="text-red-500">${translations[currentLanguage].failedToLoadModel}</p>`;
                }
            );
        }

        /**
         * Fungsi untuk memperbarui tampilan damage bar
         * @param {number} damageValue - Nilai damage (0-100)
         */
        function updateDamageBar(damageValue) {
            damageFill.style.width = `${damageValue}%`;
            damageText.textContent = `${translations[currentLanguage].weaponDamage} ${damageValue}`;
        }

        /**
         * Fungsi untuk memperbarui status tombol beli/pilih
         * @param {object} weaponData - Objek data senjata dari allWeaponsData
         */
        function updateBuyButtonState(weaponData) {
            const gameWeapon = weapons.find(w => w.id === weaponData.id);
            
            // Defensive check: If gameWeapon is not found, something is wrong with data initialization.
            if (!gameWeapon) {
                console.error("Error: gameWeapon not found in 'weapons' array for ID:", weaponData.id);
                weaponPriceDisplay.textContent = "Error"; // Clear price
                buyWeaponBtn.textContent = "Error";
                buyWeaponBtn.disabled = true;
                buyWeaponBtn.classList.remove('bg-blue-600', 'bg-purple-600', 'bg-gray-500', 'bg-green-700', 'bg-green-600');
                buyWeaponBtn.classList.add('bg-red-500'); // Indicate error
                return; // Exit the function to prevent further errors
            }

            // Update price display
            if (weaponData.price === 0) {
                weaponPriceDisplay.textContent = translations[currentLanguage].ownedButton; // If price is 0, it's the default pistol
            } else {
                weaponPriceDisplay.textContent = `${weaponData.price} ${translations[currentLanguage].coins}`;
            }

            if (gameWeapon.current) {
                buyWeaponBtn.textContent = translations[currentLanguage].currentWeapon;
                buyWeaponBtn.disabled = true;
                buyWeaponBtn.classList.remove('bg-blue-600', 'bg-purple-600', 'bg-gray-500', 'bg-green-700'); // Remove all others
                buyWeaponBtn.classList.add('bg-green-600');
            } else if (gameWeapon.owned) {
                buyWeaponBtn.textContent = translations[currentLanguage].ownedButton; // Changed to "Miliki"
                buyWeaponBtn.disabled = false; // Can still click to equip
                buyWeaponBtn.classList.remove('bg-green-600', 'bg-purple-600', 'bg-gray-500', 'bg-blue-600'); // Remove all others
                buyWeaponBtn.classList.add('bg-green-700'); // Darker green for owned but not current
            } else if (coins >= weaponData.price) {
                buyWeaponBtn.textContent = `${translations[currentLanguage].buyButton}`; // No price in button text, price is above
                buyWeaponBtn.disabled = false;
                buyWeaponBtn.classList.remove('bg-green-600', 'bg-blue-600', 'bg-gray-500', 'bg-green-700'); // Remove all others
                buyWeaponBtn.classList.add('bg-purple-600');
            } else {
                buyWeaponBtn.textContent = `${translations[currentLanguage].buyButton}`; // No price in button text, price is above
                buyWeaponBtn.disabled = true;
                buyWeaponBtn.classList.remove('bg-green-600', 'bg-blue-600', 'bg-purple-600', 'bg-green-700'); // Remove all others
                buyWeaponBtn.classList.add('bg-gray-500');
            }
        }

        /**
         * Fungsi untuk menampilkan senjata sebelumnya
         */
        function showPreviousWeapon() {
            currentWeaponIndex = (currentWeaponIndex - 1 + allWeaponsData.length) % allWeaponsData.length;
            loadWeaponForPreview(currentWeaponIndex);
        }

        /**
         * Fungsi untuk menampilkan senjata berikutnya
         */
        function showNextWeapon() {
            currentWeaponIndex = (currentWeaponIndex + 1) % allWeaponsData.length;
            loadWeaponForPreview(currentWeaponIndex);
        }

        /**
         * Fungsi untuk menangani aksi beli/pilih senjata
         */
        function buyWeapon() {
            const weaponToProcess = allWeaponsData[currentWeaponIndex];
            const gameWeapon = weapons.find(w => w.id === weaponToProcess.id);

            // Defensive check
            if (!gameWeapon) {
                console.error("Error: gameWeapon not found in 'weapons' array for ID:", weaponToProcess.id);
                showMessageBox("Error processing weapon. Please restart the game.");
                return; // Exit the function
            }

            if (gameWeapon.owned) {
                // If owned, just equip it
                equipWeapon(gameWeapon);
                showMessageBox(`${translations[currentLanguage].weaponNames[gameWeapon.id]} ${translations[currentLanguage].currentWeapon.toLowerCase()}!`);
            } else if (coins >= weaponToProcess.price) {
                // If not owned and enough coins, buy and equip
                coins -= weaponToProcess.price;
                gameWeapon.owned = true;
                updateCoinsDisplay();
                equipWeapon(gameWeapon);
                showMessageBox(`${translations[currentLanguage].weaponBought} (${translations[currentLanguage].weaponNames[gameWeapon.id]})`);
            } else {
                // Not enough coins
                showMessageBox(translations[currentLanguage].notEnoughCoins);
            }
            saveWeaponsToLocalStorage();
            updateBuyButtonState(weaponToProcess); // Update button state after action
        }

        function equipWeapon(weaponToEquip) {
            // Deselect old weapon
            if (currentWeapon) {
                currentWeapon.current = false;
            }
            
            // Select new weapon
            weaponToEquip.current = true;
            currentWeapon = weaponToEquip;
            BULLET_DAMAGE = currentWeapon.damage; // Update global damage
            
            loadInGameWeaponModel(currentWeapon.modelPath); // Load new in-game model
            saveWeaponsToLocalStorage(); // Save changes
            console.log(`Weapon ${weaponToEquip.name} equipped!`);
        }


        // --- Event Listeners ---
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                if (gameState === 'playing') {
                    // Pause game and show main menu
                    if (document.pointerLockElement) {
                        document.exitPointerLock(); // This will trigger pointerlockchange and set gameState to 'menu'
                    } else {
                        // Fallback if pointer lock somehow wasn't active
                        gameState = 'menu'; // Set to menu state directly
                        showMainMenu(); // Show main menu
                    }
                } else if (gameState === 'weaponSelect' || gameState === 'settings' || gameState === 'gameOver') {
                    // From sub-menu or game over, go to main menu
                    showMainMenu();
                } else if (gameState === 'menu' && gameStartedAtLeastOnce && !gameOver) {
                    // If in main menu (as a pause) and game has been started, resume game
                    resumeGame();
                }
            } else if (gameState === 'playing') { // Only process other keys if playing
                keys[e.key] = true;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (gameState === 'playing') {
                keys[e.key] = false;
            }
        });

        // --- Pointer Lock for Mouse Rotation ---
        const canvas3D = document.getElementById('gameCanvas3D');

        function requestPointerLock() {
            if (!canvas3D) {
                console.error("Cannot request pointer lock: canvas3D element not found.");
                return;
            }
            // Only request pointer lock if it's not already active
            if (document.pointerLockElement !== canvas3D) {
                canvas3D.requestPointerLock = canvas3D.requestPointerLock || canvas3D.mozRequestPointerLock || canvas3D.webkitRequestPointerLock;
                if (canvas3D.requestPointerLock) {
                    canvas3D.requestPointerLock().then(() => {
                        console.log("Pointer lock successful.");
                    }).catch((e) => {
                        console.error("Pointer lock failed or exited:", e);
                    });
                }
            }
        }

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === canvas3D || document.mozPointerLockElement === canvas3D || document.webkitPointerLockElement === canvas3D;
            if (isPointerLocked) {
                console.log('Pointer locked');
                // If pointer lock is acquired, and we were in the menu (as a pause), transition to playing.
                if (gameState === 'menu' && gameStartedAtLeastOnce && !gameOver) { // If we were in menu as a pause
                    gameState = 'playing';
                    playerHud.style.display = 'flex';
                    menuToggleButton.style.display = 'block';
                    // Tampilkan kontrol mobile jika lebar layar kurang dari 768px
                    if (window.innerWidth < 768) {
                        joystickContainer.style.display = 'block';
                        shootButton.style.display = 'block';
                        console.log(`pointerlockchange: Mobile controls displayed. window.innerWidth: ${window.innerWidth}`);
                    } else {
                        joystickContainer.style.display = 'none';
                        shootButton.style.display = 'none';
                        console.log(`pointerlockchange: Desktop detected. Mobile controls remain hidden. window.innerWidth: ${window.innerWidth}`);
                    }
                }
            } else {
                console.log('Pointer unlocked');
                isMouseDown = false;
                isZoomed = false;
                updateCameraFOV(false);
                // If pointer is unlocked and game was playing (not game over), it means user exited pointer lock
                if (gameState === 'playing' && !gameOver) {
                    gameState = 'menu'; // Transition to menu state (as pause menu)
                    showMainMenu(); // Show main menu
                }
            }
        }, false);

        document.addEventListener('mozpointerlockchange', () => {
            isPointerLocked = document.mozPointerLockElement === canvas3D;
        }, false);

        document.addEventListener('webkitpointerlockchange', () => {
            isPointerLocked = document.webkitPointerLockElement === canvas3D;
        }, false);

        // Click on canvas to request pointer lock (only if playing and not locked)
        canvas3D.addEventListener('click', () => {
            if (gameState === 'playing' && !isPointerLocked) { 
                requestPointerLock();
            }
        });

        // --- Mouse Down (Left Click) for Shooting, Right Click for Zoom ---
        document.addEventListener('mousedown', (event) => {
            if (gameState === 'playing' && isPointerLocked) {
                if (event.button === 0) { // Left click
                    isMouseDown = true;
                    shootBullet();
                } else if (event.button === 2) { // Right click
                    event.preventDefault(); // Prevent context menu
                    isZoomed = true;
                    updateCameraFOV(true);
                }
            }
        });

        document.addEventListener('mouseup', (event) => {
            if (event.button === 0) {
                isMouseDown = false;
            } else if (event.button === 2) { // Right click release
                isZoomed = false;
                updateCameraFOV(false);
            }
        });

        // Function to handle bullet shooting logic
        function shootBullet() {
            // Only shoot if camera is defined
            if (!camera) {
                console.warn("Cannot shoot: camera not initialized.");
                return;
            }

            const bulletMaterial = new THREE.MeshPhongMaterial({ color: BULLET_COLOR });
            const bulletMesh = new THREE.Mesh(BULLET_GEOMETRY, bulletMaterial);

            const bulletSpawnPoint = new THREE.Vector3();
            camera.getWorldPosition(bulletSpawnPoint);
            
            const bulletDirection = new THREE.Vector3();
            camera.getWorldDirection(bulletDirection);
            bulletDirection.normalize();

            bulletMesh.position.copy(bulletSpawnPoint);
            
            const tempQuaternion = new THREE.Quaternion();
            tempQuaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), bulletDirection);
            bulletMesh.setRotationFromQuaternion(tempQuaternion);

            scene.add(bulletMesh);
            bullets.push({ mesh: bulletMesh, direction: bulletDirection });
            playSound(playerShootSynth, "C4", "16n");
        }

        document.addEventListener('mousemove', (event) => {
            // Only apply rotation if playerYawObject and camera are defined
            if (gameState === 'playing' && isPointerLocked && playerYawObject && camera) {
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                playerYawObject.rotation.y -= movementX * mouseSensitivity;
                camera.rotation.x -= movementY * mouseSensitivity;
                camera.rotation.x = Math.max(-pitchLimit, Math.min(pitchLimit, camera.rotation.x));
            }
        });

        // Prevent context menu on right-click
        canvas3D.addEventListener('contextmenu', (e) => e.preventDefault());

        // --- Mobile Touch Drag for Camera Rotation (on canvas) ---
        canvas3D.addEventListener('touchstart', (e) => {
            // Only activate touch drag for camera if not interacting with joystick/buttons
            // Check if the touch is NOT on the joystick or shoot button
            if (e.touches.length === 1 && gameState === 'playing' && e.target === canvas3D) {
                isTouchDragging = true;
                previousTouchX = e.touches[0].clientX;
                previousTouchY = e.touches[0].clientY;
            }
        }, { passive: false });

        canvas3D.addEventListener('touchmove', (e) => {
            // Only apply rotation if playerYawObject and camera are defined
            if (isTouchDragging && e.touches.length === 1 && e.target === canvas3D && playerYawObject && camera) {
                e.preventDefault();
                const currentTouchX = e.touches[0].clientX;
                const currentTouchY = e.touches[0].clientY;

                const deltaX = currentTouchX - previousTouchX;
                const deltaY = currentTouchY - previousTouchY;

                if (Math.abs(deltaX) > touchDragThreshold || Math.abs(deltaY) > touchDragThreshold) {
                    playerYawObject.rotation.y -= deltaX * touchSensitivity;
                    camera.rotation.x -= deltaY * touchSensitivity;
                    camera.rotation.x = Math.max(-pitchLimit, Math.min(pitchLimit, camera.rotation.x));
                }

                previousTouchX = currentTouchX;
                previousTouchY = currentTouchY;
            }
        }, { passive: false });

        canvas3D.addEventListener('touchend', () => {
            isTouchDragging = false;
        });
        canvas3D.addEventListener('touchcancel', () => {
            isTouchDragging = false; // Also reset preview dragging on touch cancel
        });

        // --- Joystick Logic (NEW) ---
        const joystickBase = document.getElementById('joystickBase');
        const joystickKnob = document.getElementById('joystickKnob');

        let joystick = {
            active: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            radius: 0, // Will be calculated in window.onload
            knobRadius: 0, // Will be calculated in window.onload
            maxDistance: 0 // Will be calculated in window.onload
        };

        // Update joystick position and map to movement flags
        function updateJoystick(e) {
            if (!joystick.active) return;

            const touch = e.touches[0];
            
            // Get the current position of the joystick base relative to the viewport
            const rect = joystickBase.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            let deltaX = touch.clientX - centerX;
            let deltaY = touch.clientY - centerY;

            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (distance > joystick.maxDistance) {
                const angle = Math.atan2(deltaY, deltaX);
                deltaX = joystick.maxDistance * Math.cos(angle);
                deltaY = joystick.maxDistance * Math.sin(angle);
            }

            joystickKnob.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

            // Map joystick position to movement flags
            touchMoveForward = false;
            touchMoveBackward = false;
            touchMoveLeft = false;
            touchMoveRight = false;

            const deadZone = joystick.maxDistance * 0.1; // 10% dead zone
            if (distance > deadZone) {
                const angle = Math.atan2(deltaY, deltaX); // Angle in radians

                // Determine direction based on angle (8 directions)
                // Adjusting angles for typical FPS movement (forward is -Y, backward is +Y)
                // 0 = right, PI/2 = down, PI = left, -PI/2 = up
                if (angle > -Math.PI / 4 && angle <= Math.PI / 4) { // Right
                    touchMoveRight = true;
                } else if (angle > Math.PI / 4 && angle <= 3 * Math.PI / 4) { // Down (Backward)
                    touchMoveBackward = true;
                } else if (angle > 3 * Math.PI / 4 || angle <= -3 * Math.PI / 4) { // Left
                    touchMoveLeft = true;
                } else { // Up (Forward)
                    touchMoveForward = true;
                }
            }
        }

        if (joystickBase) { // Ensure joystick elements exist before adding listeners
            joystickBase.addEventListener('touchstart', (e) => {
                if (gameState === 'playing' && e.touches.length === 1) {
                    e.preventDefault(); // Prevent scrolling
                    joystick.active = true;
                    joystickKnob.style.transition = 'none'; // Disable transition during drag
                    updateJoystick(e); // Initial update
                }
            }, { passive: false });

            joystickBase.addEventListener('touchmove', (e) => {
                if (gameState === 'playing' && joystick.active) {
                    e.preventDefault(); // Prevent scrolling
                    updateJoystick(e);
                }
            }, { passive: false });

            joystickBase.addEventListener('touchend', () => {
                joystick.active = false;
                joystickKnob.style.transition = 'transform 0.1s ease-out'; // Re-enable transition
                joystickKnob.style.transform = 'translate(0, 0)'; // Reset knob position
                // Reset movement flags
                touchMoveForward = false;
                touchMoveBackward = false;
                touchMoveLeft = false;
                touchMoveRight = false;
            });
            joystickBase.addEventListener('touchcancel', () => {
                joystick.active = false;
                joystickKnob.style.transition = 'transform 0.1s ease-out';
                joystickKnob.style.transform = 'translate(0, 0)';
                touchMoveForward = false;
                touchMoveBackward = false;
                touchMoveLeft = false;
                touchMoveRight = false;
            });
        }

        // --- Mobile Shoot Button ---
        shootButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === 'playing') {
                shootBullet();
            }
        }, { passive: false });

        restartButton.addEventListener('click', startGame); // This button is only in messageBox (Game Over), always restarts.

        // Menu button listeners
        mainMenuPrimaryButton.addEventListener('click', () => {
            if (gameStartedAtLeastOnce && !gameOver) {
                resumeGame();
            } else {
                startGame();
            }
        });
        restartGameButton.addEventListener('click', startGame); // This always triggers a full restart
        weaponSelectButton.addEventListener('click', showWeaponSelection); // Renamed
        settingsButton.addEventListener('click', showSettings);
        backToMainMenuFromWeaponButton.addEventListener('click', showMainMenu); // New listener
        backToMainMenuFromSettingsButton.addEventListener('click', showMainMenu);

        menuToggleButton.addEventListener('click', () => {
            if (gameState === 'playing') {
                // Pause game and show main menu
                if (document.pointerLockElement) {
                    document.exitPointerLock(); // This will trigger pointerlockchange and set gameState to 'menu'
                } else {
                    // Fallback if pointer lock somehow wasn't active
                    gameState = 'menu'; // Set to menu state directly
                    showMainMenu(); // Show main menu
                }
            } else if (gameState === 'menu' && gameStartedAtLeastOnce && !gameOver) {
                // If in main menu (as a pause) and game has been started, resume game
                resumeGame();
            }
        });

        // Settings control listeners
        mouseSensitivitySlider.addEventListener('input', (e) => {
            mouseSensitivity = parseFloat(e.target.value);
            updateSettingsDisplay(); // Update display immediately
        });

        volumeSlider.addEventListener('input', (e) => {
            masterVolume = parseFloat(e.target.value);
            Tone.Destination.volume.value = (masterVolume * 40) - 40; // Map 0-1 to -40dB to 0dB
            updateSettingsDisplay(); // Update display immediately
        });

        langIdButton.addEventListener('click', () => updateLanguage('id'));
        langEnButton.addEventListener('click', () => updateLanguage('en'));

        // NEW WEAPON SELECT BUTTON LISTENERS
        buyWeaponBtn.addEventListener('click', buyWeapon);
        prevWeaponBtn.addEventListener('click', showPreviousWeapon);
        nextWeaponBtn.addEventListener('click', showNextWeapon);

        // Function to update UI elements on weapon select screen based on current language
        function updateWeaponPreviewUI() {
            const t = translations[currentLanguage];

            // Update text content for weapon select screen
            weaponSelectTitle.textContent = t.weaponSelectTitle;
            backToMainMenuFromWeaponButton.textContent = t.backToMainMenu;
            loadingOverlay.querySelector('p').textContent = t.loadingModel;
            
            // Update buy button text based on current weapon state
            const currentPreviewWeaponData = allWeaponsData[currentWeaponIndex];
            updateBuyButtonState(currentPreviewWeaponData);
        }

        // --- Animation loop for Weapon Preview (NEW) ---
        function animateWeaponPreview() {
            requestAnimationFrame(animateWeaponPreview);
            if (previewControls) {
                previewControls.update(); // only required if controls.enableDamping is set to true
            }
            if (previewRenderer && previewScene && previewCamera) {
                previewRenderer.render(previewScene, previewCamera);
            }
        }

        // Handle window resize
        function resizeRenderer() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            if (renderer) { // Check if renderer is defined
                renderer.setSize(width, height);
            }
            if (camera) { // Check if camera is defined
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }
            // Resize preview canvas as well
            if (previewRenderer && weaponPreviewContainer) { // Check all preview related objects
                const previewWidth = weaponPreviewContainer.clientWidth;
                const previewHeight = weaponPreviewContainer.clientHeight;
                previewRenderer.setSize(previewWidth, previewHeight);
                if (previewCamera) {
                    previewCamera.aspect = previewWidth / previewHeight;
                    previewCamera.updateProjectionMatrix();
                }
            }
        }

        window.addEventListener('resize', resizeRenderer);

        // Update camera FOV for zoom
        function updateCameraFOV(zoomed) {
            if (camera) {
                camera.fov = zoomed ? ZOOM_FOV : ORIGINAL_FOV;
                camera.updateProjectionMatrix();
            }
        }

        // Function to update all displayed text based on current language
        function updateLanguageDisplay() {
            const t = translations[currentLanguage];

            // Update main menu
            mainMenuTitle.textContent = t.gameTitle;
            welcomeMessageText.textContent = t.welcomeMessage; // Set welcome message
            // Buttons are handled dynamically by showMainMenu, but their text needs updating
            mainMenuPrimaryButton.textContent = (gameStartedAtLeastOnce && !gameOver) ? t.continueGame : t.startGame;
            restartGameButton.textContent = t.restartGame;
            weaponSelectButton.textContent = t.selectWeapon;
            settingsButton.textContent = t.settings;

            // Update weapon select screen UI
            updateWeaponPreviewUI(); // Call this to update titles, buttons, etc.

            // Update settings screen
            settingsScreen.querySelector('h1').textContent = t.settingsTitle;
            settingsScreen.querySelector('p').textContent = t.settingsPlaceholder;
            document.getElementById('mouseSensitivityLabel').textContent = t.mouseSensitivityLabel;
            document.getElementById('volumeLabel').textContent = t.volumeLabel;
            document.getElementById('languageLabel').textContent = t.languageLabel;
            backToMainMenuFromSettingsButton.textContent = t.backToMainMenu;

            // Update HUD
            coinsDisplay.textContent = `${t.coins} ${coins}`; // Changed from score
            healthLabel.textContent = `${t.health} ${Math.max(0, Math.floor(playerHealth))}`;
            shieldLabel.textContent = `${t.shield} ${Math.max(0, Math.floor(playerShield))}`;

            // Update message box (only for Game Over)
            restartButton.textContent = t.restartButton;
            if (messageBox.style.display === 'block' && messageText.dataset.originalMessage) {
                if (messageText.dataset.originalMessage.includes("GAME OVER!")) {
                    messageText.textContent = t.gameOverMessage;
                }
            }

            // Update mobile shoot button
            shootButton.innerHTML = `<i class="fas fa-crosshairs"></i> ${t.shootButton}`;

            // Update settings display to reflect language button selection
            updateSettingsDisplay();

            // Update orientation message
            document.getElementById('orientationMessage').querySelector('p:first-child').textContent = t.orientationMessage;
        }

        // --- Orientation Check ---
        function checkOrientation() {
            const orientationMessage = document.getElementById('orientationMessage');
            console.log(`checkOrientation: Current window.innerWidth: ${window.innerWidth}, window.innerHeight: ${window.innerHeight}`);
            // Check if it's a mobile device and in portrait mode
            if (window.innerWidth < window.innerHeight && /Mobi|Android/i.test(navigator.userAgent)) {
                orientationMessage.style.display = 'flex';
                // Pause game if it's currently playing
                if (gameState === 'playing') {
                    if (document.pointerLockElement) {
                        document.exitPointerLock();
                    }
                    // gameState will be set to 'menu' by pointerlockchange listener or manually if no pointer lock
                    showMainMenu(); // Ensure menu is shown
                    mainMenuPrimaryButton.textContent = translations[currentLanguage].continueGame; // Show continue button
                    restartGameButton.style.display = 'block'; // Show restart button
                    welcomeMessageText.textContent = translations[currentLanguage].gamePaused; // Update welcome message
                }
                // Explicitly hide mobile controls when in portrait
                joystickContainer.style.display = 'none';
                shootButton.style.display = 'none';
                console.log(`checkOrientation: Portrait mode detected. Mobile controls hidden. Joystick display: ${joystickContainer.style.display}, Shoot button display: ${shootButton.style.display}`);
            } else {
                orientationMessage.style.display = 'none';
                // If game was paused due to orientation, and now it's landscape, reset welcome message
                if (gameState === 'menu' && gameStartedAtLeastOnce && !gameOver) {
                    welcomeMessageText.textContent = translations[currentLanguage].welcomeMessage;
                }
                // If game is playing and in landscape, show mobile controls if on mobile device
                if (gameState === 'playing' && window.innerWidth < 768) { // Still check innerWidth for mobile
                    joystickContainer.style.display = 'block';
                    shootButton.style.display = 'block';
                    console.log(`checkOrientation: Landscape mode (mobile) detected. Mobile controls displayed. Joystick display: ${joystickContainer.style.display}, Shoot button display: ${shootButton.style.display}`);
                } else {
                    joystickContainer.style.display = 'none';
                    shootButton.style.display = 'none';
                    console.log(`checkOrientation: Desktop or portrait (not playing) detected. Mobile controls hidden. Joystick display: ${joystickContainer.style.display}, Shoot button display: ${shootButton.style.display}`);
                }
            }
        }


        // Initial setup on window load
        window.onload = function() {
            console.log(`window.onload: Initial window.innerWidth: ${window.innerWidth}, window.innerHeight: ${window.innerHeight}`);
            // Attempt to initialize Three.js components
            const threeJSInitialized = initThreeJS();

            // If Three.js initialization failed, stop further game setup
            if (!threeJSInitialized) {
                console.error("Three.js initialization failed. Game cannot proceed.");
                return;
            }

            // Set initial volume for Tone.js
            Tone.Destination.volume.value = (masterVolume * 40) - 40;
            
            // Initialize game elements, which loads weapons from localStorage
            initializeGameElements();

            // Then, update UI elements based on the initialized game state
            showMainMenu(); // Start with main menu visible
            updateLanguageDisplay(); // Initial display updates based on default language
            updateHealthShieldDisplay(); // Ensure health/shield bars are initialized
            updateSettingsDisplay(); // Ensure settings UI reflects initial values

            // Initialize joystick dimensions after elements are rendered
            if (joystickBase && joystickKnob) {
                joystick.radius = joystickBase.clientWidth / 2;
                joystick.knobRadius = joystickKnob.clientWidth / 2;
                joystick.maxDistance = joystick.radius - joystick.knobRadius;
            }

            // Check initial orientation and set up listeners
            checkOrientation();
            window.addEventListener('orientationchange', checkOrientation);
            window.addEventListener('resize', checkOrientation); // Also check on resize as orientationchange might not fire on all devices


            // Start the animation loop, but game logic will only run when gameState is 'playing'
            animate();
        };

    </script>
</body>
</html>

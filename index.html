<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!--
      Tag Title Utama untuk tab browser
    -->
    <title>fire123-game: FPS Web Game</title>

    <!--
      Meta Description untuk deskripsi di hasil pencarian Google
    -->
    <meta name="description" content="Mainkan Fire123, game tembak-tembakan FPS sederhana berbasis web dengan grafis 3D dan kontrol responsif. Targetkan musuh dan raih skor tertinggi!" />
    
    <!--
      Keywords (opsional, tapi bisa membantu)
    -->
    <meta name="keywords" content="FPS game, web game, three.js game, fire123, shooting game, game tembak-tembakan, game online gratis, 3D game, WebGL" />
    
    <!--
      Penulis/Kredit (opsional)
    -->
    <meta name="author" content="Tim Pengembang Game Fire123" />

    <!--
      Open Graph Meta Tags untuk Facebook, LinkedIn, WhatsApp, dll.
      Ini membuat tautan Anda terlihat bagus saat dibagikan.
    -->
    <meta property="og:type" content="game.website" />
    <meta property="og:url" content="https://fire123-game.vercel.app/" />
    <meta property="og:title" content="fire123-game: Game Tembak-tembakan FPS Web 3D" />
    <meta property="og:description" content="Mainkan Fire123, game tembak-tembakan FPS sederhana berbasis web dengan grafis 3D dan kontrol responsif. Targetkan musuh dan raih skor tertinggi!" />
    <meta property="og:image" content="https://placehold.co/1200x630/000/FFF?text=Fire123%20Game%20Preview" /> 
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <!--
      Twitter Card Meta Tags untuk pratinjau di Twitter
    -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://fire123-game.vercel.app/" />
    <meta property="twitter:title" content="fire123-game: Game Tembak-tembakan FPS Web 3D" />
    <meta property="twitter:description" content="Mainkan Fire123, game tembak-tembakan FPS sederhana berbasis web dengan grafis 3D dan kontrol responsif. Targetkan musuh dan raih skor tertinggi!" />
    <meta property="twitter:image" content="https://placehold.co/1200x630/000/FFF?text=Fire123%20Game%20Preview" /> 
    <meta property="twitter:creator" content="@yourtwitterhandle" /> 
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.1/umd/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Latar belakang gelap */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Mencegah scrolling */
            position: relative; /* Untuk posisi kotak pesan */
            width: 100vw;
            height: 100vh;
        }
        #gameCanvas3D {
            background-color: #000; /* Latar belakang game */
            display: block;
            touch-action: none; /* Nonaktifkan tindakan sentuh default seperti scrolling/zooming */
            width: 100%;
            height: 100%;
            border-radius: 0; /* Hapus border-radius untuk layar penuh */
            box-shadow: none; /* Hapus bayangan untuk layar penuh */
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 0; /* Hapus padding untuk konten edge-to-edge */
            margin: 0; /* Hapus margin */
            overflow: hidden; /* Pastikan konten tidak meluap */
            position: relative; /* Untuk crosshair */
            width: 100vw;
            height: 100vh;
            max-width: 100vw; /* Pastikan mengambil lebar penuh */
            background-color: #2d3748; /* Latar belakang kontainer lebih gelap */
        }
        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            color: #e2e8f0;
            font-weight: bold;
            z-index: 10; /* Di atas kanvas */
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 220px; /* Menyesuaikan untuk HUD di kanan atas */
            padding: 0 1rem;
            font-size: 1.8rem; /* Ukuran font lebih besar */
            text-shadow: 0 0 8px #0ff, 0 0 12px #0ff; /* Cahaya neon untuk teks */
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            border: 2px solid #0ff;
            box-shadow: 0 0 20px #0ff;
            z-index: 1000;
            display: none; /* Tersembunyi secara default */
        }
        .message-box button {
            margin-top: 1rem;
            padding: 0.75rem 1.5rem;
            background-color: #0ff;
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: bold;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 10px #0ff;
        }
        .message-box button:hover {
            background-color: #0cc;
            transform: scale(1.05);
        }

        /* Kontrol Mobile */
        .mobile-controls {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 1rem;
            gap: 0.5rem;
            z-index: 10; /* Di atas kanvas */
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            right: 1rem;
            padding: 0 1rem;
        }
        .mobile-controls button {
            flex: 1;
            padding: 1rem;
            background-color: #4a5568;
            color: #e2e8f0;
            border: none;
            border-radius: 8px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        .mobile-controls button:active {
            background-color: #0ff;
            color: #000;
            transform: scale(0.95);
        }
        .mobile-controls .left-right-buttons {
            display: flex;
            gap: 0.5rem;
            flex: 2;
        }
        .mobile-controls .shoot-button {
            flex: 1;
        }

        @media (min-width: 768px) {
            .mobile-controls {
                display: none; /* Sembunyikan di desktop */
            }
        }

        /* Crosshair */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 1px solid #0ff;
            border-radius: 50%;
            box-shadow: 0 0 5px #0ff;
            pointer-events: none; /* Memungkinkan klik melewati */
            z-index: 5;
        }
        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background-color: #0ff;
        }
        .crosshair::before {
            width: 2px;
            height: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .crosshair::after {
            width: 10px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Main Menu Styles */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #e2e8f0;
            z-index: 2000;
        }
        .menu-screen h1 {
            font-size: 4rem;
            margin-bottom: 2rem;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
        }
        .menu-screen button {
            padding: 1rem 2.5rem;
            margin: 0.75rem 0;
            background-color: #0ff;
            color: #000;
            border: none;
            border-radius: 12px;
            font-size: 1.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            box-shadow: 0 0 15px #0ff;
        }
        .menu-screen button:hover {
            background-color: #0cc;
            transform: scale(1.05);
            box-shadow: 0 0 25px #0cc;
        }

        /* Player HUD Bars */
        .player-hud {
            position: absolute;
            top: 1rem; /* Changed from bottom */
            right: 1rem; /* Changed from left */
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            width: 200px; /* Lebar default untuk desktop */
        }
        .health-bar, .shield-bar {
            width: 100%;
            height: 25px;
            background-color: #333;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #e2e8f0;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            position: relative;
        }
        .health-bar-fill, .shield-bar-fill {
            height: 100%;
            width: 100%; /* Default to full */
            transition: width 0.2s ease-out, background-color 0.2s ease-out;
            border-radius: 6px;
            position: absolute;
            top: 0;
            left: 0;
        }
        .health-bar-fill {
            background-color: #0F0; /* Green */
        }
        .shield-bar-fill {
            background-color: #00F; /* Blue */
        }
        .bar-label {
            position: absolute;
            width: 100%;
            text-align: center;
            color: #fff;
            font-weight: bold;
            line-height: 25px; /* Vertically center text */
            text-shadow: 0 0 5px #000;
            font-size: 0.9rem;
        }

        /* Responsive adjustments for HUD */
        @media (max-width: 767px) {
            .player-hud {
                width: 150px; /* Lebih kecil di mobile */
                top: 0.5rem; /* Changed from bottom */
                right: 0.5rem; /* Changed from left */
            }
            .health-bar, .shield-bar {
                height: 20px;
            }
            .bar-label {
                font-size: 0.8rem;
                line-height: 20px;
            }
            .game-info {
                font-size: 1.2rem;
                top: 0.5rem;
                left: 0.5rem;
                right: calc(0.5rem + 150px + 0.5rem); /* Adjusted for mobile HUD width */
            }
        }

        /* Settings Screen Specific Styles */
        .settings-group {
            width: 80%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-bottom: 1rem;
        }
        .settings-group label {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            color: #a0aec0;
        }
        .settings-group input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #4a5568;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 4px;
        }
        .settings-group input[type="range"]:hover {
            opacity: 1;
        }
        .settings-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0ff;
            cursor: pointer;
            box-shadow: 0 0 10px #0ff;
        }
        .settings-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0ff;
            cursor: pointer;
            box-shadow: 0 0 10px #0ff;
        }
        .settings-group span.text-sm {
            align-self: flex-end;
            margin-top: 0.25rem;
            color: #cbd5e0;
        }
        .settings-group button {
            padding: 0.5rem 1rem;
            font-size: 1rem;
            margin: 0; /* Override default menu button margin */
        }
        .settings-group button.selected {
            background-color: #0cc;
            box-shadow: 0 0 15px #0cc;
        }

        /* Weapon Selection Screen Styles */
        #weaponList {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            max-width: 900px;
            width: 90%;
            margin-top: 2rem;
            justify-content: center;
        }
        #weaponList > div {
            background-color: #2d3748;
            border-radius: 12px;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #weaponList > div:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.5);
        }
        #weaponList h2 {
            font-size: 2.5rem;
            font-weight: bold;
            color: #0ff;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 10px #0ff;
        }
        #weaponList p {
            font-size: 1.2rem;
            color: #e2e8f0;
            margin-bottom: 1rem;
        }
        #weaponList button {
            padding: 0.75rem 1.5rem;
            font-size: 1.1rem;
            border-radius: 8px;
            font-weight: bold;
            transition: background-color 0.3s, transform 0.2s;
            margin-top: 1rem;
        }
        #weaponList button.bg-green-600 {
            background-color: #10B981; /* Tailwind green-500 */
            color: #fff;
        }
        #weaponList button.bg-blue-600 {
            background-color: #3B82F6; /* Tailwind blue-500 */
            color: #fff;
        }
        #weaponList button.bg-gray-500 {
            background-color: #6B7280; /* Tailwind gray-500 */
            color: #cbd5e0;
        }

        /* Weapon Preview Container */
        #weaponPreviewContainer {
            position: relative;
            cursor: grab; /* Indicate draggable */
        }
        #weaponPreviewCanvas {
            background-color: rgba(0,0,0,0.3); /* Semi-transparent background for canvas */
        }
        #weaponPreviewHint {
            pointer-events: none; /* Allow events to pass through to canvas */
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-info">
            <div id="coins">Koin: 0</div>
            </div>
        <button id="menuToggleButton" class="absolute top-4 right-4 z-50 p-3 bg-gray-700 text-white rounded-full shadow-lg hover:bg-gray-600 transition-colors">
            <i class="fas fa-bars text-xl"></i>
        </button>
        <div class="crosshair"></div>
        <canvas id="gameCanvas3D"></canvas>

        <div class="mobile-controls">
            <div class="left-right-buttons">
                <button id="leftButton" class="rounded-lg"><i class="fas fa-arrow-left"></i></button>
                <button id="rightButton" class="rounded-lg"><i class="fas fa-arrow-right"></i></button>
            </div>
            <button id="forwardButton" class="rounded-lg"><i class="fas fa-arrow-up"></i></button>
            <button id="backwardButton" class="rounded-lg"><i class="fas fa-arrow-down"></i></button>
            <button id="shootButton" class="shoot-button rounded-lg"><i class="fas fa-crosshairs"></i> Tembak</button>
        </div>

        <div class="player-hud">
            <div class="health-bar">
                <div id="healthBarFill" class="health-bar-fill"></div>
                <span class="bar-label" id="healthLabel">Kesehatan: 100</span>
            </div>
            <div class="shield-bar">
                <div id="shieldBarFill" class="shield-bar-fill"></div>
                <span class="bar-label" id="shieldLabel">Perisai: 50</span>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="restartButton">Mulai Ulang</button>
    </div>

    <div id="mainMenuScreen" class="menu-screen">
        <h1 id="mainMenuTitle">fire123-game</h1>
        <p id="welcomeMessageText" class="text-xl text-center mb-4 px-4"></p>
        <button id="mainMenuPrimaryButton">Mulai Game</button> 
        <button id="restartGameButton" style="display: none;">Mulai Ulang</button> 
        <button id="weaponSelectButton">Pilih Senjata</button> 
        <button id="settingsButton">Pengaturan</button>
    </div>

    <div id="weaponSelectScreen" class="menu-screen" style="display: none;">
        <h1 id="weaponSelectTitle">Pilih Senjata</h1>
        <div id="weaponPreviewContainer" class="w-full max-w-sm h-64 bg-gray-900 rounded-lg shadow-inner flex items-center justify-center relative my-4">
            <canvas id="weaponPreviewCanvas" class="w-full h-full rounded-lg"></canvas>
            <p id="weaponPreviewHint" class="absolute text-gray-400 text-sm" style="display: none;"></p> </div>
        <div id="weaponList">
            </div>
        <button id="backToMainMenuFromWeapon">Kembali ke Menu Utama</button>
    </div>

    <div id="settingsScreen" class="menu-screen" style="display: none;">
        <h1>Pengaturan</h1>
        <p>Atur opsi game di sini.</p>
        <div class="settings-group">
            <label for="mouseSensitivitySlider" id="mouseSensitivityLabel">Sensitivitas Mouse:</label>
            <input type="range" id="mouseSensitivitySlider" min="0.0005" max="0.005" step="0.0001" value="0.0015" class="w-full">
            <span id="mouseSensitivityValue" class="text-sm">0.0015</span>
        </div>
        <div class="settings-group mt-4">
            <label for="volumeSlider" id="volumeLabel">Volume:</label>
            <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.5" class="w-full">
            <span id="volumeValue" class="text-sm">50%</span>
        </div>
        <div class="settings-group mt-4">
            <label id="languageLabel">Bahasa:</label>
            <div class="flex gap-2 mt-2">
                <button id="langIdButton" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md text-base">Indonesia</button>
                <button id="langEnButton" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-md text-base">English</button>
            </div>
        </div>
        <button id="backToMainMenuFromSettings" class="mt-8">Kembali ke Menu Utama</button>
    </div>

    <script>
        // Get info elements
        const coinsDisplay = document.getElementById('coins'); // Changed from score

        // Get message box elements
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton'); // This is for Game Over screen

        // Get main menu elements
        const mainMenuScreen = document.getElementById('mainMenuScreen');
        const mainMenuTitle = document.getElementById('mainMenuTitle');
        const welcomeMessageText = document.getElementById('welcomeMessageText');
        const mainMenuPrimaryButton = document.getElementById('mainMenuPrimaryButton');
        const restartGameButton = document.getElementById('restartGameButton'); // This is for pause menu restart
        const weaponSelectButton = document.getElementById('weaponSelectButton'); // Renamed
        const settingsButton = document.getElementById('settingsButton');

        // Get weapon select elements
        const weaponSelectScreen = document.getElementById('weaponSelectScreen');
        const weaponSelectTitle = document.getElementById('weaponSelectTitle');
        const weaponList = document.getElementById('weaponList');
        const backToMainMenuFromWeaponButton = document.getElementById('backToMainMenuFromWeapon');
        const weaponPreviewCanvas = document.getElementById('weaponPreviewCanvas'); // New
        const weaponPreviewHint = document.getElementById('weaponPreviewHint'); // New

        // Get settings elements
        const settingsScreen = document.getElementById('settingsScreen');
        const backToMainMenuFromSettingsButton = document.getElementById('backToMainMenuFromSettings');
        const mouseSensitivitySlider = document.getElementById('mouseSensitivitySlider');
        const mouseSensitivityValueDisplay = document.getElementById('mouseSensitivityValue');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValueDisplay = document.getElementById('volumeValue');
        const langIdButton = document.getElementById('langIdButton');
        const langEnButton = document.getElementById('langEnButton');

        // Get mobile controls
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const forwardButton = document.getElementById('forwardButton');
        const backwardButton = document.getElementById('backwardButton');
        const shootButton = document.getElementById('shootButton');

        // Get player HUD elements
        const healthBarFill = document.getElementById('healthBarFill');
        const healthLabel = document.getElementById('healthLabel');
        const shieldBarFill = document.getElementById('shieldBarFill');
        const shieldLabel = document.getElementById('shieldLabel');
        const playerHud = document.querySelector('.player-hud');

        // Get menu toggle button
        const menuToggleButton = document.getElementById('menuToggleButton');

        // Three.js variables
        let scene, camera, renderer;
        let playerYawObject; // Object to handle horizontal rotation (yaw)
        let playerCapsule; // Invisible mesh for player collision and position (child of playerYawObject)
        let bullets = []; // Array of { mesh, velocity }
        let enemies = []; // Array of { mesh, speed }
        let obstacles = []; // Array of obstacle meshes
        let playerGunModel; // Variable to hold the gun model (FBX)
        let playerModel; // Variable to hold the player model (FBX)

        // Game variables
        let coins = 0; // Changed from score
        let playerHealth = 100;
        let playerMaxHealth = 100;
        let playerShield = 50;
        let playerMaxShield = 50;
        let gameOver = false;
        // 'menu': main menu, can be initial or pause state
        // 'playing': game is active
        // 'gameOver': game has ended
        // 'weaponSelect': weapon selection screen
        // 'settings': settings screen
        let gameState = 'menu'; 
        let gameStartedAtLeastOnce = false; // Flag to track if game has been started from main menu

        // Timing variables for frame-rate independence
        let lastFrameTime = 0;

        // Debugging flag - SET THIS TO TRUE TO SEE COLLISION BOXES
        const DEBUG_COLLISIONS = false; // Dimatikan untuk tampilan yang lebih bersih

        // Player properties (in Three.js units)
        const PLAYER_HEIGHT_OFFSET = 0.5; // How high the camera is from the ground
        const PLAYER_RADIUS = 0.3; // For simple cylindrical collision
        const PLAYER_BASE_SPEED = 2.0; // Adjusted to be slower, similar to Valorant's walking speed
        const PLAYER_COLOR = 0x00FFFF; // Cyan (not visible, but for conceptual player body)

        // Bullet properties (in Three.js units)
        const BULLET_WIDTH = 0.05;
        const BULLET_HEIGHT = 0.8;
        const BULLET_SPEED = 15; // Speed units per second (will be multiplied by deltaTime)
        const BULLET_COLOR = 0xFF00FF; // Magenta
        let BULLET_DAMAGE = 10; // This will change based on selected weapon
        const ZOOMED_BULLET_DAMAGE_MULTIPLIER = 2.5; // Zoomed damage is this much more than base weapon damage

        // Pre-rotated bullet geometry (length along Z-axis)
        const BULLET_GEOMETRY = new THREE.CylinderGeometry(BULLET_WIDTH, BULLET_WIDTH, BULLET_HEIGHT, 8).rotateX(Math.PI / 2);

        // Enemy properties (in Three.js units)
        const ENEMY_SIZE = 0.7; // Base size for enemy scaling
        const ENEMY_BODY_HEIGHT = 0.8;
        const ENEMY_HEAD_RADIUS = 0.2;
        const ENEMY_ARM_LENGTH = 0.5;
        const ENEMY_LEG_LENGTH = 0.5;
        const ENEMY_SPEED_MIN = 0.5; // Speed units per second
        const ENEMY_SPEED_MAX = 1.5; // Speed units per second
        const ENEMY_COLOR = 0xFF0000; // Red
        const ENEMY_SPAWN_INTERVAL = 1500; // milliseconds (diperpanjang untuk debugging)
        let lastEnemySpawnTime = 0; // Akan diinisialisasi dengan Date.now() saat game dimulai
        const ENEMY_DAMAGE_TO_PLAYER = 20; // Damage an enemy deals to player on collision

        // Game world dimensions (in Three.js units)
        const WORLD_SCALE_FACTOR = 3.5; // New scale factor for the map
        const ORIGINAL_WORLD_WIDTH = 10;
        const ORIGINAL_WORLD_DEPTH = 15;
        const WORLD_WIDTH = ORIGINAL_WORLD_WIDTH * WORLD_SCALE_FACTOR;
        const WORLD_DEPTH = ORIGINAL_WORLD_DEPTH * WORLD_SCALE_FACTOR;
        const WORLD_HEIGHT = 5;

        // FOV for zoom
        const ORIGINAL_FOV = 75;
        const ZOOM_FACTOR = 1.5;
        const ZOOM_FOV = ORIGINAL_FOV / ZOOM_FACTOR;
        let isZoomed = false;

        // Epsilon for collision push-out
        const EPSILON = 0.01;

        // Keyboard input
        const keys = {};
        let isMouseDown = false; // Flag for mouse button state

        // Touch input for movement (simplified for FPS)
        let touchMoveForward = false;
        let touchMoveBackward = false;
        let touchMoveLeft = false;
        let touchMoveRight = false;

        // Camera rotation variables
        let isPointerLocked = false;
        // mouseSensitivity is now a global variable controlled by settings
        let mouseSensitivity = 0.0015; // Default value, can be changed in settings
        const pitchLimit = Math.PI / 2 - 0.1; // Limit vertical look (e.g., 80 degrees up/down)
        let isTouchDragging = false;
        let previousTouchX = 0;
        let previousTouchY = 0;
        const touchSensitivity = 0.003; // Adjusted for touch rotation
        const touchDragThreshold = 5; // Minimum pixel movement to register as a drag for rotation

        // Sound effects using Tone.js
        const playerShootSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: {
                attack: 0.001,
                decay: 0.1,
                sustain: 0.05,
                release: 0.1
            }
        }).toDestination();

        const enemyExplodeSynth = new Tone.NoiseSynth({
            noise: { type: "white" },
            envelope: {
                attack: 0.001,
                decay: 0.2,
                sustain: 0.01,
                release: 0.3
            }
        }).toDestination();

        const playerHitSynth = new Tone.Synth({
            oscillator: { type: "triangle" },
            envelope: {
                attack: 0.001,
                decay: 0.2,
                sustain: 0.1,
                release: 0.5
            }
        }).toDestination();

        // masterVolume is now a global variable controlled by settings
        let masterVolume = 0.5; // Default volume (0.0 to 1.0)
        let currentLanguage = 'id'; // 'id' for Indonesian, 'en' for English

        // Weapon data
        const weapons = [
            // Pistol sekarang adalah senjata default dengan harga 0 koin dan kerusakan 15
            { id: 'pistol', name: 'Pistol', damage: 15, price: 0, current: true, modelPath: 'https://raw.githubusercontent.com/fajrigans/assetgametembak/main/ImageToStl.com_buatkan_senjata_temba_0531174819_texture_fbx.fbx' },
            // AR-15 sekarang berharga 1500 koin dan memiliki kerusakan 20
            { id: 'ar15', name: 'AR-15 Style Rifle', damage: 20, price: 1500, current: false, modelPath: 'https://raw.githubusercontent.com/fajrigans/assetgametembak/main/ImageToStl.com_buatkan_senjata_temba_0531124219_texture_fbx.fbx' }
        ];
        // Temukan senjata yang saat ini dipilih (awalnya pistol)
        let currentWeapon = weapons.find(w => w.current); 

        const translations = {
            'id': {
                'gameTitle': 'fire123-game',
                'startGame': 'Mulai Game',
                'continueGame': 'Lanjutkan', // New
                'restartGame': 'Mulai Ulang', // New
                'selectWeapon': 'Pilih Senjata', // Changed from characterSelect
                'settings': 'Pengaturan',
                'backToMainMenu': 'Kembali ke Menu Utama',
                'weaponSelectTitle': 'Pilih Senjata',
                'weaponDamage': 'Kerusakan:', // New
                'buyButton': 'Beli', // New
                'currentWeapon': 'Terpilih', // New
                'settingsTitle': 'Pengaturan',
                'settingsPlaceholder': 'Atur opsi game di sini.',
                'mouseSensitivityLabel': 'Sensitivitas Mouse:',
                'volumeLabel': 'Volume:',
                'languageLabel': 'Bahasa:',
                'coins': 'Koin:', // Changed from score
                'health': 'Kesehatan:',
                'shield': 'Perisai:',
                'gameOverMessage': 'GAME OVER! Musuh menabrak Anda.',
                'restartButton': 'Mulai Ulang', // For game over screen
                'welcomeMessage': "Selamat datang! Gunakan ESC atau tombol menu untuk membuka/menutup menu. Klik di dalam area game untuk mengaktifkan kontrol kamera.",
                'shootButton': 'Tembak',
                'gamePaused': 'Game Dijeda.',
                'weaponPreviewNoModel': 'Model senjata tidak tersedia.', // New
                'weaponNames': { // New nested object for weapon names
                    'ar15': 'Senapan Gaya AR-15',
                    'pistol': 'Pistol'
                }
            },
            'en': {
                'gameTitle': 'fire123-game',
                'startGame': 'Start Game',
                'continueGame': 'Continue', // New
                'restartGame': 'Restart', // New
                'selectWeapon': 'Select Weapon', // Changed from characterSelect
                'settings': 'Settings',
                'backToMainMenu': 'Back to Main Menu',
                'weaponSelectTitle': 'Select Weapon',
                'weaponDamage': 'Damage:', // New
                'buyButton': 'Buy', // New
                'currentWeapon': 'Equipped', // New
                'settingsTitle': 'Settings',
                'settingsPlaceholder': 'Adjust game options here.',
                'mouseSensitivityLabel': 'Mouse Sensitivity:',
                'volumeLabel': 'Volume:',
                'languageLabel': 'Language:',
                'coins': 'Coins:', // Changed from score
                'health': 'Health:',
                'shield': 'Shield:',
                'gameOverMessage': 'GAME OVER! Enemy collided with you.',
                'restartButton': 'Restart', // For game over screen
                'welcomeMessage': "Welcome! Use ESC or the menu button to open/close the menu. Click inside the game area to activate camera controls.",
                'shootButton': 'Shoot',
                'gamePaused': 'Game Paused.',
                'weaponPreviewNoModel': 'Weapon model not available.', // New
                'weaponNames': { // New nested object for weapon names
                    'ar15': 'AR-15 Style Rifle',
                    'pistol': 'Pistol'
                }
            }
        };

        // Weapon Preview 3D variables
        let weaponPreviewScene, weaponPreviewCamera, weaponPreviewRenderer;
        let currentPreviewModel = null;
        let previewRotationX = 0;
        let previewRotationY = 0;
        let isPreviewDragging = false;
        let prevPreviewMouseX = 0;
        let prevPreviewMouseY = 0;
        const previewRotationSpeed = 0.005; // Adjust as needed

        // Helper function to play sound only if audio context is running and valid
        function playSound(synth, note, duration) {
            if (Tone.context.state === 'running' && typeof Tone.context.currentTime === 'number' && Tone.context.currentTime >= 0) {
                try {
                    if (synth && synth.triggerAttackRelease) {
                        synth.triggerAttackRelease(note, duration);
                    }
                } catch (e) {
                    console.error("Error playing sound:", e);
                }
            } else {
                console.warn("Konteks audio tidak berjalan atau waktu tidak valid, tidak dapat memutar suara.");
            }
        }

        // --- Three.js Initialization ---
        function initThreeJS() {
            // Scene
            scene = new THREE.Scene(); 

            // Camera (Perspective for FPS)
            camera = new THREE.PerspectiveCamera(ORIGINAL_FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, PLAYER_HEIGHT_OFFSET, 0); // Camera position relative to playerYawObject

            // Renderer
            const canvas3D = document.getElementById('gameCanvas3D');
            renderer = new THREE.WebGLRenderer({ canvas: canvas3D, alpha: false, antialias: true }); // Initialize renderer here
            renderer.setPixelRatio(window.devicePixelRatio); // Set pixel ratio for high DPI displays
            renderer.shadowMap.enabled = true; // Mengaktifkan peta bayangan
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Jenis bayangan yang lebih lembut
            resizeRenderer(); // Set initial size

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x606060); // Increased ambient light for better overall visibility
            scene.add(ambientLight);

            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7); // Light from above and below
            scene.add(hemisphereLight); // ADDED HEMISPHERE LIGHT BACK

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 15, 5); // Posisi cahaya
            directionalLight.castShadow = true; // Cahaya ini akan memancarkan bayangan
            scene.add(directionalLight);

            // Pengaturan bayangan untuk directional light
            directionalLight.shadow.mapSize.width = 2048; // Resolusi peta bayangan (lebih tinggi = lebih tajam)
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -WORLD_WIDTH / 2;
            directionalLight.shadow.camera.right = WORLD_WIDTH / 2;
            directionalLight.shadow.camera.top = WORLD_DEPTH / 2;
            directionalLight.shadow.camera.bottom = -WORLD_DEPTH / 2;
            directionalLight.shadow.bias = -0.0005; // Mengurangi "shadow acne"

            // Ground Plane (now larger)
            const groundGeometry = new THREE.PlaneGeometry(WORLD_WIDTH, WORLD_DEPTH);
            const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22, side: THREE.DoubleSide }); // Forest green
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            ground.position.y = 0; // At y=0
            ground.position.z = -WORLD_DEPTH / 2 + (ORIGINAL_WORLD_DEPTH / 2); // Shift back to center the original play area
            ground.receiveShadow = true; // Tanah akan menerima bayangan
            scene.add(ground);

            // Player Yaw Object (handles horizontal rotation for player and camera)
            playerYawObject = new THREE.Object3D(); // Initialize playerYawObject here
            scene.add(playerYawObject); // Add to scene

            // Player Capsule (invisible for player collision, child of playerYawObject)
            const playerCapsuleGeometry = new THREE.CylinderGeometry(PLAYER_RADIUS, PLAYER_RADIUS, PLAYER_HEIGHT_OFFSET * 2, 16);
            const playerCapsuleMaterial = DEBUG_COLLISIONS ? new THREE.MeshBasicMaterial({ color: 0x00FF00, wireframe: true, transparent: true, opacity: 0.5 }) : new THREE.MeshBasicMaterial({ visible: false });
            playerCapsule = new THREE.Mesh(playerCapsuleGeometry, playerCapsuleMaterial);
            playerCapsule.position.y = PLAYER_HEIGHT_OFFSET; // Position relative to playerYawObject's base
            playerYawObject.add(playerCapsule); // Add as child

            playerYawObject.add(camera); // Make camera a child of playerYawObject

            // Load Weapon Model (FBX) - This is for the in-game gun
            // This will be loaded dynamically based on currentWeapon.modelPath
            loadInGameWeaponModel(currentWeapon.modelPath);


            // Add initial environment assets
            addEnvironmentAssets();
            
            // Add Skybox
            addSkybox();
        }

        // Function to load the in-game weapon model
        function loadInGameWeaponModel(modelPath) {
            if (playerGunModel) {
                camera.remove(playerGunModel);
                playerGunModel = null;
            }

            if (!modelPath) {
                console.warn("No model path for in-game weapon. Using fallback.");
                const gunGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
                const gunMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                playerGunModel = new THREE.Mesh(gunGeometry, gunMaterial);
                playerGunModel.position.set(0.3, -0.25, -0.5);
                playerGunModel.castShadow = true;
                camera.add(playerGunModel);
                return;
            }

            const fbxLoader = new THREE.FBXLoader();
            fbxLoader.load(modelPath, (fbx) => {
                playerGunModel = fbx;
                playerGunModel.scale.set(0.005, 0.005, 0.005);
                playerGunModel.position.set(0.3, -0.25, -0.5);
                playerGunModel.rotation.set(Math.PI, Math.PI, Math.PI); // Adjust rotation as needed
                playerGunModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    child.material = new THREE.MeshPhongMaterial({ color: mat.color });
                                    mat.needsUpdate = true;
                                });
                            } else {
                                child.material = new THREE.MeshPhongMaterial({ color: child.material.color });
                                child.material.needsUpdate = true;
                            }
                        } else {
                            child.material = new THREE.MeshPhongMaterial({ color: 0x888888 });
                        }
                    }
                });
                camera.add(playerGunModel);
            }, undefined, (error) => {
                console.error("Error loading in-game weapon FBX model:", error);
                // Fallback to simple box gun if model fails to load
                const gunGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
                const gunMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                playerGunModel = new THREE.Mesh(gunGeometry, gunMaterial);
                playerGunModel.position.set(0.3, -0.25, -0.5);
                playerGunModel.castShadow = true;
                camera.add(playerGunModel);
            });
        }


        // Helper function to add a box obstacle
        function addObstacle(x, y, z, sizeX, sizeY, sizeZ, color = 0x8B4513) {
            const obstacleGeometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
            const obstacleMaterial = new THREE.MeshPhongMaterial({ color: color });
            const obstacleMesh = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacleMesh.position.set(x, y + sizeY / 2, z);
            obstacleMesh.castShadow = true; // Rintangan memancarkan bayangan
            obstacleMesh.receiveShadow = true; // Rintangan menerima bayangan
            scene.add(obstacleMesh);
            obstacles.push(obstacleMesh);

            if (DEBUG_COLLISIONS) {
                const boxHelper = new THREE.BoxHelper(obstacleMesh, 0xFFFF00);
                scene.add(boxHelper);
                obstacleMesh.userData.boxHelper = boxHelper;
            }
        }

        // Helper function to add a cylinder obstacle (e.g., pillar, barrel)
        function addCylinderObstacle(x, y, z, radius, height, color = 0x696969) {
            const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, height, 32);
            const cylinderMaterial = new THREE.MeshPhongMaterial({ color: color });
            const cylinderMesh = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinderMesh.position.set(x, y + height / 2, z);
            cylinderMesh.castShadow = true; // Silinder memancarkan bayangan
            cylinderMesh.receiveShadow = true; // Silinder menerima bayangan
            scene.add(cylinderMesh);
            obstacles.push(cylinderMesh);

            if (DEBUG_COLLISIONS) {
                const boxHelper = new THREE.BoxHelper(cylinderMesh, 0xFFFF00);
                scene.add(boxHelper);
                cylinderMesh.userData.boxHelper = boxHelper;
            }
        }

        function addEnvironmentAssets() {
            obstacles.forEach(o => {
                scene.remove(o);
                if (DEBUG_COLLISIONS && o.userData.boxHelper) {
                    scene.remove(o.userData.boxHelper);
                }
            });
            obstacles = [];

            addObstacle(0, 0, -5, 2, 1, 2, 0x808080);
            addCylinderObstacle(3, 0, -7, 0.8, 2.5, 0x556B2F);
            addObstacle(-3, 0, -3, 1.5, 1.5, 1.5, 0x708090);
            addObstacle(0, 0, 8, 10, 5, 4, 0x4682B4);
            addObstacle(0, 5, 8, 11, 1, 5, 0x8B4513);
            addObstacle(-WORLD_WIDTH / 2 + 2, 0, 0, 1, 3, 8, 0x6A5ACD);
            addObstacle(WORLD_WIDTH / 2 - 2, 0, 0, 1, 3, 8, 0x6A5ACD);
            addObstacle(-WORLD_WIDTH / 4, 0, -10, 3, 2, 1.5, 0xCD853F);
            addCylinderObstacle(WORLD_WIDTH / 4, 0, -10, 0.6, 2, 0xCD853F);

            for (let i = 0; i < 8; i++) {
                const x = (Math.random() * (WORLD_WIDTH - 2)) - (WORLD_WIDTH / 2 - 1);
                const z = (Math.random() * (WORLD_DEPTH - 2)) - (WORLD_DEPTH / 2 - 1);
                const size = 0.5 + Math.random() * 1.5;
                const height = 0.5 + Math.random() * 2;
                addObstacle(x, 0, z, size, height, size, 0x778899);
            }
        }

        // --- Enemy Creation Function (More complex shape) ---
        function createEnemyMesh() {
            const enemyGroup = new THREE.Group();
            const material = new THREE.MeshPhongMaterial({ color: ENEMY_COLOR });

            const bodyGeometry = new THREE.BoxGeometry(ENEMY_SIZE * 0.6, ENEMY_BODY_HEIGHT, ENEMY_SIZE * 0.4);
            const bodyMesh = new THREE.Mesh(bodyGeometry, material);
            bodyMesh.position.y = ENEMY_BODY_HEIGHT / 2;
            bodyMesh.castShadow = true; // Badan musuh memancarkan bayangan
            enemyGroup.add(bodyMesh);

            const headGeometry = new THREE.SphereGeometry(ENEMY_HEAD_RADIUS, 16, 16);
            const headMesh = new THREE.Mesh(headGeometry, material);
            headMesh.position.y = ENEMY_BODY_HEIGHT + ENEMY_HEAD_RADIUS;
            headMesh.castShadow = true; // Kepala musuh memancarkan bayangan
            enemyGroup.add(headMesh);

            const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, ENEMY_ARM_LENGTH, 8);
            const leftArm = new THREE.Mesh(armGeometry, material);
            leftArm.position.set(-(ENEMY_SIZE * 0.3 + 0.1), ENEMY_BODY_HEIGHT * 0.7, 0);
            leftArm.rotation.z = Math.PI / 4;
            leftArm.castShadow = true; // Lengan memancarkan bayangan
            enemyGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, material);
            rightArm.position.set((ENEMY_SIZE * 0.3 + 0.1), ENEMY_BODY_HEIGHT * 0.7, 0);
            rightArm.rotation.z = -Math.PI / 4;
            rightArm.castShadow = true; // Lengan memancarkan bayangan
            enemyGroup.add(rightArm);

            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, ENEMY_LEG_LENGTH, 8);
            const leftLeg = new THREE.Mesh(legGeometry, material);
            leftLeg.position.set(-(ENEMY_SIZE * 0.2), ENEMY_LEG_LENGTH / 2, 0);
            leftLeg.castShadow = true; // Kaki memancarkan bayangan
            enemyGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, material);
            rightLeg.position.set((ENEMY_SIZE * 0.2), ENEMY_LEG_LENGTH / 2, 0);
            rightLeg.castShadow = true; // Kaki memancarkan bayangan
            enemyGroup.add(rightLeg);

            enemyGroup.position.y = ENEMY_LEG_LENGTH / 2;
            enemyGroup.receiveShadow = true; // Musuh menerima bayangan (dari dirinya sendiri atau objek lain)

            // Add health bar to enemy
            const healthBarWidth = 1.2;
            const healthBarHeight = 0.15;

            const healthBarBackgroundGeometry = new THREE.PlaneGeometry(healthBarWidth, healthBarHeight);
            const healthBarBackgroundMaterial = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
            const healthBarBackground = new THREE.Mesh(healthBarBackgroundGeometry, healthBarBackgroundMaterial);
            healthBarBackground.position.y = ENEMY_BODY_HEIGHT + ENEMY_HEAD_RADIUS + 0.3;
            enemyGroup.add(healthBarBackground);
            enemyGroup.userData.healthBarBackground = healthBarBackground;

            const healthBarForegroundGeometry = new THREE.PlaneGeometry(healthBarWidth * 0.9, healthBarHeight * 0.8);
            const healthBarForegroundMaterial = new THREE.MeshBasicMaterial({ color: 0x00FF00, side: THREE.DoubleSide });
            const healthBarForeground = new THREE.Mesh(healthBarForegroundGeometry, healthBarForegroundMaterial);
            healthBarForeground.position.y = ENEMY_BODY_HEIGHT + ENEMY_HEAD_RADIUS + 0.3;
            healthBarForeground.position.z = 0.01;
            enemyGroup.add(healthBarForeground);
            enemyGroup.userData.healthBar = healthBarForeground;

            enemyGroup.userData.maxHealth = 30; // ENEMY_MAX_HEALTH
            enemyGroup.userData.currentHealth = 30; // ENEMY_MAX_HEALTH

            return enemyGroup;
        }

        // --- Skybox Implementation ---
        function addSkybox() {
            const path = "https://threejs.org/examples/textures/cube/Bridge2/";
            const urls = [
                path + "posx.jpg", path + "negx.jpg",
                path + "posy.jpg", path + "negy.jpg",
                path + "posz.jpg", path + "negz.jpg"
            ];

            const cubeTextureLoader = new THREE.CubeTextureLoader();
            cubeTextureLoader.load(urls, (texture) => {
                scene.background = texture;
            }, undefined, (error) => {
                console.error("Error loading skybox textures:", error);
                scene.background = new THREE.Color(0x333333); 
            });
        }


        // --- Game Initialization ---
        function initializeGameElements() {
            console.log("initializeGameElements called");
            bullets.forEach(b => scene.remove(b.mesh));
            enemies.forEach(e => scene.remove(e.mesh));

            bullets = [];
            enemies = [];
            // Load coins from localStorage, default to 0 if not found
            const savedCoins = localStorage.getItem('gameCoins');
            coins = savedCoins ? parseInt(savedCoins) : 0;
            
            playerHealth = playerMaxHealth;
            playerShield = playerMaxShield;
            lastEnemySpawnTime = Date.now();
            updateCoinsDisplay(); // Changed from updateScoreDisplay
            updateHealthShieldDisplay(); // Update new health/shield display

            playerYawObject.position.set(0, 0, 5);
            playerYawObject.rotation.y = 0;
            camera.rotation.x = 0;
            
            addEnvironmentAssets();
            addSkybox();
        }

        // Fungsi untuk memulai permainan (dari awal)
        function startGame() { // This function is for a full restart
            console.log("startGame called (full restart)");
            initializeGameElements(); // Resets coins, health, enemies, player position
            gameOver = false;
            gameState = 'playing';
            gameStartedAtLeastOnce = true;

            hideAllScreens();
            playerHud.style.display = 'flex';
            menuToggleButton.style.display = 'block';
            Tone.start();
            requestPointerLock();
            console.log("New Game Started!");
        }

        // New function to resume the game without resetting
        function resumeGame() {
            console.log("resumeGame called");
            gameOver = false; // Ensure game is not in game over state
            gameState = 'playing';
            hideAllScreens();
            playerHud.style.display = 'flex';
            menuToggleButton.style.display = 'block';
            requestPointerLock();
            // No need to call animate() here, it's already running.
            console.log("Game Resumed!");
        }


        // --- Update Game State Functions ---
        function updatePlayer(deltaTime) {
            const moveSpeed = PLAYER_BASE_SPEED * deltaTime;
            const originalX = playerYawObject.position.x;
            const originalZ = playerYawObject.position.z;

            const forwardVector = new THREE.Vector3(0, 0, -1).applyQuaternion(playerYawObject.quaternion);
            forwardVector.y = 0;
            forwardVector.normalize();

            const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(playerYawObject.quaternion);
            rightVector.y = 0;
            rightVector.normalize();

            let movementVector = new THREE.Vector3();

            if (keys['ArrowUp'] || keys['w'] || touchMoveForward) {
                movementVector.add(forwardVector);
            }
            if (keys['ArrowDown'] || keys['s'] || touchMoveBackward) {
                movementVector.sub(forwardVector);
            }
            if (keys['ArrowLeft'] || keys['a'] || touchMoveLeft) {
                movementVector.sub(rightVector);
            }
            if (keys['ArrowRight'] || keys['d'] || touchMoveRight) {
                movementVector.add(rightVector);
            }

            if (movementVector.lengthSq() > 0) {
                movementVector.normalize();
                movementVector.multiplyScalar(moveSpeed);
            }

            playerYawObject.position.x += movementVector.x;
            const playerBoxAfterXMove = new THREE.Box3().setFromObject(playerCapsule);
            for (const obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBoxAfterXMove.intersectsBox(obstacleBox)) {
                    playerYawObject.position.x = originalX;
                    break;
                }
            }

            playerYawObject.position.z += movementVector.z;
            const playerBoxAfterZMove = new THREE.Box3().setFromObject(playerCapsule);
            for (const obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBoxAfterZMove.intersectsBox(obstacleBox)) {
                    playerYawObject.position.z = originalZ;
                    break;
                }
            }

            playerYawObject.position.y = 0; 

            const halfWorldWidth = WORLD_WIDTH / 2 - PLAYER_RADIUS;
            const halfWorldDepth = WORLD_DEPTH / 2 - PLAYER_RADIUS;

            if (playerYawObject.position.x < -halfWorldWidth) playerYawObject.position.x = -halfWorldWidth;
            if (playerYawObject.position.x > halfWorldWidth) playerYawObject.position.x = halfWorldWidth;
            if (playerYawObject.position.z > halfWorldDepth) playerYawObject.position.z = halfWorldDepth;
            if (playerYawObject.position.z < -halfWorldDepth) playerYawObject.position.z = -halfWorldDepth;
        }

        function updateBullets(deltaTime) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.mesh.position.add(bullet.direction.clone().multiplyScalar(BULLET_SPEED * deltaTime));

                if (
                    bullet.mesh.position.z < -WORLD_DEPTH / 2 - 2 ||
                    bullet.mesh.position.z > WORLD_DEPTH / 2 + 2 ||
                    bullet.mesh.position.x < -WORLD_WIDTH / 2 - 2 ||
                    bullet.mesh.position.x > WORLD_WIDTH / 2 + 2
                ) {
                    scene.remove(bullet.mesh);
                    bullets.splice(i, 1);
                }
            }
        }

        function spawnEnemy() {
            const now = Date.now();
            if (now - lastEnemySpawnTime > ENEMY_SPAWN_INTERVAL) {
                const x = (Math.random() * (WORLD_WIDTH - ENEMY_SIZE)) - (WORLD_WIDTH / 2 - ENEMY_SIZE / 2);
                const z = -(WORLD_DEPTH / 2) - ENEMY_SIZE - (Math.random() * 5); // Spawn further back
                const speed = ENEMY_SPEED_MIN + Math.random() * (ENEMY_SPEED_MAX - ENEMY_SPEED_MIN);

                const enemyMesh = createEnemyMesh();
                enemyMesh.position.set(x, 0, z);
                scene.add(enemyMesh);

                enemies.push({ mesh: enemyMesh, speed: speed });
                lastEnemySpawnTime = now;
            }
        }

        function updateEnemies(deltaTime) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                // Move enemy towards player
                const directionToPlayer = new THREE.Vector3().subVectors(playerYawObject.position, enemy.mesh.position).normalize();
                enemy.mesh.position.add(directionToPlayer.multiplyScalar(enemy.speed * deltaTime));

                // Make enemy look at player (only yaw)
                enemy.mesh.lookAt(playerYawObject.position.x, enemy.mesh.position.y, playerYawObject.position.z);
                enemy.mesh.rotation.x = 0; // Prevent tilting up/down
                enemy.mesh.rotation.z = 0; // Prevent rolling

                // Update health bar orientation to face camera
                if (enemy.mesh.userData.healthBar && camera) {
                    enemy.mesh.userData.healthBar.quaternion.copy(camera.quaternion);
                    enemy.mesh.userData.healthBarBackground.quaternion.copy(camera.quaternion);
                }

                const playerCollisionBox = new THREE.Box3().setFromObject(playerCapsule);
                const enemyBox = new THREE.Box3().setFromObject(enemy.mesh);

                if (playerCollisionBox.intersectsBox(enemyBox)) {
                    // Apply damage to player's shield first, then health
                    let damageRemaining = ENEMY_DAMAGE_TO_PLAYER;
                    if (playerShield > 0) {
                        const shieldDmg = Math.min(playerShield, damageRemaining);
                        playerShield -= shieldDmg;
                        damageRemaining -= shieldDmg;
                    }
                    if (damageRemaining > 0) {
                        playerHealth -= damageRemaining;
                    }
                    
                    playSound(playerHitSynth, "C3", "8n");
                    updateHealthShieldDisplay(); // Update health and shield bars
                    
                    scene.remove(enemy.mesh);
                    enemies.splice(i, 1);
                    
                    if (playerHealth <= 0) {
                        endGame(translations[currentLanguage].gameOverMessage);
                    }
                    continue;
                }

                // Remove enemies that pass the player
                if (enemy.mesh.position.z > playerYawObject.position.z + 5) { // If enemy is 5 units past player
                    scene.remove(enemy.mesh);
                    enemies.splice(i, 1);
                }
            }
        }

        // --- Collision Detection ---
        function checkCollisions() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                const bulletBox = new THREE.Box3().setFromObject(bullet.mesh);

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const enemyBox = new THREE.Box3().setFromObject(enemy.mesh);

                    if (bulletBox.intersectsBox(enemyBox)) {
                        playSound(enemyExplodeSynth, "C2", "8n");
                        scene.remove(bullet.mesh);
                        bullets.splice(i, 1);

                        // Apply damage and update health bar
                        // Kerusakan peluru kini disesuaikan dengan nilai BULLET_DAMAGE saat ini
                        enemy.mesh.userData.currentHealth -= (isZoomed ? (BULLET_DAMAGE * ZOOMED_BULLET_DAMAGE_MULTIPLIER) : BULLET_DAMAGE);
                        const healthRatio = enemy.mesh.userData.currentHealth / enemy.mesh.userData.maxHealth;

                        enemy.mesh.userData.healthBar.scale.x = healthRatio;
                        // Adjust position to keep left edge fixed
                        enemy.mesh.userData.healthBar.position.x = (enemy.mesh.userData.healthBar.geometry.parameters.width / 2) * (healthRatio - 1);

                        // Change health bar color based on health
                        if (healthRatio > 0.5) {
                            enemy.mesh.userData.healthBar.material.color.setHex(0x00FF00); // Green
                        } else if (healthRatio > 0.2) {
                            enemy.mesh.userData.healthBar.material.color.setHex(0xFFFF00); // Yellow
                        } else {
                            enemy.mesh.userData.healthBar.material.color.setHex(0xFF0000); // Red
                        }

                        if (enemy.mesh.userData.currentHealth <= 0) {
                            scene.remove(enemy.mesh);
                            enemies.splice(j, 1);
                            coins += 10; // Changed from score
                            updateCoinsDisplay(); // Changed from updateScoreDisplay
                        }
                        break; // Bullet hit an enemy, stop checking other enemies for this bullet
                    }
                }
            }
        }

        // --- Display Updates ---
        function updateCoinsDisplay() { // Changed from updateScoreDisplay
            coinsDisplay.textContent = `${translations[currentLanguage].coins} ${coins}`; // Changed from score
            localStorage.setItem('gameCoins', coins); // Save coins to localStorage
        }

        function updateHealthShieldDisplay() {
            // Health Bar
            const healthPercentage = (playerHealth / playerMaxHealth) * 100;
            healthBarFill.style.width = `${Math.max(0, healthPercentage)}%`;
            healthLabel.textContent = `${translations[currentLanguage].health} ${Math.max(0, Math.floor(playerHealth))}`;
            if (playerHealth > 50) {
                healthBarFill.style.backgroundColor = '#0F0'; // Green
            } else if (playerHealth > 20) {
                healthBarFill.style.backgroundColor = '#FFD700'; // Gold/Yellow
            } else {
                healthBarFill.style.backgroundColor = '#F00'; // Red
            }

            // Shield Bar
            const shieldPercentage = (playerShield / playerMaxShield) * 100;
            shieldBarFill.style.width = `${Math.max(0, shieldPercentage)}%`;
            shieldLabel.textContent = `${translations[currentLanguage].shield} ${Math.max(0, Math.floor(playerShield))}`;
            if (playerShield > 20) {
                shieldBarFill.style.backgroundColor = '#00F'; // Blue
            } else {
                shieldBarFill.style.backgroundColor = '#800080'; // Purple
            }
        }

        // Function to update settings UI elements based on current values
        function updateSettingsDisplay() {
            mouseSensitivitySlider.value = mouseSensitivity;
            mouseSensitivityValueDisplay.textContent = mouseSensitivity.toFixed(4);

            volumeSlider.value = masterVolume;
            volumeValueDisplay.textContent = `${Math.floor(masterVolume * 100)}%`;

            // Update language button selection
            if (currentLanguage === 'id') {
                langIdButton.classList.add('selected');
                langEnButton.classList.remove('selected');
                langIdButton.style.backgroundColor = '#2563eb'; // Tailwind blue-600
                langEnButton.style.backgroundColor = '#4b5563'; // Tailwind gray-600
            } else {
                langIdButton.classList.remove('selected');
                langEnButton.classList.add('selected');
                langIdButton.style.backgroundColor = '#4b5563'; // Tailwind gray-600
                langEnButton.style.backgroundColor = '#2563eb'; // Tailwind blue-600
            }
        }

        // Function to change the game language
        function updateLanguage(lang) {
            currentLanguage = lang;
            updateLanguageDisplay();
            // Re-render weapon list to update language
            if (gameState === 'weaponSelect') {
                updateWeaponList();
            }
        }

        // --- Game Over / Message Box ---
        // This message box is now only for Game Over messages.
        function showMessageBox(message) {
            messageText.textContent = message;
            messageText.dataset.originalMessage = message; // Store original message for language changes
            messageBox.style.display = 'block';
            playerHud.style.display = 'none'; // Hide HUD when message box is shown
            menuToggleButton.style.display = 'none'; // Hide menu button
        }

        function hideMessageBox() {
            messageBox.style.display = 'none';
            // HUD and menu button visibility is now managed by hideAllScreens and then explicitly shown when gameState is 'playing'.
        }

        function endGame(message) {
            console.log("GAME OVER CALLED with message:", message);
            gameOver = true;
            gameState = 'gameOver';
            showMessageBox(message);
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }

        // --- Main Game Loop ---
        function animate(currentTime) {
            if (!lastFrameTime) {
                lastFrameTime = currentTime;
            }
            const deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            if (gameState !== 'playing') { // Only update game logic if playing
                renderer.render(scene, camera); // Still render the scene even if paused/menu
                requestAnimationFrame(animate); // Keep rendering the current state (menu/game over)
                return;
            }

            updatePlayer(deltaTime);
            updateBullets(deltaTime);
            spawnEnemy();
            updateEnemies(deltaTime);
            checkCollisions();

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        // --- Screen Management ---
        function hideAllScreens() {
            mainMenuScreen.style.display = 'none';
            weaponSelectScreen.style.display = 'none'; // Changed from characterSelectScreen
            settingsScreen.style.display = 'none';
            messageBox.style.display = 'none'; // Always hide message box when changing screens
            playerHud.style.display = 'none'; // Hide HUD by default
            menuToggleButton.style.display = 'none'; // Hide menu button by default
        }

        function showMainMenu() {
            hideAllScreens();
            mainMenuScreen.style.display = 'flex';
            gameState = 'menu';
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }

            // Adjust button visibility and text based on game state
            if (gameStartedAtLeastOnce && !gameOver) {
                mainMenuPrimaryButton.textContent = translations[currentLanguage].continueGame;
                restartGameButton.style.display = 'block'; // Show restart button
            } else {
                mainMenuPrimaryButton.textContent = translations[currentLanguage].startGame;
                restartGameButton.style.display = 'none'; // Hide restart button if not paused game
            }
            welcomeMessageText.textContent = translations[currentLanguage].welcomeMessage;
        }

        function showWeaponSelection() {
            hideAllScreens();
            weaponSelectScreen.style.display = 'flex';
            gameState = 'weaponSelect';
            updateWeaponList(); // Populate weapon list and load preview when screen is shown
        }

        function showSettings() {
            hideAllScreens();
            settingsScreen.style.display = 'flex';
            gameState = 'settings';
            updateSettingsDisplay(); // Update settings UI when shown
        }

        // --- Weapon Selection Logic ---
        function updateWeaponList() {
            weaponList.innerHTML = ''; // Clear previous list
            weapons.forEach(weapon => {
                const weaponDiv = document.createElement('div');
                weaponDiv.className = 'flex flex-col items-center p-4 bg-gray-800 rounded-lg shadow-md w-64';
                
                const weaponName = document.createElement('h2');
                weaponName.className = 'text-2xl font-bold text-white mb-2';
                weaponName.textContent = translations[currentLanguage].weaponNames[weapon.id]; // Use translated name
                weaponDiv.appendChild(weaponName);

                const damageText = document.createElement('p');
                damageText.className = 'text-lg text-gray-300';
                damageText.textContent = `${translations[currentLanguage].weaponDamage} ${weapon.damage}`;
                weaponDiv.appendChild(damageText);

                // Simple damage bar
                const damageBarContainer = document.createElement('div');
                damageBarContainer.className = 'w-full h-4 bg-gray-600 rounded-full mt-2 overflow-hidden';
                const damageBarFill = document.createElement('div');
                damageBarFill.className = 'h-full bg-red-500';
                // Scale damage bar relative to max possible damage (e.g., 50)
                damageBarFill.style.width = `${(weapon.damage / 50) * 100}%`; 
                damageBarContainer.appendChild(damageBarFill);
                weaponDiv.appendChild(damageBarContainer);

                const buyButton = document.createElement('button');
                buyButton.className = 'mt-4 px-4 py-2 rounded-md font-bold transition-colors';
                if (weapon.current) {
                    buyButton.textContent = translations[currentLanguage].currentWeapon;
                    buyButton.className += ' bg-green-600 text-white cursor-default';
                    buyButton.disabled = true;
                } else if (coins >= weapon.price) { // Changed from score
                    buyButton.textContent = `${translations[currentLanguage].buyButton} (${weapon.price})`;
                    buyButton.className += ' bg-blue-600 hover:bg-blue-700 text-white';
                    buyButton.onclick = () => buyWeapon(weapon);
                } else {
                    buyButton.textContent = `${translations[currentLanguage].buyButton} (${weapon.price})`;
                    buyButton.className += ' bg-gray-500 text-gray-300 cursor-not-allowed';
                    buyButton.disabled = true;
                }
                weaponDiv.appendChild(buyButton);
                weaponList.appendChild(weaponDiv);
            });

            // Load the model for the currently selected weapon into the preview
            const selectedWeapon = weapons.find(w => w.current);
            if (selectedWeapon && selectedWeapon.modelPath) {
                loadWeaponModelForPreview(selectedWeapon.modelPath);
            } else {
                // Clear preview if no model path or no weapon selected
                if (currentPreviewModel) {
                    weaponPreviewScene.remove(currentPreviewModel);
                    currentPreviewModel = null;
                }
                weaponPreviewHint.textContent = translations[currentLanguage].weaponPreviewNoModel;
                weaponPreviewHint.style.display = 'block'; // Show hint if no model
            }
        }

        function buyWeapon(weaponToBuy) {
            if (coins >= weaponToBuy.price) { // Changed from score
                coins -= weaponToBuy.price; // Changed from score
                currentWeapon.current = false; // Deselect old weapon
                weaponToBuy.current = true; // Select new weapon
                currentWeapon = weaponToBuy;
                BULLET_DAMAGE = currentWeapon.damage; // Update global damage based on new weapon's damage
                updateCoinsDisplay(); // Refresh weapon list display and preview
                updateWeaponList(); // Re-render weapon list to reflect changes
                loadInGameWeaponModel(currentWeapon.modelPath); // Load new in-game model
                console.log(`Weapon ${weaponToBuy.name} bought!`);
            } else {
                console.log("Not enough money to buy this weapon!");
            }
        }

        // --- Weapon Preview 3D Functions ---
        function initWeaponPreview3D() {
            const previewCanvas = document.getElementById('weaponPreviewCanvas');
            weaponPreviewScene = new THREE.Scene(); // Initialize scene here
            weaponPreviewCamera = new THREE.PerspectiveCamera(75, previewCanvas.clientWidth / previewCanvas.clientHeight, 0.1, 100);
            weaponPreviewRenderer = new THREE.WebGLRenderer({ canvas: previewCanvas, alpha: true, antialias: true }); // Initialize renderer here
            weaponPreviewRenderer.setSize(previewCanvas.clientWidth, previewCanvas.clientHeight);
            weaponPreviewRenderer.setPixelRatio(window.devicePixelRatio);

            // Lights for the preview scene
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Brighter ambient
            weaponPreviewScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            weaponPreviewScene.add(directionalLight);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight2.position.set(-5, -5, -5);
            weaponPreviewScene.add(directionalLight2);

            // Camera position for preview
            weaponPreviewCamera.position.z = 2;
            weaponPreviewCamera.position.y = 0.5;

            // Event listeners for preview rotation
            previewCanvas.addEventListener('mousedown', (e) => {
                isPreviewDragging = true;
                prevPreviewMouseX = e.clientX;
                prevPreviewMouseY = e.clientY;
                previewCanvas.style.cursor = 'grabbing';
            });
            previewCanvas.addEventListener('mousemove', (e) => {
                if (isPreviewDragging) {
                    const deltaX = e.clientX - prevPreviewMouseX;
                    const deltaY = e.clientY - prevPreviewMouseY;
                    previewRotationY += deltaX * previewRotationSpeed;
                    previewRotationX += deltaY * previewRotationSpeed;
                    // Limit vertical rotation to prevent flipping
                    previewRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, previewRotationX));
                    prevPreviewMouseX = e.clientX;
                    prevPreviewMouseY = e.clientY;
                }
            });
            previewCanvas.addEventListener('mouseup', () => {
                isPreviewDragging = false;
                previewCanvas.style.cursor = 'grab';
            });
            previewCanvas.addEventListener('mouseleave', () => {
                isPreviewDragging = false;
                previewCanvas.style.cursor = 'grab';
            });

            // Touch events for mobile
            previewCanvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isPreviewDragging = true;
                    prevPreviewMouseX = e.touches[0].clientX;
                    prevPreviewMouseY = e.touches[0].clientY;
                }
            }, { passive: false });
            previewCanvas.addEventListener('touchmove', (e) => {
                if (isPreviewDragging && e.touches.length === 1) {
                    e.preventDefault(); // Prevent scrolling
                    const deltaX = e.touches[0].clientX - prevPreviewMouseX;
                    const deltaY = e.touches[0].clientY - prevPreviewMouseY;
                    previewRotationY += deltaX * previewRotationSpeed;
                    previewRotationX += deltaY * previewRotationSpeed;
                    previewRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, previewRotationX));
                    prevPreviewMouseX = e.touches[0].clientX;
                    prevPreviewMouseY = e.touches[0].clientY;
                }
            }, { passive: false });
            previewCanvas.addEventListener('touchend', () => {
                isPreviewDragging = false;
            });
            previewCanvas.addEventListener('touchcancel', () => {
                isPreviewDragging = false;
            });

            // Initial cursor style
            previewCanvas.style.cursor = 'grab';

            animateWeaponPreview();
        }

        function animateWeaponPreview() {
            requestAnimationFrame(animateWeaponPreview);

            if (currentPreviewModel) {
                currentPreviewModel.rotation.y = previewRotationY;
                currentPreviewModel.rotation.x = previewRotationX;
            }
            weaponPreviewRenderer.render(weaponPreviewScene, weaponPreviewCamera);
        }

        function loadWeaponModelForPreview(weaponModelPath) {
            if (currentPreviewModel) {
                weaponPreviewScene.remove(currentPreviewModel);
                currentPreviewModel = null;
            }

            if (!weaponModelPath) {
                console.warn("No model path provided for weapon preview.");
                weaponPreviewHint.textContent = translations[currentLanguage].weaponPreviewNoModel;
                weaponPreviewHint.style.display = 'block'; // Show hint if no model
                return;
            }

            weaponPreviewHint.textContent = "Memuat model...";
            weaponPreviewHint.style.display = 'block'; // Show loading hint

            const fbxLoader = new THREE.FBXLoader();
            fbxLoader.load(weaponModelPath, (fbx) => {
                currentPreviewModel = fbx;
                // Adjust scale and position for preview
                currentPreviewModel.scale.set(0.01, 0.01, 0.01); // Example scale, adjust as needed
                currentPreviewModel.position.set(0, 0, 0); // Center the model
                currentPreviewModel.rotation.set(0, 0, 0); // Reset initial rotation

                currentPreviewModel.traverse((child) => {
                    if (child.isMesh) {
                        // Ensure materials are compatible with Phong (for lighting)
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.needsUpdate = true; // Ensure material updates
                                if (!mat.color) mat.color = new THREE.Color(0xAAAAAA); // Default color if none
                                child.material = new THREE.MeshPhongMaterial({ color: mat.color });
                            });
                        } else {
                            if (!child.material.color) child.material.color = new THREE.Color(0xAAAAAA); // Default color if none
                            child.material = new THREE.MeshPhongMaterial({ color: child.material.color });
                            child.material.needsUpdate = true; // Ensure material updates
                        }
                    }
                });

                weaponPreviewScene.add(currentPreviewModel);
                weaponPreviewHint.style.display = 'none'; // Hide hint once model is loaded
                previewRotationX = 0; // Reset rotation when new model is loaded
                previewRotationY = 0;
            }, undefined, (error) => {
                console.error("Error loading weapon preview FBX model:", error);
                weaponPreviewHint.textContent = translations[currentLanguage].weaponPreviewNoModel;
                weaponPreviewHint.style.display = 'block'; // Show error hint
            });
        }


        // --- Event Listeners ---
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                if (gameState === 'playing') {
                    // Pause game and show main menu
                    if (document.pointerLockElement) {
                        document.exitPointerLock(); // This will trigger pointerlockchange and set gameState to 'menu'
                    } else {
                        // Fallback if pointer lock somehow wasn't active
                        gameState = 'menu'; // Set to menu state directly
                        showMainMenu(); // Show main menu
                    }
                } else if (gameState === 'weaponSelect' || gameState === 'settings' || gameState === 'gameOver') {
                    // From sub-menu or game over, go to main menu
                    showMainMenu();
                } else if (gameState === 'menu' && gameStartedAtLeastOnce && !gameOver) {
                    // If in main menu (as a pause) and game has been started, resume game
                    resumeGame();
                }
            } else if (gameState === 'playing') { // Only process other keys if playing
                keys[e.key] = true;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (gameState === 'playing') {
                keys[e.key] = false;
            }
        });

        // --- Pointer Lock for Mouse Rotation ---
        const canvas3D = document.getElementById('gameCanvas3D');

        function requestPointerLock() {
            canvas3D.requestPointerLock = canvas3D.requestPointerLock || canvas3D.mozRequestPointerLock || canvas3D.webkitRequestPointerLock;
            if (canvas3D.requestPointerLock) {
                canvas3D.requestPointerLock().then(() => {
                    console.log("Pointer lock successful.");
                }).catch((e) => {
                    console.error("Pointer lock failed or exited:", e);
                });
            }
        }

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === canvas3D || document.mozPointerLockElement === canvas3D || document.webkitPointerLockElement === canvas3D;
            if (isPointerLocked) {
                console.log('Pointer locked');
                // If pointer lock is acquired, and we were in the menu (as a pause), transition to playing.
                if (gameState === 'menu' && gameStartedAtLeastOnce && !gameOver) { // If we were in menu as a pause
                    gameState = 'playing';
                    playerHud.style.display = 'flex';
                    menuToggleButton.style.display = 'block';
                }
            } else {
                console.log('Pointer unlocked');
                isMouseDown = false;
                isZoomed = false;
                updateCameraFOV(false);
                // If pointer is unlocked and game was playing (not game over), it means user exited pointer lock
                if (gameState === 'playing' && !gameOver) {
                    gameState = 'menu'; // Transition to menu state (as pause menu)
                    showMainMenu(); // Show main menu
                }
            }
        }, false);

        document.addEventListener('mozpointerlockchange', () => {
            isPointerLocked = document.mozPointerLockElement === canvas3D;
        }, false);

        document.addEventListener('webkitpointerlockchange', () => {
            isPointerLocked = document.webkitPointerLockElement === canvas3D;
        }, false);

        // Click on canvas to request pointer lock (only if playing and not locked)
        canvas3D.addEventListener('click', () => {
            if (gameState === 'playing' && !isPointerLocked) { 
                requestPointerLock();
            }
        });

        // --- Mouse Down (Left Click) for Shooting, Right Click for Zoom ---
        document.addEventListener('mousedown', (event) => {
            if (gameState === 'playing' && isPointerLocked) {
                if (event.button === 0) { // Left click
                    isMouseDown = true;
                    shootBullet();
                } else if (event.button === 2) { // Right click
                    event.preventDefault(); // Prevent context menu
                    isZoomed = true;
                    updateCameraFOV(true);
                }
            }
        });

        document.addEventListener('mouseup', (event) => {
            if (event.button === 0) {
                isMouseDown = false;
            } else if (event.button === 2) { // Right click release
                isZoomed = false;
                updateCameraFOV(false);
            }
        });

        // Function to handle bullet shooting logic
        function shootBullet() {
            const bulletMaterial = new THREE.MeshPhongMaterial({ color: BULLET_COLOR });
            const bulletMesh = new THREE.Mesh(BULLET_GEOMETRY, bulletMaterial);

            const bulletSpawnPoint = new THREE.Vector3();
            camera.getWorldPosition(bulletSpawnPoint);
            
            const bulletDirection = new THREE.Vector3();
            camera.getWorldDirection(bulletDirection);
            bulletDirection.normalize();

            bulletMesh.position.copy(bulletSpawnPoint);
            
            const tempQuaternion = new THREE.Quaternion();
            tempQuaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), bulletDirection);
            bulletMesh.setRotationFromQuaternion(tempQuaternion);

            scene.add(bulletMesh);
            bullets.push({ mesh: bulletMesh, direction: bulletDirection });
            playSound(playerShootSynth, "C4", "16n");
        }

        document.addEventListener('mousemove', (event) => {
            if (gameState === 'playing' && isPointerLocked) {
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                playerYawObject.rotation.y -= movementX * mouseSensitivity;
                camera.rotation.x -= movementY * mouseSensitivity;
                camera.rotation.x = Math.max(-pitchLimit, Math.min(pitchLimit, camera.rotation.x));
            }
        });

        // Prevent context menu on right-click
        canvas3D.addEventListener('contextmenu', (e) => e.preventDefault());

        // --- Mobile Touch Drag for Rotation ---
        canvas3D.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1 && gameState === 'playing' && e.target === canvas3D) {
                isTouchDragging = true;
                previousTouchX = e.touches[0].clientX;
                previousTouchY = e.touches[0].clientY;
            }
        }, { passive: false });

        canvas3D.addEventListener('touchmove', (e) => {
            if (isTouchDragging && e.touches.length === 1 && e.target === canvas3D) {
                e.preventDefault();
                const currentTouchX = e.touches[0].clientX;
                const currentTouchY = e.touches[0].clientY;

                const deltaX = currentTouchX - previousTouchX;
                const deltaY = currentTouchY - previousTouchY;

                if (Math.abs(deltaX) > touchDragThreshold || Math.abs(deltaY) > touchDragThreshold) {
                    playerYawObject.rotation.y -= deltaX * touchSensitivity;
                    camera.rotation.x -= deltaY * touchSensitivity;
                    camera.rotation.x = Math.max(-pitchLimit, Math.min(pitchLimit, camera.rotation.x));
                }

                previousTouchX = currentTouchX;
                previousTouchY = currentTouchY;
            }
        }, { passive: false });

        canvas3D.addEventListener('touchend', () => {
            isTouchDragging = false;
        });
        canvas3D.addEventListener('touchcancel', () => {
            isTouchDragging = false; // Also reset preview dragging on touch cancel
        });


        // --- Mobile Controls for Movement (Buttons) ---
        leftButton.addEventListener('touchstart', () => { touchMoveLeft = true; }, { passive: true });
        leftButton.addEventListener('touchend', () => { touchMoveLeft = false; });
        leftButton.addEventListener('touchcancel', () => { touchMoveLeft = false; });

        rightButton.addEventListener('touchstart', () => { touchMoveRight = true; }, { passive: true });
        rightButton.addEventListener('touchend', () => { touchMoveRight = false; });
        rightButton.addEventListener('touchcancel', () => { touchMoveRight = false; });

        forwardButton.addEventListener('touchstart', () => { touchMoveForward = true; }, { passive: true });
        forwardButton.addEventListener('touchend', () => { touchMoveForward = false; });
        forwardButton.addEventListener('touchcancel', () => { touchMoveForward = false; });

        backwardButton.addEventListener('touchstart', () => { touchMoveBackward = true; }, { passive: true });
        backwardButton.addEventListener('touchend', () => { touchMoveBackward = false; });
        backwardButton.addEventListener('touchcancel', () => { touchMoveBackward = false; });

        shootButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === 'playing') {
                shootBullet();
            }
        }, { passive: false });

        restartButton.addEventListener('click', startGame); // This button is only in messageBox (Game Over), always restarts.

        // Menu button listeners
        mainMenuPrimaryButton.addEventListener('click', () => {
            if (gameStartedAtLeastOnce && !gameOver) {
                resumeGame();
            } else {
                startGame();
            }
        });
        restartGameButton.addEventListener('click', startGame); // This always triggers a full restart
        weaponSelectButton.addEventListener('click', showWeaponSelection); // Renamed
        settingsButton.addEventListener('click', showSettings);
        backToMainMenuFromWeaponButton.addEventListener('click', showMainMenu); // New listener
        backToMainMenuFromSettingsButton.addEventListener('click', showMainMenu);

        menuToggleButton.addEventListener('click', () => {
            if (gameState === 'playing') {
                // Pause game and show main menu
                if (document.pointerLockElement) {
                    document.exitPointerLock(); // This will trigger pointerlockchange and set gameState to 'menu'
                } else {
                    // Fallback if pointer lock somehow wasn't active
                    gameState = 'menu'; // Set to menu state directly
                    showMainMenu(); // Show main menu
                }
            } else if (gameState === 'menu' && gameStartedAtLeastOnce && !gameOver) {
                // If in main menu (as a pause) and game has been started, resume game
                resumeGame();
            }
        });

        // Settings control listeners
        mouseSensitivitySlider.addEventListener('input', (e) => {
            mouseSensitivity = parseFloat(e.target.value);
            updateSettingsDisplay(); // Update display immediately
        });

        volumeSlider.addEventListener('input', (e) => {
            masterVolume = parseFloat(e.target.value);
            Tone.Destination.volume.value = (masterVolume * 40) - 40; // Map 0-1 to -40dB to 0dB
            updateSettingsDisplay(); // Update display immediately
        });

        langIdButton.addEventListener('click', () => updateLanguage('id'));
        langEnButton.addEventListener('click', () => updateLanguage('en'));


        // Handle window resize
        function resizeRenderer() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            if (renderer) { // Check if renderer is defined
                renderer.setSize(width, height);
            }
            if (camera) { // Check if camera is defined
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }
            // Resize preview canvas as well
            if (weaponPreviewCanvas && weaponPreviewRenderer && weaponPreviewCamera) { // Check all preview related objects
                weaponPreviewRenderer.setSize(weaponPreviewCanvas.clientWidth, weaponPreviewCanvas.clientHeight);
                weaponPreviewCamera.aspect = weaponPreviewCanvas.clientWidth / weaponPreviewCanvas.clientHeight;
                weaponPreviewCamera.updateProjectionMatrix();
            }
        }

        window.addEventListener('resize', resizeRenderer);

        // Update camera FOV for zoom
        function updateCameraFOV(zoomed) {
            if (camera) {
                camera.fov = zoomed ? ZOOM_FOV : ORIGINAL_FOV;
                camera.updateProjectionMatrix();
            }
        }

        // Function to update all displayed text based on current language
        function updateLanguageDisplay() {
            const t = translations[currentLanguage];

            // Update main menu
            mainMenuTitle.textContent = t.gameTitle;
            welcomeMessageText.textContent = t.welcomeMessage; // Set welcome message
            // Buttons are handled dynamically by showMainMenu, but their text needs updating
            mainMenuPrimaryButton.textContent = (gameStartedAtLeastOnce && !gameOver) ? t.continueGame : t.startGame;
            restartGameButton.textContent = t.restartGame;
            weaponSelectButton.textContent = t.selectWeapon;
            settingsButton.textContent = t.settings;

            // Update weapon select screen
            weaponSelectTitle.textContent = t.weaponSelectTitle;
            backToMainMenuFromWeaponButton.textContent = t.backToMainMenu;
            // Update weapon preview hint - now always hidden
            weaponPreviewHint.style.display = 'none';


            // Update settings screen
            settingsScreen.querySelector('h1').textContent = t.settingsTitle;
            settingsScreen.querySelector('p').textContent = t.settingsPlaceholder;
            document.getElementById('mouseSensitivityLabel').textContent = t.mouseSensitivityLabel;
            document.getElementById('volumeLabel').textContent = t.volumeLabel;
            document.getElementById('languageLabel').textContent = t.languageLabel;
            backToMainMenuFromSettingsButton.textContent = t.backToMainMenu;

            // Update HUD
            coinsDisplay.textContent = `${t.coins} ${coins}`; // Changed from score
            healthLabel.textContent = `${t.health} ${Math.max(0, Math.floor(playerHealth))}`;
            shieldLabel.textContent = `${t.shield} ${Math.max(0, Math.floor(playerShield))}`;

            // Update message box (only for Game Over)
            restartButton.textContent = t.restartButton;
            if (messageBox.style.display === 'block' && messageText.dataset.originalMessage) {
                if (messageText.dataset.originalMessage.includes("GAME OVER!")) {
                    messageText.textContent = t.gameOverMessage;
                }
            }

            // Update mobile shoot button
            shootButton.innerHTML = `<i class="fas fa-crosshairs"></i> ${t.shootButton}`;

            // Update settings display to reflect language button selection
            updateSettingsDisplay();
        }


        // Initial setup on window load
        window.onload = function() {
            initThreeJS();
            initWeaponPreview3D(); // Initialize weapon preview scene
            // Set initial volume for Tone.js
            Tone.Destination.volume.value = (masterVolume * 40) - 40;
            // Start with main menu visible
            showMainMenu();
            // Initial display updates based on default language
            updateLanguageDisplay();
            updateHealthShieldDisplay(); // Ensure health/shield bars are initialized
            updateSettingsDisplay(); // Ensure settings UI reflects initial values

            // Set initial bullet damage based on default weapon (pistol)
            BULLET_DAMAGE = currentWeapon.damage;

            // Start the animation loop, but game logic will only run when gameState is 'playing'
            animate();
        };

    </script>
</body>
</html>

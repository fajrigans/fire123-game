<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!--
      Tag Title Utama untuk tab browser
    -->
    <title>fire123-game: FPS Web Game</title>

    <!--
      Meta Description untuk deskripsi di hasil pencarian Google
    -->
    <meta name="description" content="Mainkan Fire123, game tembak-tembakan FPS sederhana berbasis web dengan grafis 3D dan kontrol responsif. Targetkan musuh dan raih skor tertinggi!" />
    
    <!--
      Keywords (opsional, tapi bisa membantu)
    -->
    <meta name="keywords" content="FPS game, web game, three.js game, fire123, shooting game, game tembak-tembakan, game online gratis, 3D game, WebGL" />
    
    <!--
      Penulis/Kredit (opsional)
    -->
    <meta name="author" content="Tim Pengembang Game Fire123" />

    <!--
      Open Graph Meta Tags untuk Facebook, LinkedIn, WhatsApp, dll.
      Ini membuat tautan Anda terlihat bagus saat dibagikan.
    -->
    <meta property="og:type" content="game.website" />
    <meta property="og:url" content="https://fire123-game.vercel.app/" />
    <meta property="og:title" content="fire123-game: Game Tembak-tembakan FPS Web 3D" />
    <meta property="og:description" content="Mainkan Fire123, game tembak-tembakan FPS sederhana berbasis web dengan grafis 3D dan kontrol responsif. Targetkan musuh dan raih skor tertinggi!" />
    <meta property="og:image" content="https://placehold.co/1200x630/000/FFF?text=Fire123%20Game%20Preview" /> 
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <!--
      Twitter Card Meta Tags untuk pratinjau di Twitter
    -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://fire123-game.vercel.app/" />
    <meta property="twitter:title" content="fire123-game: Game Tembak-tembakan FPS Web 3D" />
    <meta property="twitter:description" content="Mainkan Fire123, game tembak-tembakan FPS sederhana berbasis web dengan grafis 3D dan kontrol responsif. Targetkan musuh dan raih skor tertinggi!" />
    <meta property="twitter:image" content="https://placehold.co/1200x630/000/FFF?text=Fire123%20Game%20Preview" /> 
    <meta property="twitter:creator" content="@yourtwitterhandle" /> 
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.1/umd/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Latar belakang gelap */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Mencegah scrolling */
            position: relative; /* Untuk posisi kotak pesan */
            width: 100vw;
            height: 100vh;
        }
        #gameCanvas3D {
            background-color: #000; /* Latar belakang game */
            display: block;
            touch-action: none; /* Nonaktifkan tindakan sentuh default seperti scrolling/zooming */
            width: 100%;
            height: 100%;
            border-radius: 0; /* Hapus border-radius untuk layar penuh */
            box-shadow: none; /* Hapus bayangan untuk layar penuh */
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 0; /* Hapus padding untuk konten edge-to-edge */
            margin: 0; /* Hapus margin */
            overflow: hidden; /* Pastikan konten tidak meluap */
            position: relative; /* Untuk crosshair */
            width: 100vw;
            height: 100vh;
            max-width: 100vw; /* Pastikan mengambil lebar penuh */
            background-color: #2d3748; /* Latar belakang kontainer lebih gelap */
        }
        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            color: #e2e8f0;
            font-weight: bold;
            z-index: 10; /* Di atas kanvas */
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 220px; /* Menyesuaikan untuk HUD di kanan atas */
            padding: 0 1rem;
            font-size: 1.8rem; /* Ukuran font lebih besar */
            text-shadow: 0 0 8px #0ff, 0 0 12px #0ff; /* Cahaya neon untuk teks */
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            border: 2px solid #0ff;
            box-shadow: 0 0 20px #0ff;
            z-index: 1000;
            display: none; /* Tersembunyi secara default */
        }
        .message-box button {
            margin-top: 1rem;
            padding: 0.75rem 1.5rem;
            background-color: #0ff;
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: bold;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 10px #0ff;
        }
        .message-box button:hover {
            background-color: #0cc;
            transform: scale(1.05);
        }

        /* Kontrol Mobile */
        .mobile-controls {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 1rem;
            gap: 0.5rem;
            z-index: 10; /* Di atas kanvas */
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            right: 1rem;
            padding: 0 1rem;
        }
        .mobile-controls button {
            flex: 1;
            padding: 1rem;
            background-color: #4a5568;
            color: #e2e8f0;
            border: none;
            border-radius: 8px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        .mobile-controls button:active {
            background-color: #0ff;
            color: #000;
            transform: scale(0.95);
        }
        .mobile-controls .left-right-buttons {
            display: flex;
            gap: 0.5rem;
            flex: 2;
        }
        .mobile-controls .shoot-button {
            flex: 1;
        }

        @media (min-width: 768px) {
            .mobile-controls {
                display: none; /* Sembunyikan di desktop */
            }
        }

        /* Crosshair */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 1px solid #0ff;
            border-radius: 50%;
            box-shadow: 0 0 5px #0ff;
            pointer-events: none; /* Memungkinkan klik melewati */
            z-index: 5;
        }
        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background-color: #0ff;
        }
        .crosshair::before {
            width: 2px;
            height: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .crosshair::after {
            width: 10px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Main Menu Styles */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #e2e8f0;
            z-index: 2000;
        }
        .menu-screen h1 {
            font-size: 4rem;
            margin-bottom: 2rem;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
        }
        .menu-screen button {
            padding: 1rem 2.5rem;
            margin: 0.75rem 0;
            background-color: #0ff;
            color: #000;
            border: none;
            border-radius: 12px;
            font-size: 1.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            box-shadow: 0 0 15px #0ff;
        }
        .menu-screen button:hover {
            background-color: #0cc;
            transform: scale(1.05);
            box-shadow: 0 0 25px #0cc;
        }

        /* Player HUD Bars */
        .player-hud {
            position: absolute;
            top: 1rem; /* Changed from bottom */
            right: 1rem; /* Changed from left */
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            width: 200px; /* Lebar default untuk desktop */
        }
        .health-bar, .shield-bar {
            width: 100%;
            height: 25px;
            background-color: #333;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #e2e8f0;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            position: relative;
        }
        .health-bar-fill, .shield-bar-fill {
            height: 100%;
            width: 100%; /* Default to full */
            transition: width 0.2s ease-out, background-color 0.2s ease-out;
            border-radius: 6px;
            position: absolute;
            top: 0;
            left: 0;
        }
        .health-bar-fill {
            background-color: #0F0; /* Green */
        }
        .shield-bar-fill {
            background-color: #00F; /* Blue */
        }
        .bar-label {
            position: absolute;
            width: 100%;
            text-align: center;
            color: #fff;
            font-weight: bold;
            line-height: 25px; /* Vertically center text */
            text-shadow: 0 0 5px #000;
            font-size: 0.9rem;
        }

        /* Responsive adjustments for HUD */
        @media (max-width: 767px) {
            .player-hud {
                width: 150px; /* Lebih kecil di mobile */
                top: 0.5rem; /* Changed from bottom */
                right: 0.5rem; /* Changed from left */
            }
            .health-bar, .shield-bar {
                height: 20px;
            }
            .bar-label {
                font-size: 0.8rem;
                line-height: 20px;
            }
            .game-info {
                font-size: 1.2rem;
                top: 0.5rem;
                left: 0.5rem;
                right: calc(0.5rem + 150px + 0.5rem); /* Adjusted for mobile HUD width */
            }
        }

        /* Settings Screen Specific Styles */
        .settings-group {
            width: 80%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-bottom: 1rem;
        }
        .settings-group label {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            color: #a0aec0;
        }
        .settings-group input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #4a5568;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 4px;
        }
        .settings-group input[type="range"]:hover {
            opacity: 1;
        }
        .settings-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0ff;
            cursor: pointer;
            box-shadow: 0 0 10px #0ff;
        }
        .settings-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0ff;
            cursor: pointer;
            box-shadow: 0 0 10px #0ff;
        }
        .settings-group span.text-sm {
            align-self: flex-end;
            margin-top: 0.25rem;
            color: #cbd5e0;
        }
        .settings-group button {
            padding: 0.5rem 1rem;
            font-size: 1rem;
            margin: 0; /* Override default menu button margin */
        }
        .settings-group button.selected {
            background-color: #0cc;
            box-shadow: 0 0 15px #0cc;
        }

        /* Weapon Selection Screen Styles (NEW) */
        #weaponSelectScreen.menu-screen {
            background-color: #1a1a2e; /* Darker background for weapon select */
            justify-content: flex-start; /* Align items to start */
            padding-top: 2rem; /* Add some top padding */
        }
        #weaponSelectScreen h1 {
            margin-bottom: 1rem;
        }
        #weaponSelectScreen #container {
            width: 80%;
            max-width: 600px;
            height: 60vh; /* Make 3D view larger */
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            position: relative;
            margin-bottom: 2rem;
        }
        #weaponSelectScreen #container canvas {
            border-radius: 12px; /* Apply rounded corners to the canvas itself */
        }
        #weaponSelectScreen #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
            z-index: 1000;
            border-radius: 12px; /* Match container border-radius */
        }
        #weaponSelectScreen #loading-spinner {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 2s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #weaponSelectScreen .control-button {
            background-color: #2563eb; /* Tailwind blue-600 */
            color: white;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px; /* rounded-full */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease-in-out;
        }
        #weaponSelectScreen .control-button:hover {
            background-color: #1d4ed8; /* Tailwind blue-700 */
            transform: scale(1.05);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2);
        }
        #weaponSelectScreen .control-button:disabled {
            background-color: #6b7280; /* Tailwind gray-500 */
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #weaponSelectScreen .arrow-button {
            background-color: #4b5563; /* Tailwind gray-700 */
            color: white;
            font-weight: bold;
            padding: 0.5rem 1rem;
            border-radius: 9999px; /* rounded-full */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease-in-out;
            font-size: 1.25rem;
        }
        #weaponSelectScreen .arrow-button:hover {
            background-color: #374151; /* Tailwind gray-600 */
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        #weaponSelectScreen #damage-bar-container {
            position: relative; /* Changed from absolute */
            top: auto; /* Reset top */
            left: auto; /* Reset left */
            transform: none; /* Reset transform */
            width: 80%;
            max-width: 300px;
            background-color: #333;
            border: 2px solid #555;
            border-radius: 10px;
            overflow: hidden;
            height: 30px;
            display: flex;
            align-items: center;
            z-index: 50;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            margin-bottom: 1rem; /* Add margin below bar */
        }
        #weaponSelectScreen #damage-fill {
            height: 100%;
            background-color: #ef4444; /* Red for damage */
            width: 0%;
            transition: width 0.5s ease-in-out;
        }
        #weaponSelectScreen #damage-text {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 1.1rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }
        #weaponSelectScreen .weapon-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            space-x-4;
            z-index: 50;
            margin-top: 1rem; /* Space between damage bar and buttons */
        }
        #weaponSelectScreen #weaponPriceDisplay { /* NEW STYLE FOR PRICE */
            color: #e2e8f0;
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 0.5rem; /* Space between price and button */
            text-align: center;
            width: 100%;
            max-width: 300px;
        }
    </style>
</head>
<body> 
    <h1>Daftar Game dari RSS Feed</h1>
  <ul id="game-list"></ul>

  <script>
    const rssFeedUrl = "https://feeds.gamepix.com/v2/json?sid=R8149&pagination=12&page=1";

    fetch(rssFeedUrl)
      .then(response => response.json())
      .then(data => {
        const gameList = document.getElementById('game-list');
        data.items.forEach(game => {
          const li = document.createElement('li');
          li.innerHTML = `
            <strong>${game.title}</strong><br/>
            Kategori: ${game.category}<br/>
            <img src="${game.banner_image}" alt="${game.title}" width="200"/><br/>
            <a href="${game.url}" target="_blank">Mainkan Game</a>
          `;
          gameList.appendChild(li);
        });
      })
      .catch(error => {
        console.error('Error fetching RSS Feed:', error);
      });
  </script>
    <div class="game-container">
        <div class="game-info">
            <div id="coins">Koin: 0</div>
            </div>
        <button id="menuToggleButton" class="absolute top-4 right-4 z-50 p-3 bg-gray-700 text-white rounded-full shadow-lg hover:bg-gray-600 transition-colors">
            <i class="fas fa-bars text-xl"></i>
        </button>
        <div class="crosshair"></div>
        <canvas id="gameCanvas3D"></canvas>

        <div class="mobile-controls">
            <div class="left-right-buttons">
                <button id="leftButton" class="rounded-lg"><i class="fas fa-arrow-left"></i></button>
                <button id="rightButton" class="rounded-lg"><i class="fas fa-arrow-right"></i></button>
            </div>
            <button id="forwardButton" class="rounded-lg"><i class="fas fa-arrow-up"></i></button>
            <button id="backwardButton" class="rounded-lg"><i class="fas fa-arrow-down"></i></button>
            <button id="shootButton" class="shoot-button rounded-lg"><i class="fas fa-crosshairs"></i> Tembak</button>
        </div>

        <div class="player-hud">
            <div class="health-bar">
                <div id="healthBarFill" class="health-bar-fill"></div>
                <span class="bar-label" id="healthLabel">Kesehatan: 100</span>
            </div>
            <div class="shield-bar">
                <div id="shieldBarFill" class="shield-bar-fill"></div>
                <span class="bar-label" id="shieldLabel">Perisai: 50</span>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="restartButton">Mulai Ulang</button>
    </div>

    <div id="mainMenuScreen" class="menu-screen">
        <h1 id="mainMenuTitle">fire123-game</h1>
        <p id="welcomeMessageText" class="text-xl text-center mb-4 px-4"></p>
        <button id="mainMenuPrimaryButton">Mulai Game</button> 
        <button id="restartGameButton" style="display: none;">Mulai Ulang</button> 
        <button id="weaponSelectButton">Pilih Senjata</button> 
        <button id="settingsButton">Pengaturan</button>
    </div>

    <div id="weaponSelectScreen" class="menu-screen" style="display: none;">
        <h1 id="weaponSelectTitle">Pilih Senjata</h1>
        <div id="loading-overlay" class="rounded-lg">
            <div id="loading-spinner"></div>
            <p>Memuat model 3D...</p>
        </div>

        <div id="damage-bar-container" class="rounded-full">
            <div id="damage-fill" class="rounded-full"></div>
            <div id="damage-text"></div>
        </div>

        <div id="container" class="relative"></div>

        <div class="weapon-controls">
            <button id="prevWeaponBtn" class="arrow-button">
                &lt;
            </button>
            <div class="flex flex-col items-center"> <div id="weaponPriceDisplay"></div> <button id="buyWeaponBtn" class="control-button">
                    Beli Senjata Ini
                </button>
            </div>
            <button id="nextWeaponBtn" class="arrow-button">
                &gt;
            </button>
        </div>
        <button id="backToMainMenuFromWeapon">Kembali ke Menu Utama</button>
    </div>

    <div id="settingsScreen" class="menu-screen" style="display: none;">
        <h1>Pengaturan</h1>
        <p>Atur opsi game di sini.</p>
        <div class="settings-group">
            <label for="mouseSensitivitySlider" id="mouseSensitivityLabel">Sensitivitas Mouse:</label>
            <input type="range" id="mouseSensitivitySlider" min="0.0005" max="0.005" step="0.0001" value="0.0015" class="w-full">
            <span id="mouseSensitivityValue" class="text-sm">0.0015</span>
        </div>
        <div class="settings-group mt-4">
            <label for="volumeSlider" id="volumeLabel">Volume:</label>
            <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.5" class="w-full">
            <span id="volumeValue" class="text-sm">50%</span>
        </div>
        <div class="settings-group mt-4">
            <label id="languageLabel">Bahasa:</label>
            <div class="flex gap-2 mt-2">
                <button id="langIdButton" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md text-base">Indonesia</button>
                <button id="langEnButton" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-md text-base">English</button>
            </div>
        </div>
        <button id="backToMainMenuFromSettings" class="mt-8">Kembali ke Menu Utama</button>
    </div>

    <script>
        // Get info elements
        const coinsDisplay = document.getElementById('coins'); // Changed from score

        // Get message box elements
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton'); // This is for Game Over screen

        // Get main menu elements
        const mainMenuScreen = document.getElementById('mainMenuScreen');
        const mainMenuTitle = document.getElementById('mainMenuTitle');
        const welcomeMessageText = document.getElementById('welcomeMessageText');
        const mainMenuPrimaryButton = document.getElementById('mainMenuPrimaryButton');
        const restartGameButton = document.getElementById('restartGameButton'); // This is for pause menu restart
        const weaponSelectButton = document.getElementById('weaponSelectButton'); // Renamed
        const settingsButton = document.getElementById('settingsButton');

        // Get weapon select elements (NEW)
        const weaponSelectScreen = document.getElementById('weaponSelectScreen');
        const weaponSelectTitle = document.getElementById('weaponSelectTitle');
        const backToMainMenuFromWeaponButton = document.getElementById('backToMainMenuFromWeapon');
        
        // NEW 3D PREVIEW ELEMENTS
        const loadingOverlay = document.getElementById('loading-overlay');
        const damageFill = document.getElementById('damage-fill');
        const damageText = document.getElementById('damage-text');
        const buyWeaponBtn = document.getElementById('buyWeaponBtn');
        const prevWeaponBtn = document.getElementById('prevWeaponBtn');
        const nextWeaponBtn = document.getElementById('nextWeaponBtn');
        const weaponPreviewContainer = document.getElementById('container'); // Renamed from weaponPreviewContainer
        const weaponPriceDisplay = document.getElementById('weaponPriceDisplay'); // NEW: Price display element

        // Get settings elements
        const settingsScreen = document.getElementById('settingsScreen');
        const backToMainMenuFromSettingsButton = document.getElementById('backToMainMenuFromSettings');
        const mouseSensitivitySlider = document.getElementById('mouseSensitivitySlider');
        const mouseSensitivityValueDisplay = document.getElementById('mouseSensitivityValue');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValueDisplay = document.getElementById('volumeValue');
        const langIdButton = document.getElementById('langIdButton');
        const langEnButton = document.getElementById('langEnButton');

        // Get mobile controls
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const forwardButton = document.getElementById('forwardButton');
        const backwardButton = document.getElementById('backwardButton');
        const shootButton = document.getElementById('shootButton');

        // Get player HUD elements
        const healthBarFill = document.getElementById('healthBarFill');
        const healthLabel = document.getElementById('healthLabel');
        const shieldBarFill = document.getElementById('shieldBarFill');
        const shieldLabel = document.getElementById('shieldLabel');
        const playerHud = document.querySelector('.player-hud');

        // Get menu toggle button
        const menuToggleButton = document.getElementById('menuToggleButton');

        // Three.js variables
        let scene, camera, renderer;
        let playerYawObject; // Object to handle horizontal rotation (yaw)
        let playerCapsule; // Invisible mesh for player collision and position (child of playerYawObject)
        let bullets = []; // Array of { mesh, velocity }
        let enemies = []; // Array of { mesh, speed }
        let obstacles = []; // Array of obstacle meshes
        let playerGunModel; // Variable to hold the gun model (FBX)
        let playerModel; // Variable to hold the player model (FBX)

        // Game variables
        let coins = 0; // Changed from score
        let playerHealth = 100;
        let playerMaxHealth = 100;
        let playerShield = 50;
        let playerMaxShield = 50;
        let gameOver = false;
        // 'menu': main menu, can be initial or pause state
        // 'playing': game is active
        // 'gameOver': game has ended
        // 'weaponSelect': weapon selection screen
        // 'settings': settings screen
        let gameState = 'menu'; 
        let gameStartedAtLeastOnce = false; // Flag to track if game has been started from main menu

        // Timing variables for frame-rate independence
        let lastFrameTime = 0;

        // Debugging flag - SET THIS TO TRUE TO SEE COLLISION BOXES
        const DEBUG_COLLISIONS = false; // Dimatikan untuk tampilan yang lebih bersih

        // Player properties (in Three.js units)
        const PLAYER_HEIGHT_OFFSET = 0.5; // How high the camera is from the ground
        const PLAYER_RADIUS = 0.3; // For simple cylindrical collision
        const PLAYER_BASE_SPEED = 2.0; // Adjusted to be slower, similar to Valorant's walking speed
        const PLAYER_COLOR = 0x00FFFF; // Cyan (not visible, but for conceptual player body)

        // Bullet properties (in Three.js units)
        const BULLET_WIDTH = 0.05;
        const BULLET_HEIGHT = 0.8;
        const BULLET_SPEED = 15; // Speed units per second (will be multiplied by deltaTime)
        const BULLET_COLOR = 0xFF00FF; // Magenta
        let BULLET_DAMAGE = 10; // This will change based on selected weapon
        const ZOOMED_BULLET_DAMAGE_MULTIPLIER = 2.5; // Zoomed damage is this much more than base weapon damage

        // Pre-rotated bullet geometry (length along Z-axis)
        const BULLET_GEOMETRY = new THREE.CylinderGeometry(BULLET_WIDTH, BULLET_WIDTH, BULLET_HEIGHT, 8).rotateX(Math.PI / 2);

        // Enemy properties (in Three.js units)
        const ENEMY_SIZE = 0.7; // Base size for enemy scaling
        const ENEMY_BODY_HEIGHT = 0.8;
        const ENEMY_HEAD_RADIUS = 0.2;
        const ENEMY_ARM_LENGTH = 0.5;
        const ENEMY_LEG_LENGTH = 0.5;
        const ENEMY_SPEED_MIN = 0.5; // Speed units per second
        const ENEMY_SPEED_MAX = 1.5; // Speed units per second
        const ENEMY_COLOR = 0xFF0000; // Red
        const ENEMY_SPAWN_INTERVAL = 1500; // milliseconds (diperpanjang untuk debugging)
        let lastEnemySpawnTime = 0; // Akan diinisialisasi dengan Date.now() saat game dimulai
        const ENEMY_DAMAGE_TO_PLAYER = 20; // Damage an enemy deals to player on collision

        // Game world dimensions (in Three.js units)
        const WORLD_SCALE_FACTOR = 3.5; // New scale factor for the map
        const ORIGINAL_WORLD_WIDTH = 10;
        const ORIGINAL_WORLD_DEPTH = 15;
        const WORLD_WIDTH = ORIGINAL_WORLD_WIDTH * WORLD_SCALE_FACTOR;
        const WORLD_DEPTH = ORIGINAL_WORLD_DEPTH * WORLD_SCALE_FACTOR;
        const WORLD_HEIGHT = 5;

        // FOV for zoom
        const ORIGINAL_FOV = 75;
        const ZOOM_FACTOR = 1.5;
        const ZOOM_FOV = ORIGINAL_FOV / ZOOM_FACTOR;
        let isZoomed = false;

        // Epsilon for collision push-out
        const EPSILON = 0.01;

        // Keyboard input
        const keys = {};
        let isMouseDown = false; // Flag for mouse button state

        // Touch input for movement (simplified for FPS)
        let touchMoveForward = false;
        let touchMoveBackward = false;
        let touchMoveLeft = false;
        let touchMoveRight = false;

        // Camera rotation variables
        let isPointerLocked = false;
        // mouseSensitivity is now a global variable controlled by settings
        let mouseSensitivity = 0.0015; // Default value, can be changed in settings
        const pitchLimit = Math.PI / 2 - 0.1; // Limit vertical look (e.g., 80 degrees up/down)
        let isTouchDragging = false;
        let previousTouchX = 0;
        let previousTouchY = 0;
        const touchSensitivity = 0.003; // Adjusted for touch rotation
        const touchDragThreshold = 5; // Minimum pixel movement to register as a drag for rotation

        // Sound effects using Tone.js
        const playerShootSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: {
                attack: 0.001,
                decay: 0.1,
                sustain: 0.05,
                release: 0.1
            }
        }).toDestination();

        const enemyExplodeSynth = new Tone.NoiseSynth({
            noise: { type: "white" },
            envelope: {
                attack: 0.001,
                decay: 0.2,
                sustain: 0.01,
                release: 0.3
            }
        }).toDestination();

        const playerHitSynth = new Tone.Synth({
            oscillator: { type: "triangle" },
            envelope: {
                attack: 0.001,
                decay: 0.2,
                sustain: 0.1,
                release: 0.5
            }
        }).toDestination();

        // masterVolume is now a global variable controlled by settings
        let masterVolume = 0.5; // Default volume (0.0 to 1.0)
        let currentLanguage = 'id'; // 'id' for Indonesian, 'en' for English

        // Weapon data (Combined and adapted from provided code)
        // Note: The 'name' property here is for internal use/translation key.
        // The display name will come from translations[currentLanguage].weaponNames.
        const allWeaponsData = [
            { id: 'pistol', name: 'Pistol', damage: 15, price: 0, modelPath: 'https://raw.githubusercontent.com/fajrigans/assetgametembak/main/ImageToStl.com_buatkan_senjata_temba_0531174819_texture_fbx.fbx' },
            { id: 'ar15', name: 'AR-15 Style Rifle', damage: 20, price: 1500, modelPath: 'https://raw.githubusercontent.com/fajrigans/assetgametembak/main/ImageToStl.com_buatkan_senjata_temba_0531124219_texture_fbx.fbx' }
        ];
        let weapons = []; // This will store the game's weapon state (owned, current)
        let currentWeapon; // Will be set after loading weapons

        // Weapon Preview 3D variables (renamed for clarity)
        let previewScene, previewCamera, previewRenderer, previewControls;
        let currentPreviewModel = null;
        let currentWeaponIndex = 0; // Index for weaponModels array

        const translations = {
            'id': {
                'gameTitle': 'fire123-game',
                'startGame': 'Mulai Game',
                'continueGame': 'Lanjutkan', // New
                'restartGame': 'Mulai Ulang', // New
                'selectWeapon': 'Pilih Senjata', // Changed from characterSelect
                'settings': 'Pengaturan',
                'backToMainMenu': 'Kembali ke Menu Utama',
                'weaponSelectTitle': 'Pilih Senjata',
                'weaponDamage': 'Kerusakan:', // New
                'buyButton': 'Beli Senjata Ini', // New
                'equipButton': 'Pilih', // New
                'currentWeapon': 'Terpilih', // New
                'ownedButton': 'Miliki', // NEW TRANSLATION
                'settingsTitle': 'Pengaturan',
                'settingsPlaceholder': 'Atur opsi game di sini.',
                'mouseSensitivityLabel': 'Sensitivitas Mouse:',
                'volumeLabel': 'Volume:',
                'languageLabel': 'Bahasa:',
                'coins': 'Koin:', // Changed from score
                'health': 'Kesehatan:',
                'shield': 'Perisai:',
                'gameOverMessage': 'GAME OVER! Musuh menabrak Anda.',
                'restartButton': 'Mulai Ulang', // For game over screen
                'welcomeMessage': "Selamat datang! Gunakan ESC atau tombol menu untuk membuka/menutup menu. Klik di dalam area game untuk mengaktifkan kontrol kamera.",
                'shootButton': 'Tembak',
                'gamePaused': 'Game Dijeda.',
                'weaponPreviewNoModel': 'Model senjata tidak tersedia.', // New
                'loadingModel': 'Memuat model 3D...', // New
                'failedToLoadModel': 'Gagal memuat model. Periksa konsol untuk detail.', // New
                'weaponBought': 'Senjata berhasil dibeli!', // New
                'notEnoughCoins': 'Koin tidak cukup!', // New
                'weaponNames': { // New nested object for weapon names
                    'ar15': 'Senapan Gaya AR-15',
                    'pistol': 'Pistol'
                }
            },
            'en': {
                'gameTitle': 'fire123-game',
                'startGame': 'Start Game',
                'continueGame': 'Continue', // New
                'restartGame': 'Restart', // New
                'selectWeapon': 'Select Weapon', // Changed from characterSelect
                'settings': 'Settings',
                'backToMainMenu': 'Back to Main Menu',
                'weaponSelectTitle': 'Select Weapon',
                'weaponDamage': 'Damage:', // New
                'buyButton': 'Buy This Weapon', // New
                'equipButton': 'Equip', // New
                'currentWeapon': 'Equipped', // New
                'ownedButton': 'Owned', // NEW TRANSLATION
                'settingsTitle': 'Settings',
                'settingsPlaceholder': 'Adjust game options here.',
                'mouseSensitivityLabel': 'Mouse Sensitivity:',
                'volumeLabel': 'Volume:',
                'languageLabel': 'Language:',
                'coins': 'Coins:', // Changed from score
                'health': 'Health:',
                'shield': 'Shield:',
                'gameOverMessage': 'GAME OVER! Enemy collided with you.',
                'restartButton': 'Restart', // For game over screen
                'welcomeMessage': "Welcome! Use ESC or the menu button to open/close the menu. Click inside the game area to activate camera controls.",
                'shootButton': 'Shoot',
                'gamePaused': 'Game Paused.',
                'weaponPreviewNoModel': 'Weapon model not available.', // New
                'loadingModel': 'Loading 3D model...', // New
                'failedToLoadModel': 'Failed to load model. Check console for details.', // New
                'weaponBought': 'Weapon successfully purchased!', // New
                'notEnoughCoins': 'Not enough coins!', // New
                'weaponNames': { // New nested object for weapon names
                    'ar15': 'AR-15 Style Rifle',
                    'pistol': 'Pistol'
                }
            }
        };

        // Helper function to play sound only if audio context is running and valid
        function playSound(synth, note, duration) {
            if (Tone.context.state === 'running' && typeof Tone.context.currentTime === 'number' && Tone.context.currentTime >= 0) {
                try {
                    if (synth && synth.triggerAttackRelease) {
                        synth.triggerAttackRelease(note, duration);
                    }
                } catch (e) {
                    console.error("Error playing sound:", e);
                }
            } else {
                console.warn("Konteks audio tidak berjalan atau waktu tidak valid, tidak dapat memutar suara.");
            }
        }

        // --- Three.js Initialization ---
        function initThreeJS() {
            // Scene
            scene = new THREE.Scene(); 

            // Camera (Perspective for FPS)
            camera = new THREE.PerspectiveCamera(ORIGINAL_FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, PLAYER_HEIGHT_OFFSET, 0); // Camera position relative to playerYawObject

            // Renderer
            const canvas3D = document.getElementById('gameCanvas3D');
            renderer = new THREE.WebGLRenderer({ canvas: canvas3D, alpha: false, antialias: true }); // Initialize renderer here
            renderer.setPixelRatio(window.devicePixelRatio); // Set pixel ratio for high DPI displays
            renderer.shadowMap.enabled = true; // Mengaktifkan peta bayangan
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Jenis bayangan yang lebih lembut
            resizeRenderer(); // Set initial size

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x606060); // Increased ambient light for better overall visibility
            scene.add(ambientLight);

            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7); // Light from above and below
            scene.add(hemisphereLight); // ADDED HEMISPHERE LIGHT BACK

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 15, 5); // Posisi cahaya
            directionalLight.castShadow = true; // Cahaya ini akan memancarkan bayangan
            scene.add(directionalLight);

            // Pengaturan bayangan untuk directional light
            directionalLight.shadow.mapSize.width = 2048; // Resolusi peta bayangan (lebih tinggi = lebih tajam)
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -WORLD_WIDTH / 2;
            directionalLight.shadow.camera.right = WORLD_WIDTH / 2;
            directionalLight.shadow.camera.top = WORLD_DEPTH / 2;
            directionalLight.shadow.camera.bottom = -WORLD_DEPTH / 2;
            directionalLight.shadow.bias = -0.0005; // Mengurangi "shadow acne"

            // Ground Plane (now larger)
            const groundGeometry = new THREE.PlaneGeometry(WORLD_WIDTH, WORLD_DEPTH);
            const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22, side: THREE.DoubleSide }); // Forest green
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            ground.position.y = 0; // At y=0
            ground.position.z = -WORLD_DEPTH / 2 + (ORIGINAL_WORLD_DEPTH / 2); // Shift back to center the original play area
            ground.receiveShadow = true; // Tanah akan menerima bayangan
            scene.add(ground);

            // Player Yaw Object (handles horizontal rotation for player and camera)
            playerYawObject = new THREE.Object3D(); // Initialize playerYawObject here
            scene.add(playerYawObject); // Add to scene

            // Player Capsule (invisible for player collision, child of playerYawObject)
            const playerCapsuleGeometry = new THREE.CylinderGeometry(PLAYER_RADIUS, PLAYER_RADIUS, PLAYER_HEIGHT_OFFSET * 2, 16);
            const playerCapsuleMaterial = DEBUG_COLLISIONS ? new THREE.MeshBasicMaterial({ color: 0x00FF00, wireframe: true, transparent: true, opacity: 0.5 }) : new THREE.MeshBasicMaterial({ visible: false });
            playerCapsule = new THREE.Mesh(playerCapsuleGeometry, playerCapsuleMaterial);
            playerCapsule.position.y = PLAYER_HEIGHT_OFFSET; // Position relative to playerYawObject's base
            playerYawObject.add(playerCapsule); // Add as child

            playerYawObject.add(camera); // Make camera a child of playerYawObject

            // Load Weapon Model (FBX) - This is for the in-game gun
            // This will be loaded dynamically based on currentWeapon.modelPath
            // This is called in initializeGameElements after currentWeapon is set
            // loadInGameWeaponModel(currentWeapon.modelPath);


            // Add initial environment assets
            addEnvironmentAssets();
            
            // Add Skybox
            addSkybox();
        }

        // Function to load the in-game weapon model
        function loadInGameWeaponModel(modelPath) {
            if (playerGunModel) {
                camera.remove(playerGunModel);
                playerGunModel = null;
            }

            if (!modelPath) {
                console.warn("No model path for in-game weapon. Using fallback.");
                const gunGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
                const gunMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                playerGunModel = new THREE.Mesh(gunGeometry, gunMaterial);
                playerGunModel.position.set(0.3, -0.25, -0.5);
                playerGunModel.castShadow = true;
                camera.add(playerGunModel);
                return;
            }

            const fbxLoader = new THREE.FBXLoader();
            fbxLoader.load(modelPath, (fbx) => {
                playerGunModel = fbx;
                playerGunModel.scale.set(0.005, 0.005, 0.005);
                playerGunModel.position.set(0.3, -0.25, -0.5);
                playerGunModel.rotation.set(Math.PI, Math.PI, Math.PI); // Adjust rotation as needed
                playerGunModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    // Ensure material is a PhongMaterial for lighting
                                    child.material = new THREE.MeshPhongMaterial({ color: mat.color });
                                    mat.needsUpdate = true;
                                });
                            } else {
                                child.material = new THREE.MeshPhongMaterial({ color: child.material.color });
                                child.material.needsUpdate = true;
                            }
                        } else {
                            child.material = new THREE.MeshPhongMaterial({ color: 0x888888 });
                        }
                    }
                });
                camera.add(playerGunModel);
            }, undefined, (error) => {
                console.error("Error loading in-game weapon FBX model:", error);
                // Fallback to simple box gun if model fails to load
                const gunGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
                const gunMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                playerGunModel = new THREE.Mesh(gunGeometry, gunMaterial);
                playerGunModel.position.set(0.3, -0.25, -0.5);
                playerGunModel.castShadow = true;
                camera.add(playerGunModel);
            });
        }


        // Helper function to add a box obstacle
        function addObstacle(x, y, z, sizeX, sizeY, sizeZ, color = 0x8B4513) {
            const obstacleGeometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
            const obstacleMaterial = new THREE.MeshPhongMaterial({ color: color });
            const obstacleMesh = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacleMesh.position.set(x, y + sizeY / 2, z);
            obstacleMesh.castShadow = true; // Rintangan memancarkan bayangan
            obstacleMesh.receiveShadow = true; // Rintangan menerima bayangan
            scene.add(obstacleMesh);
            obstacles.push(obstacleMesh);

            if (DEBUG_COLLISIONS) {
                const boxHelper = new THREE.BoxHelper(obstacleMesh, 0xFFFF00);
                scene.add(boxHelper);
                obstacleMesh.userData.boxHelper = boxHelper;
            }
        }

        // Helper function to add a cylinder obstacle (e.g., pillar, barrel)
        function addCylinderObstacle(x, y, z, radius, height, color = 0x696969) {
            const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, height, 32);
            const cylinderMaterial = new THREE.MeshPhongMaterial({ color: color });
            const cylinderMesh = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinderMesh.position.set(x, y + height / 2, z);
            cylinderMesh.castShadow = true; // Silinder memancarkan bayangan
            cylinderMesh.receiveShadow = true; // Silinder menerima bayangan
            scene.add(cylinderMesh);
            obstacles.push(cylinderMesh);

            if (DEBUG_COLLISIONS) {
                const boxHelper = new THREE.BoxHelper(cylinderMesh, 0xFFFF00);
                scene.add(boxHelper);
                cylinderMesh.userData.boxHelper = boxHelper;
            }
        }

        function addEnvironmentAssets() {
            obstacles.forEach(o => {
                scene.remove(o);
                if (DEBUG_COLLISIONS && o.userData.boxHelper) {
                    scene.remove(o.userData.boxHelper);
                }
            });
            obstacles = [];

            addObstacle(0, 0, -5, 2, 1, 2, 0x808080);
            addCylinderObstacle(3, 0, -7, 0.8, 2.5, 0x556B2F);
            addObstacle(-3, 0, -3, 1.5, 1.5, 1.5, 0x708090);
            addObstacle(0, 0, 8, 10, 5, 4, 0x4682B4);
            addObstacle(0, 5, 8, 11, 1, 5, 0x8B4513);
            addObstacle(-WORLD_WIDTH / 2 + 2, 0, 0, 1, 3, 8, 0x6A5ACD);
            addObstacle(WORLD_WIDTH / 2 - 2, 0, 0, 1, 3, 8, 0x6A5ACD);
            addObstacle(-WORLD_WIDTH / 4, 0, -10, 3, 2, 1.5, 0xCD853F);
            addCylinderObstacle(WORLD_WIDTH / 4, 0, -10, 0.6, 2, 0xCD853F);

            for (let i = 0; i < 8; i++) {
                const x = (Math.random() * (WORLD_WIDTH - 2)) - (WORLD_WIDTH / 2 - 1);
                const z = (Math.random() * (WORLD_DEPTH - 2)) - (WORLD_DEPTH / 2 - 1);
                const size = 0.5 + Math.random() * 1.5;
                const height = 0.5 + Math.random() * 2;
                addObstacle(x, 0, z, size, height, size, 0x778899);
            }
        }

        // --- Enemy Creation Function (More complex shape) ---
        function createEnemyMesh() {
            const enemyGroup = new THREE.Group();
            const material = new THREE.MeshPhongMaterial({ color: ENEMY_COLOR });

            const bodyGeometry = new THREE.BoxGeometry(ENEMY_SIZE * 0.6, ENEMY_BODY_HEIGHT, ENEMY_SIZE * 0.4);
            const bodyMesh = new THREE.Mesh(bodyGeometry, material);
            bodyMesh.position.y = ENEMY_BODY_HEIGHT / 2;
            bodyMesh.castShadow = true; // Badan musuh memancarkan bayangan
            enemyGroup.add(bodyMesh);

            const headGeometry = new THREE.SphereGeometry(ENEMY_HEAD_RADIUS, 16, 16);
            const headMesh = new THREE.Mesh(headGeometry, material);
            headMesh.position.y = ENEMY_BODY_HEIGHT + ENEMY_HEAD_RADIUS;
            headMesh.castShadow = true; // Kepala musuh memancarkan bayangan
            enemyGroup.add(headMesh);

            const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, ENEMY_ARM_LENGTH, 8);
            const leftArm = new THREE.Mesh(armGeometry, material);
            leftArm.position.set(-(ENEMY_SIZE * 0.3 + 0.1), ENEMY_BODY_HEIGHT * 0.7, 0);
            leftArm.rotation.z = Math.PI / 4;
            leftArm.castShadow = true; // Lengan memancarkan bayangan
            enemyGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, material);
            rightArm.position.set((ENEMY_SIZE * 0.3 + 0.1), ENEMY_BODY_HEIGHT * 0.7, 0);
            rightArm.rotation.z = -Math.PI / 4;
            rightArm.castShadow = true; // Lengan memancarkan bayangan
            enemyGroup.add(rightArm);

            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, ENEMY_LEG_LENGTH, 8);
            const leftLeg = new THREE.Mesh(legGeometry, material);
            leftLeg.position.set(-(ENEMY_SIZE * 0.2), ENEMY_LEG_LENGTH / 2, 0);
            leftLeg.castShadow = true; // Kaki memancarkan bayangan
            enemyGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, material);
            rightLeg.position.set((ENEMY_SIZE * 0.2), ENEMY_LEG_LENGTH / 2, 0);
            rightLeg.castShadow = true; // Kaki memancarkan bayangan
            enemyGroup.add(rightLeg);

            enemyGroup.position.y = ENEMY_LEG_LENGTH / 2;
            enemyGroup.receiveShadow = true; // Musuh menerima bayangan (dari dirinya sendiri atau objek lain)

            // Add health bar to enemy
            const healthBarWidth = 1.2;
            const healthBarHeight = 0.15;

            const healthBarBackgroundGeometry = new THREE.PlaneGeometry(healthBarWidth, healthBarHeight);
            const healthBarBackgroundMaterial = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
            const healthBarBackground = new THREE.Mesh(healthBarBackgroundGeometry, healthBarBackgroundMaterial);
            healthBarBackground.position.y = ENEMY_BODY_HEIGHT + ENEMY_HEAD_RADIUS + 0.3;
            enemyGroup.add(healthBarBackground);
            enemyGroup.userData.healthBarBackground = healthBarBackground;

            const healthBarForegroundGeometry = new THREE.PlaneGeometry(healthBarWidth * 0.9, healthBarHeight * 0.8);
            const healthBarForegroundMaterial = new THREE.MeshBasicMaterial({ color: 0x00FF00, side: THREE.DoubleSide });
            const healthBarForeground = new THREE.Mesh(healthBarForegroundGeometry, healthBarForegroundMaterial);
            healthBarForeground.position.y = ENEMY_BODY_HEIGHT + ENEMY_HEAD_RADIUS + 0.3;
            healthBarForeground.position.z = 0.01;
            enemyGroup.add(healthBarForeground);
            enemyGroup.userData.healthBar = healthBarForeground;

            // --- PERUBAHAN DI SINI: Kesehatan musuh ditingkatkan menjadi 60 ---
            enemyGroup.userData.maxHealth = 60; 
            enemyGroup.userData.currentHealth = 60; 

            return enemyGroup;
        }

        // --- Skybox Implementation ---
        function addSkybox() {
            const path = "https://threejs.org/examples/textures/cube/Bridge2/";
            const urls = [
                path + "posx.jpg", path + "negx.jpg",
                path + "posy.jpg", path + "negy.jpg",
                path + "posz.jpg", path + "negz.jpg"
            ];

            const cubeTextureLoader = new THREE.CubeTextureLoader();
            cubeTextureLoader.load(urls, (texture) => {
                scene.background = texture;
            }, undefined, (error) => {
                console.error("Error loading skybox textures:", error);
                scene.background = new THREE.Color(0x333333); 
            });
        }

        // Function to save weapon data to localStorage
        function saveWeaponsToLocalStorage() {
            localStorage.setItem('ownedWeapons', JSON.stringify(weapons));
        }

        // --- Game Initialization ---
        function initializeGameElements() {
            console.log("initializeGameElements called");
            bullets.forEach(b => scene.remove(b.mesh));
            enemies.forEach(e => scene.remove(e.mesh));

            bullets = [];
            enemies = [];
            
            // Load coins from localStorage, default to 0 if not found
            const savedCoins = localStorage.getItem('gameCoins');
            coins = savedCoins ? parseInt(savedCoins) : 0;
            
            // Load weapons from localStorage
            const savedWeapons = localStorage.getItem('ownedWeapons');
            if (savedWeapons) {
                weapons = JSON.parse(savedWeapons);
                // Ensure allWeaponsData weapons are present in 'weapons' array with correct 'owned' status
                allWeaponsData.forEach(defaultWeapon => {
                    const existingWeapon = weapons.find(w => w.id === defaultWeapon.id);
                    if (!existingWeapon) {
                        // Add new weapons from allWeaponsData if they don't exist in saved data
                        weapons.push({ ...defaultWeapon, owned: false, current: false });
                    } else {
                        // Update existing weapon properties (like damage, modelPath) from default, but keep owned/current status
                        existingWeapon.damage = defaultWeapon.damage;
                        existingWeapon.modelPath = defaultWeapon.modelPath;
                        existingWeapon.price = defaultWeapon.price;
                    }
                });
                // Remove any weapons from 'weapons' that are no longer in 'allWeaponsData'
                weapons = weapons.filter(w => allWeaponsData.some(dw => dw.id === w.id));

                // Ensure 'current' status is consistent: only one weapon should be current.
                // If multiple are current or none, reset to pistol.
                const currentlyEquipped = weapons.filter(w => w.current);
                if (currentlyEquipped.length !== 1) {
                    weapons.forEach(w => w.current = false); // Clear all 'current' flags
                    const pistol = weapons.find(w => w.id === 'pistol');
                    if (pistol) {
                        pistol.current = true;
                        pistol.owned = true; // Ensure pistol is always owned
                    } else { // Fallback if pistol somehow not found (shouldn't happen with defaultWeapons)
                        weapons[0].current = true;
                        weapons[0].owned = true;
                    }
                } else {
                    // If exactly one is current, ensure pistol is owned
                    const pistol = weapons.find(w => w.id === 'pistol');
                    if (pistol) pistol.owned = true;
                }

            } else {
                // First time loading, use default weapons and mark pistol as owned/current
                weapons = JSON.parse(JSON.stringify(allWeaponsData)); // Deep copy
                weapons.forEach(w => {
                    w.owned = (w.id === 'pistol'); // Only pistol is owned by default
                    w.current = (w.id === 'pistol'); // Only pistol is current by default
                });
                saveWeaponsToLocalStorage(); // Save defaults
            }
            currentWeapon = weapons.find(w => w.current);
            BULLET_DAMAGE = currentWeapon.damage; // Set initial damage based on loaded weapon
            loadInGameWeaponModel(currentWeapon.modelPath); // Load the in-game model

            playerHealth = playerMaxHealth;
            playerShield = playerMaxShield;
            lastEnemySpawnTime = Date.now();
            updateCoinsDisplay(); // Changed from updateScoreDisplay
            updateHealthShieldDisplay(); // Update new health/shield display

            playerYawObject.position.set(0, 0, 5);
            playerYawObject.rotation.y = 0;
            camera.rotation.x = 0;
            
            addEnvironmentAssets();
            addSkybox();
        }

        // Fungsi untuk memulai permainan (dari awal)
        function startGame() { // This function is for a full restart
            console.log("startGame called (full restart)");
            initializeGameElements(); // Resets coins, health, enemies, player position, and loads weapons
            gameOver = false;
            gameState = 'playing';
            gameStartedAtLeastOnce = true;

            hideAllScreens();
            playerHud.style.display = 'flex';
            menuToggleButton.style.display = 'block';
            Tone.start();
            requestPointerLock();
            console.log("New Game Started!");
        }

        // New function to resume the game without resetting
        function resumeGame() {
            console.log("resumeGame called");
            gameOver = false; // Ensure game is not in game over state
            gameState = 'playing';
            hideAllScreens();
            playerHud.style.display = 'flex';
            menuToggleButton.style.display = 'block';
            requestPointerLock();
            // No need to call animate() here, it's already running.
            console.log("Game Resumed!");
        }


        // --- Update Game State Functions ---
        function updatePlayer(deltaTime) {
            const moveSpeed = PLAYER_BASE_SPEED * deltaTime;
            const originalX = playerYawObject.position.x;
            const originalZ = playerYawObject.position.z;

            const forwardVector = new THREE.Vector3(0, 0, -1).applyQuaternion(playerYawObject.quaternion);
            forwardVector.y = 0;
            forwardVector.normalize();

            const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(playerYawObject.quaternion);
            rightVector.y = 0;
            rightVector.normalize();

            let movementVector = new THREE.Vector3();

            if (keys['ArrowUp'] || keys['w'] || touchMoveForward) {
                movementVector.add(forwardVector);
            }
            if (keys['ArrowDown'] || keys['s'] || touchMoveBackward) {
                movementVector.sub(forwardVector);
            }
            if (keys['ArrowLeft'] || keys['a'] || touchMoveLeft) {
                movementVector.sub(rightVector);
            }
            if (keys['ArrowRight'] || keys['d'] || touchMoveRight) {
                movementVector.add(rightVector);
            }

            if (movementVector.lengthSq() > 0) {
                movementVector.normalize();
                movementVector.multiplyScalar(moveSpeed);
            }

            playerYawObject.position.x += movementVector.x;
            const playerBoxAfterXMove = new THREE.Box3().setFromObject(playerCapsule);
            for (const obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBoxAfterXMove.intersectsBox(obstacleBox)) {
                    playerYawObject.position.x = originalX;
                    break;
                }
            }

            playerYawObject.position.z += movementVector.z;
            const playerBoxAfterZMove = new THREE.Box3().setFromObject(playerCapsule);
            for (const obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBoxAfterZMove.intersectsBox(obstacleBox)) {
                    playerYawObject.position.z = originalZ;
                    break;
                }
            }

            playerYawObject.position.y = 0; 

            const halfWorldWidth = WORLD_WIDTH / 2 - PLAYER_RADIUS;
            const halfWorldDepth = WORLD_DEPTH / 2 - PLAYER_RADIUS;

            if (playerYawObject.position.x < -halfWorldWidth) playerYawObject.position.x = -halfWorldWidth;
            if (playerYawObject.position.x > halfWorldWidth) playerYawObject.position.x = halfWorldWidth;
            if (playerYawObject.position.z > halfWorldDepth) playerYawObject.position.z = halfWorldDepth;
            if (playerYawObject.position.z < -halfWorldDepth) playerYawObject.position.z = -halfWorldDepth;
        }

        function updateBullets(deltaTime) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.mesh.position.add(bullet.direction.clone().multiplyScalar(BULLET_SPEED * deltaTime));

                if (
                    bullet.mesh.position.z < -WORLD_DEPTH / 2 - 2 ||
                    bullet.mesh.position.z > WORLD_DEPTH / 2 + 2 ||
                    bullet.mesh.position.x < -WORLD_WIDTH / 2 - 2 ||
                    bullet.mesh.position.x > WORLD_WIDTH / 2 + 2
                ) {
                    scene.remove(bullet.mesh);
                    bullets.splice(i, 1);
                }
            }
        }

        function spawnEnemy() {
            const now = Date.now();
            if (now - lastEnemySpawnTime > ENEMY_SPAWN_INTERVAL) {
                const x = (Math.random() * (WORLD_WIDTH - ENEMY_SIZE)) - (WORLD_WIDTH / 2 - ENEMY_SIZE / 2);
                const z = -(WORLD_DEPTH / 2) - ENEMY_SIZE - (Math.random() * 5); // Spawn further back
                const speed = ENEMY_SPEED_MIN + Math.random() * (ENEMY_SPEED_MAX - ENEMY_SPEED_MIN);

                const enemyMesh = createEnemyMesh();
                enemyMesh.position.set(x, 0, z);
                scene.add(enemyMesh);

                enemies.push({ mesh: enemyMesh, speed: speed });
                lastEnemySpawnTime = now;
            }
        }

        function updateEnemies(deltaTime) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                // Move enemy towards player
                const directionToPlayer = new THREE.Vector3().subVectors(playerYawObject.position, enemy.mesh.position).normalize();
                enemy.mesh.position.add(directionToPlayer.multiplyScalar(enemy.speed * deltaTime));

                // Make enemy look at player (only yaw)
                enemy.mesh.lookAt(playerYawObject.position.x, enemy.mesh.position.y, playerYawObject.position.z);
                enemy.mesh.rotation.x = 0; // Prevent tilting up/down
                enemy.mesh.rotation.z = 0; // Prevent rolling

                // Update health bar orientation to face camera
                if (enemy.mesh.userData.healthBar && camera) {
                    enemy.mesh.userData.healthBar.quaternion.copy(camera.quaternion);
                    enemy.mesh.userData.healthBarBackground.quaternion.copy(camera.quaternion);
                }

                const playerCollisionBox = new THREE.Box3().setFromObject(playerCapsule);
                const enemyBox = new THREE.Box3().setFromObject(enemy.mesh);

                if (playerCollisionBox.intersectsBox(enemyBox)) {
                    // Apply damage to player's shield first, then health
                    let damageRemaining = ENEMY_DAMAGE_TO_PLAYER;
                    if (playerShield > 0) {
                        const shieldDmg = Math.min(playerShield, damageRemaining);
                        playerShield -= shieldDmg;
                        damageRemaining -= shieldDmg;
                    }
                    if (damageRemaining > 0) {
                        playerHealth -= damageRemaining;
                    }
                    
                    playSound(playerHitSynth, "C3", "8n");
                    updateHealthShieldDisplay(); // Update health and shield bars
                    
                    scene.remove(enemy.mesh);
                    enemies.splice(i, 1);
                    
                    if (playerHealth <= 0) {
                        endGame(translations[currentLanguage].gameOverMessage);
                    }
                    continue;
                }

                // Remove enemies that pass the player
                if (enemy.mesh.position.z > playerYawObject.position.z + 5) { // If enemy is 5 units past player
                    scene.remove(enemy.mesh);
                    enemies.splice(i, 1);
                }
            }
        }

        // --- Collision Detection ---
        function checkCollisions() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                const bulletBox = new THREE.Box3().setFromObject(bullet.mesh);

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const enemyBox = new THREE.Box3().setFromObject(enemy.mesh);

                    if (bulletBox.intersectsBox(enemyBox)) {
                        playSound(enemyExplodeSynth, "C2", "8n");
                        scene.remove(bullet.mesh);
                        bullets.splice(i, 1);

                        // Apply damage and update health bar
                        enemy.mesh.userData.currentHealth -= (isZoomed ? (BULLET_DAMAGE * ZOOMED_BULLET_DAMAGE_MULTIPLIER) : BULLET_DAMAGE);
                        
                        // --- Efek Kilatan (Flash Effect) pada Musuh ---
                        enemy.mesh.traverse((child) => {
                            if (child.isMesh && child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => mat.color.setHex(0xFFFFFF)); // Kilat putih
                                } else {
                                    child.material.color.setHex(0xFFFFFF); // Kilat putih
                                }
                            }
                        });

                        setTimeout(() => {
                            enemy.mesh.traverse((child) => {
                                if (child.isMesh && child.material) {
                                    if (Array.isArray(child.material)) {
                                        child.material.forEach(mat => mat.color.setHex(ENEMY_COLOR)); // Kembali ke warna merah asli
                                    } else {
                                        child.material.color.setHex(ENEMY_COLOR); // Kembali ke warna merah asli
                                    }
                                }
                            });
                        }, 100); // Kilat selama 100ms
                        // --- Akhir Efek Kilatan ---

                        const healthRatio = enemy.mesh.userData.currentHealth / enemy.mesh.userData.maxHealth;

                        enemy.mesh.userData.healthBar.scale.x = healthRatio;
                        // Adjust position to keep left edge fixed
                        enemy.mesh.userData.healthBar.position.x = (enemy.mesh.userData.healthBar.geometry.parameters.width / 2) * (healthRatio - 1);

                        // Change health bar color based on health
                        if (healthRatio > 0.5) {
                            enemy.mesh.userData.healthBar.material.color.setHex(0x00FF00); // Green
                        } else if (healthRatio > 0.2) {
                            enemy.mesh.userData.healthBar.material.color.setHex(0xFFFF00); // Yellow
                        } else {
                            enemy.mesh.userData.healthBar.material.color.setHex(0xFF0000); // Red
                        }

                        if (enemy.mesh.userData.currentHealth <= 0) {
                            scene.remove(enemy.mesh);
                            enemies.splice(j, 1);
                            coins += 10; // Changed from score
                            updateCoinsDisplay(); // Changed from updateScoreDisplay
                        }
                        break; // Bullet hit an enemy, stop checking other enemies for this bullet
                    }
                }
            }
        }

        // --- Display Updates ---
        function updateCoinsDisplay() { // Changed from updateScoreDisplay
            coinsDisplay.textContent = `${translations[currentLanguage].coins} ${coins}`; // Changed from score
            localStorage.setItem('gameCoins', coins); // Save coins to localStorage
        }

        function updateHealthShieldDisplay() {
            // Health Bar
            const healthPercentage = (playerHealth / playerMaxHealth) * 100;
            healthBarFill.style.width = `${Math.max(0, healthPercentage)}%`;
            healthLabel.textContent = `${translations[currentLanguage].health} ${Math.max(0, Math.floor(playerHealth))}`;
            if (playerHealth > 50) {
                healthBarFill.style.backgroundColor = '#0F0'; // Green
            } else if (playerHealth > 20) {
                healthBarFill.style.backgroundColor = '#FFD700'; // Gold/Yellow
            } else {
                healthBarFill.style.backgroundColor = '#F00'; // Red
            }

            // Shield Bar
            const shieldPercentage = (playerShield / playerMaxShield) * 100;
            shieldBarFill.style.width = `${Math.max(0, shieldPercentage)}%`;
            shieldLabel.textContent = `${translations[currentLanguage].shield} ${Math.max(0, Math.floor(playerShield))}`;
            if (playerShield > 20) {
                shieldBarFill.style.backgroundColor = '#00F'; // Blue
            } else {
                shieldBarFill.style.backgroundColor = '#800080'; // Purple
            }
        }

        // Function to update settings UI elements based on current values
        function updateSettingsDisplay() {
            mouseSensitivitySlider.value = mouseSensitivity;
            mouseSensitivityValueDisplay.textContent = mouseSensitivity.toFixed(4);

            volumeSlider.value = masterVolume;
            volumeValueDisplay.textContent = `${Math.floor(masterVolume * 100)}%`;

            // Update language button selection
            if (currentLanguage === 'id') {
                langIdButton.classList.add('selected');
                langEnButton.classList.remove('selected');
                langIdButton.style.backgroundColor = '#2563eb'; // Tailwind blue-600
                langEnButton.style.backgroundColor = '#4b5563'; // Tailwind gray-600
            } else {
                langIdButton.classList.remove('selected');
                langEnButton.classList.add('selected');
                langIdButton.style.backgroundColor = '#4b5563'; // Tailwind gray-600
                langEnButton.style.backgroundColor = '#2563eb'; // Tailwind blue-600
            }
        }

        // Function to change the game language
        function updateLanguage(lang) {
            currentLanguage = lang;
            updateLanguageDisplay();
            // Re-render weapon list to update language
            if (gameState === 'weaponSelect') {
                updateWeaponPreviewUI(); // Update UI elements on weapon select screen
            }
        }

        // --- Game Over / Message Box ---
        // This message box is now only for Game Over messages.
        function showMessageBox(message) {
            messageText.textContent = message;
            messageText.dataset.originalMessage = message; // Store original message for language changes
            messageBox.style.display = 'block';
            playerHud.style.display = 'none'; // Hide HUD when message box is shown
            menuToggleButton.style.display = 'none'; // Hide menu button
        }

        function hideMessageBox() {
            messageBox.style.display = 'none';
            // HUD and menu button visibility is now managed by hideAllScreens and then explicitly shown when gameState is 'playing'.
        }

        function endGame(message) {
            console.log("GAME OVER CALLED with message:", message);
            gameOver = true;
            gameState = 'gameOver';
            showMessageBox(message);
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }

        // --- Main Game Loop ---
        function animate(currentTime) {
            if (!lastFrameTime) {
                lastFrameTime = currentTime;
            }
            const deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            if (gameState !== 'playing') { // Only update game logic if playing
                renderer.render(scene, camera); // Still render the scene even if paused/menu
                requestAnimationFrame(animate); // Keep rendering the current state (menu/game over)
                return;
            }

            updatePlayer(deltaTime);
            updateBullets(deltaTime);
            spawnEnemy();
            updateEnemies(deltaTime);
            checkCollisions();

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        // --- Screen Management ---
        function hideAllScreens() {
            mainMenuScreen.style.display = 'none';
            weaponSelectScreen.style.display = 'none'; // Changed from characterSelectScreen
            settingsScreen.style.display = 'none';
            messageBox.style.display = 'none'; // Always hide message box when changing screens
            playerHud.style.display = 'none'; // Hide HUD by default
            menuToggleButton.style.display = 'none'; // Hide menu button by default
        }

        function showMainMenu() {
            hideAllScreens();
            mainMenuScreen.style.display = 'flex';
            gameState = 'menu';
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }

            // Adjust button visibility and text based on game state
            if (gameStartedAtLeastOnce && !gameOver) {
                mainMenuPrimaryButton.textContent = translations[currentLanguage].continueGame;
                restartGameButton.style.display = 'block'; // Show restart button
            } else {
                mainMenuPrimaryButton.textContent = translations[currentLanguage].startGame;
                restartGameButton.style.display = 'none'; // Hide restart button if not paused game
            }
            welcomeMessageText.textContent = translations[currentLanguage].welcomeMessage;
        }

        function showWeaponSelection() {
            hideAllScreens();
            weaponSelectScreen.style.display = 'flex';
            gameState = 'weaponSelect';
            // Ensure preview canvas is correctly sized when it becomes visible
            resizeRenderer(); // This will resize both main and preview renderers
            initWeaponPreview3D(); // Initialize weapon preview scene
            loadWeaponForPreview(currentWeaponIndex); // Load the current weapon for preview
        }

        function showSettings() {
            hideAllScreens();
            settingsScreen.style.display = 'flex';
            gameState = 'settings';
            updateSettingsDisplay(); // Update settings UI when shown
        }

        // --- Weapon Selection Logic (NEW) ---
        /**
         * Fungsi untuk menginisialisasi scene 3D untuk pratinjau senjata
         */
        function initWeaponPreview3D() {
            // Hanya inisialisasi jika belum ada
            if (previewScene) return;

            const previewCanvas = document.createElement('canvas');
            previewCanvas.id = 'weaponPreviewCanvas'; // Assign an ID for easier reference
            weaponPreviewContainer.appendChild(previewCanvas); // Append to the new container

            previewScene = new THREE.Scene();
            previewScene.background = new THREE.Color(0x1a1a2e); // Latar belakang scene

            previewCamera = new THREE.PerspectiveCamera(75, weaponPreviewContainer.clientWidth / weaponPreviewContainer.clientHeight, 0.1, 1000);
            previewCamera.position.set(0, 0, 5);

            previewRenderer = new THREE.WebGLRenderer({ canvas: previewCanvas, antialias: true, alpha: true });
            previewRenderer.setSize(weaponPreviewContainer.clientWidth, weaponPreviewContainer.clientHeight);
            previewRenderer.setPixelRatio(window.devicePixelRatio);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            previewScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            previewScene.add(directionalLight);

            previewControls = new THREE.OrbitControls(previewCamera, previewRenderer.domElement);
            previewControls.enableDamping = true;
            previewControls.dampingFactor = 0.05;
            previewControls.screenSpacePanning = false;
            previewControls.minDistance = 1;
            previewControls.maxDistance = 10;
            previewControls.maxPolarAngle = Math.PI / 2;

            // Start the preview animation loop
            animateWeaponPreview();
        }

        /**
         * Fungsi untuk memuat model senjata untuk pratinjau
         * @param {number} index - Indeks model senjata dalam array allWeaponsData
         */
        function loadWeaponForPreview(index) {
            loadingOverlay.style.display = 'flex';
            loadingOverlay.querySelector('p').textContent = translations[currentLanguage].loadingModel;

            if (currentPreviewModel) {
                previewScene.remove(currentPreviewModel);
                currentPreviewModel.traverse(function (child) {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    }
                });
                currentPreviewModel = null;
            }

            const weaponData = allWeaponsData[index];
            const fbxModelUrl = weaponData.modelPath;
            const loader = new THREE.FBXLoader();
            loader.load(
                fbxModelUrl,
                function (object) {
                    loadingOverlay.style.display = 'none';

                    object.scale.set(0.01, 0.01, 0.01); 
                    object.position.set(0, 0, 0);

                    currentPreviewModel = object;
                    previewScene.add(object);

                    updateDamageBar(weaponData.damage);
                    updateBuyButtonState(weaponData);

                    const box = new THREE.Box3().setFromObject(object);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = previewCamera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                    cameraZ *= 1.5;

                    previewCamera.position.set(center.x, center.y, center.z + cameraZ);
                    previewControls.target.copy(center);
                    previewControls.update();
                },
                function (xhr) {
                    const progress = (xhr.loaded / xhr.total) * 100;
                    loadingOverlay.querySelector('p').textContent = `${translations[currentLanguage].loadingModel} ${progress.toFixed(0)}%`;
                },
                function (error) {
                    console.error('Terjadi kesalahan saat memuat model FBX:', error);
                    loadingOverlay.innerHTML = `<p class="text-red-500">${translations[currentLanguage].failedToLoadModel}</p>`;
                }
            );
        }

        /**
         * Fungsi untuk memperbarui tampilan damage bar
         * @param {number} damageValue - Nilai damage (0-100)
         */
        function updateDamageBar(damageValue) {
            damageFill.style.width = `${damageValue}%`;
            damageText.textContent = `${translations[currentLanguage].weaponDamage} ${damageValue}`;
        }

        /**
         * Fungsi untuk memperbarui status tombol beli/pilih
         * @param {object} weaponData - Objek data senjata dari allWeaponsData
         */
        function updateBuyButtonState(weaponData) {
            const gameWeapon = weapons.find(w => w.id === weaponData.id);
            
            // Defensive check: If gameWeapon is not found, something is wrong with data initialization.
            if (!gameWeapon) {
                console.error("Error: gameWeapon not found in 'weapons' array for ID:", weaponData.id);
                weaponPriceDisplay.textContent = "Error"; // Clear price
                buyWeaponBtn.textContent = "Error";
                buyWeaponBtn.disabled = true;
                buyWeaponBtn.classList.remove('bg-blue-600', 'bg-purple-600', 'bg-gray-500', 'bg-green-700', 'bg-green-600');
                buyWeaponBtn.classList.add('bg-red-500'); // Indicate error
                return; // Exit the function to prevent further errors
            }

            // Update price display
            if (weaponData.price === 0) {
                weaponPriceDisplay.textContent = translations[currentLanguage].ownedButton; // If price is 0, it's the default pistol
            } else {
                weaponPriceDisplay.textContent = `${weaponData.price} ${translations[currentLanguage].coins}`;
            }

            if (gameWeapon.current) {
                buyWeaponBtn.textContent = translations[currentLanguage].currentWeapon;
                buyWeaponBtn.disabled = true;
                buyWeaponBtn.classList.remove('bg-blue-600', 'bg-purple-600', 'bg-gray-500', 'bg-green-700'); // Remove all others
                buyWeaponBtn.classList.add('bg-green-600');
            } else if (gameWeapon.owned) {
                buyWeaponBtn.textContent = translations[currentLanguage].ownedButton; // Changed to "Miliki"
                buyWeaponBtn.disabled = false; // Can still click to equip
                buyWeaponBtn.classList.remove('bg-green-600', 'bg-purple-600', 'bg-gray-500', 'bg-blue-600'); // Remove all others
                buyWeaponBtn.classList.add('bg-green-700'); // Darker green for owned but not current
            } else if (coins >= weaponData.price) {
                buyWeaponBtn.textContent = `${translations[currentLanguage].buyButton}`; // No price in button text, price is above
                buyWeaponBtn.disabled = false;
                buyWeaponBtn.classList.remove('bg-green-600', 'bg-blue-600', 'bg-gray-500', 'bg-green-700'); // Remove all others
                buyWeaponBtn.classList.add('bg-purple-600');
            } else {
                buyWeaponBtn.textContent = `${translations[currentLanguage].buyButton}`; // No price in button text, price is above
                buyWeaponBtn.disabled = true;
                buyWeaponBtn.classList.remove('bg-green-600', 'bg-blue-600', 'bg-purple-600', 'bg-green-700'); // Remove all others
                buyWeaponBtn.classList.add('bg-gray-500');
            }
        }

        /**
         * Fungsi untuk menampilkan senjata sebelumnya
         */
        function showPreviousWeapon() {
            currentWeaponIndex = (currentWeaponIndex - 1 + allWeaponsData.length) % allWeaponsData.length;
            loadWeaponForPreview(currentWeaponIndex);
        }

        /**
         * Fungsi untuk menampilkan senjata berikutnya
         */
        function showNextWeapon() {
            currentWeaponIndex = (currentWeaponIndex + 1) % allWeaponsData.length;
            loadWeaponForPreview(currentWeaponIndex);
        }

        /**
         * Fungsi untuk menangani aksi beli/pilih senjata
         */
        function buyWeapon() {
            const weaponToProcess = allWeaponsData[currentWeaponIndex];
            const gameWeapon = weapons.find(w => w.id === weaponToProcess.id);

            // Defensive check
            if (!gameWeapon) {
                console.error("Error: gameWeapon not found in 'weapons' array for ID:", weaponToProcess.id);
                showMessageBox("Error processing weapon. Please restart the game.");
                return; // Exit the function
            }

            if (gameWeapon.owned) {
                // If owned, just equip it
                equipWeapon(gameWeapon);
                showMessageBox(`${translations[currentLanguage].weaponNames[gameWeapon.id]} ${translations[currentLanguage].currentWeapon.toLowerCase()}!`);
            } else if (coins >= weaponToProcess.price) {
                // If not owned and enough coins, buy and equip
                coins -= weaponToProcess.price;
                gameWeapon.owned = true;
                updateCoinsDisplay();
                equipWeapon(gameWeapon);
                showMessageBox(`${translations[currentLanguage].weaponBought} (${translations[currentLanguage].weaponNames[gameWeapon.id]})`);
            } else {
                // Not enough coins
                showMessageBox(translations[currentLanguage].notEnoughCoins);
            }
            saveWeaponsToLocalStorage();
            updateBuyButtonState(weaponToProcess); // Update button state after action
        }

        function equipWeapon(weaponToEquip) {
            // Deselect old weapon
            if (currentWeapon) {
                currentWeapon.current = false;
            }
            
            // Select new weapon
            weaponToEquip.current = true;
            currentWeapon = weaponToEquip;
            BULLET_DAMAGE = currentWeapon.damage; // Update global damage
            
            loadInGameWeaponModel(currentWeapon.modelPath); // Load new in-game model
            saveWeaponsToLocalStorage(); // Save changes
            console.log(`Weapon ${weaponToEquip.name} equipped!`);
        }


        // --- Event Listeners ---
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                if (gameState === 'playing') {
                    // Pause game and show main menu
                    if (document.pointerLockElement) {
                        document.exitPointerLock(); // This will trigger pointerlockchange and set gameState to 'menu'
                    } else {
                        // Fallback if pointer lock somehow wasn't active
                        gameState = 'menu'; // Set to menu state directly
                        showMainMenu(); // Show main menu
                    }
                } else if (gameState === 'weaponSelect' || gameState === 'settings' || gameState === 'gameOver') {
                    // From sub-menu or game over, go to main menu
                    showMainMenu();
                } else if (gameState === 'menu' && gameStartedAtLeastOnce && !gameOver) {
                    // If in main menu (as a pause) and game has been started, resume game
                    resumeGame();
                }
            } else if (gameState === 'playing') { // Only process other keys if playing
                keys[e.key] = true;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (gameState === 'playing') {
                keys[e.key] = false;
            }
        });

        // --- Pointer Lock for Mouse Rotation ---
        const canvas3D = document.getElementById('gameCanvas3D');

        function requestPointerLock() {
            canvas3D.requestPointerLock = canvas3D.requestPointerLock || canvas3D.mozRequestPointerLock || canvas3D.webkitRequestPointerLock;
            if (canvas3D.requestPointerLock) {
                canvas3D.requestPointerLock().then(() => {
                    console.log("Pointer lock successful.");
                }).catch((e) => {
                    console.error("Pointer lock failed or exited:", e);
                });
            }
        }

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === canvas3D || document.mozPointerLockElement === canvas3D || document.webkitPointerLockElement === canvas3D;
            if (isPointerLocked) {
                console.log('Pointer locked');
                // If pointer lock is acquired, and we were in the menu (as a pause), transition to playing.
                if (gameState === 'menu' && gameStartedAtLeastOnce && !gameOver) { // If we were in menu as a pause
                    gameState = 'playing';
                    playerHud.style.display = 'flex';
                    menuToggleButton.style.display = 'block';
                }
            } else {
                console.log('Pointer unlocked');
                isMouseDown = false;
                isZoomed = false;
                updateCameraFOV(false);
                // If pointer is unlocked and game was playing (not game over), it means user exited pointer lock
                if (gameState === 'playing' && !gameOver) {
                    gameState = 'menu'; // Transition to menu state (as pause menu)
                    showMainMenu(); // Show main menu
                }
            }
        }, false);

        document.addEventListener('mozpointerlockchange', () => {
            isPointerLocked = document.mozPointerLockElement === canvas3D;
        }, false);

        document.addEventListener('webkitpointerlockchange', () => {
            isPointerLocked = document.webkitPointerLockElement === canvas3D;
        }, false);

        // Click on canvas to request pointer lock (only if playing and not locked)
        canvas3D.addEventListener('click', () => {
            if (gameState === 'playing' && !isPointerLocked) { 
                requestPointerLock();
            }
        });

        // --- Mouse Down (Left Click) for Shooting, Right Click for Zoom ---
        document.addEventListener('mousedown', (event) => {
            if (gameState === 'playing' && isPointerLocked) {
                if (event.button === 0) { // Left click
                    isMouseDown = true;
                    shootBullet();
                } else if (event.button === 2) { // Right click
                    event.preventDefault(); // Prevent context menu
                    isZoomed = true;
                    updateCameraFOV(true);
                }
            }
        });

        document.addEventListener('mouseup', (event) => {
            if (event.button === 0) {
                isMouseDown = false;
            } else if (event.button === 2) { // Right click release
                isZoomed = false;
                updateCameraFOV(false);
            }
        });

        // Function to handle bullet shooting logic
        function shootBullet() {
            const bulletMaterial = new THREE.MeshPhongMaterial({ color: BULLET_COLOR });
            const bulletMesh = new THREE.Mesh(BULLET_GEOMETRY, bulletMaterial);

            const bulletSpawnPoint = new THREE.Vector3();
            camera.getWorldPosition(bulletSpawnPoint);
            
            const bulletDirection = new THREE.Vector3();
            camera.getWorldDirection(bulletDirection);
            bulletDirection.normalize();

            bulletMesh.position.copy(bulletSpawnPoint);
            
            const tempQuaternion = new THREE.Quaternion();
            tempQuaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), bulletDirection);
            bulletMesh.setRotationFromQuaternion(tempQuaternion);

            scene.add(bulletMesh);
            bullets.push({ mesh: bulletMesh, direction: bulletDirection });
            playSound(playerShootSynth, "C4", "16n");
        }

        document.addEventListener('mousemove', (event) => {
            if (gameState === 'playing' && isPointerLocked) {
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                playerYawObject.rotation.y -= movementX * mouseSensitivity;
                camera.rotation.x -= movementY * mouseSensitivity;
                camera.rotation.x = Math.max(-pitchLimit, Math.min(pitchLimit, camera.rotation.x));
            }
        });

        // Prevent context menu on right-click
        canvas3D.addEventListener('contextmenu', (e) => e.preventDefault());

        // --- Mobile Touch Drag for Rotation ---
        canvas3D.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1 && gameState === 'playing' && e.target === canvas3D) {
                isTouchDragging = true;
                previousTouchX = e.touches[0].clientX;
                previousTouchY = e.touches[0].clientY;
            }
        }, { passive: false });

        canvas3D.addEventListener('touchmove', (e) => {
            if (isTouchDragging && e.touches.length === 1 && e.target === canvas3D) {
                e.preventDefault();
                const currentTouchX = e.touches[0].clientX;
                const currentTouchY = e.touches[0].clientY;

                const deltaX = currentTouchX - previousTouchX;
                const deltaY = currentTouchY - previousTouchY;

                if (Math.abs(deltaX) > touchDragThreshold || Math.abs(deltaY) > touchDragThreshold) {
                    playerYawObject.rotation.y -= deltaX * touchSensitivity;
                    camera.rotation.x -= deltaY * touchSensitivity;
                    camera.rotation.x = Math.max(-pitchLimit, Math.min(pitchLimit, camera.rotation.x));
                }

                previousTouchX = currentTouchX;
                previousTouchY = currentTouchY;
            }
        }, { passive: false });

        canvas3D.addEventListener('touchend', () => {
            isTouchDragging = false;
        });
        canvas3D.addEventListener('touchcancel', () => {
            isTouchDragging = false; // Also reset preview dragging on touch cancel
        });


        // --- Mobile Controls for Movement (Buttons) ---
        leftButton.addEventListener('touchstart', () => { touchMoveLeft = true; }, { passive: true });
        leftButton.addEventListener('touchend', () => { touchMoveLeft = false; });
        leftButton.addEventListener('touchcancel', () => { touchMoveLeft = false; });

        rightButton.addEventListener('touchstart', () => { touchMoveRight = true; }, { passive: true });
        rightButton.addEventListener('touchend', () => { touchMoveRight = false; });
        rightButton.addEventListener('touchcancel', () => { touchMoveRight = false; });

        forwardButton.addEventListener('touchstart', () => { touchMoveForward = true; }, { passive: true });
        forwardButton.addEventListener('touchend', () => { touchMoveForward = false; });
        forwardButton.addEventListener('touchcancel', () => { touchMoveForward = false; });

        backwardButton.addEventListener('touchstart', () => { touchMoveBackward = true; }, { passive: true });
        backwardButton.addEventListener('touchend', () => { touchMoveBackward = false; });
        backwardButton.addEventListener('touchcancel', () => { touchMoveBackward = false; });

        shootButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === 'playing') {
                shootBullet();
            }
        }, { passive: false });

        restartButton.addEventListener('click', startGame); // This button is only in messageBox (Game Over), always restarts.

        // Menu button listeners
        mainMenuPrimaryButton.addEventListener('click', () => {
            if (gameStartedAtLeastOnce && !gameOver) {
                resumeGame();
            } else {
                startGame();
            }
        });
        restartGameButton.addEventListener('click', startGame); // This always triggers a full restart
        weaponSelectButton.addEventListener('click', showWeaponSelection); // Renamed
        settingsButton.addEventListener('click', showSettings);
        backToMainMenuFromWeaponButton.addEventListener('click', showMainMenu); // New listener
        backToMainMenuFromSettingsButton.addEventListener('click', showMainMenu);

        menuToggleButton.addEventListener('click', () => {
            if (gameState === 'playing') {
                // Pause game and show main menu
                if (document.pointerLockElement) {
                    document.exitPointerLock(); // This will trigger pointerlockchange and set gameState to 'menu'
                } else {
                    // Fallback if pointer lock somehow wasn't active
                    gameState = 'menu'; // Set to menu state directly
                    showMainMenu(); // Show main menu
                }
            } else if (gameState === 'menu' && gameStartedAtLeastOnce && !gameOver) {
                // If in main menu (as a pause) and game has been started, resume game
                resumeGame();
            }
        });

        // Settings control listeners
        mouseSensitivitySlider.addEventListener('input', (e) => {
            mouseSensitivity = parseFloat(e.target.value);
            updateSettingsDisplay(); // Update display immediately
        });

        volumeSlider.addEventListener('input', (e) => {
            masterVolume = parseFloat(e.target.value);
            Tone.Destination.volume.value = (masterVolume * 40) - 40; // Map 0-1 to -40dB to 0dB
            updateSettingsDisplay(); // Update display immediately
        });

        langIdButton.addEventListener('click', () => updateLanguage('id'));
        langEnButton.addEventListener('click', () => updateLanguage('en'));

        // NEW WEAPON SELECT BUTTON LISTENERS
        buyWeaponBtn.addEventListener('click', buyWeapon);
        prevWeaponBtn.addEventListener('click', showPreviousWeapon);
        nextWeaponBtn.addEventListener('click', showNextWeapon);

        // Function to update UI elements on weapon select screen based on current language
        function updateWeaponPreviewUI() {
            const t = translations[currentLanguage];
            weaponSelectTitle.textContent = t.weaponSelectTitle;
            backToMainMenuFromWeaponButton.textContent = t.backToMainMenu;
            loadingOverlay.querySelector('p').textContent = t.loadingModel;
            // Update buy button text based on current weapon state
            const currentPreviewWeaponData = allWeaponsData[currentWeaponIndex];
            updateBuyButtonState(currentPreviewWeaponData);
        }

        // --- Animation loop for Weapon Preview (NEW) ---
        function animateWeaponPreview() {
            requestAnimationFrame(animateWeaponPreview);
            if (previewControls) {
                previewControls.update(); // only required if controls.enableDamping is set to true
            }
            if (previewRenderer && previewScene && previewCamera) {
                previewRenderer.render(previewScene, previewCamera);
            }
        }

        // Handle window resize
        function resizeRenderer() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            if (renderer) { // Check if renderer is defined
                renderer.setSize(width, height);
            }
            if (camera) { // Check if camera is defined
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }
            // Resize preview canvas as well
            if (previewRenderer && weaponPreviewContainer) { // Check all preview related objects
                const previewWidth = weaponPreviewContainer.clientWidth;
                const previewHeight = weaponPreviewContainer.clientHeight;
                previewRenderer.setSize(previewWidth, previewHeight);
                if (previewCamera) {
                    previewCamera.aspect = previewWidth / previewHeight;
                    previewCamera.updateProjectionMatrix();
                }
            }
        }

        window.addEventListener('resize', resizeRenderer);

        // Update camera FOV for zoom
        function updateCameraFOV(zoomed) {
            if (camera) {
                camera.fov = zoomed ? ZOOM_FOV : ORIGINAL_FOV;
                camera.updateProjectionMatrix();
            }
        }

        // Function to update all displayed text based on current language
        function updateLanguageDisplay() {
            const t = translations[currentLanguage];

            // Update main menu
            mainMenuTitle.textContent = t.gameTitle;
            welcomeMessageText.textContent = t.welcomeMessage; // Set welcome message
            // Buttons are handled dynamically by showMainMenu, but their text needs updating
            mainMenuPrimaryButton.textContent = (gameStartedAtLeastOnce && !gameOver) ? t.continueGame : t.startGame;
            restartGameButton.textContent = t.restartGame;
            weaponSelectButton.textContent = t.selectWeapon;
            settingsButton.textContent = t.settings;

            // Update weapon select screen UI
            updateWeaponPreviewUI(); // Call this to update titles, buttons, etc.

            // Update settings screen
            settingsScreen.querySelector('h1').textContent = t.settingsTitle;
            settingsScreen.querySelector('p').textContent = t.settingsPlaceholder;
            document.getElementById('mouseSensitivityLabel').textContent = t.mouseSensitivityLabel;
            document.getElementById('volumeLabel').textContent = t.volumeLabel;
            document.getElementById('languageLabel').textContent = t.languageLabel;
            backToMainMenuFromSettingsButton.textContent = t.backToMainMenu;

            // Update HUD
            coinsDisplay.textContent = `${t.coins} ${coins}`; // Changed from score
            healthLabel.textContent = `${t.health} ${Math.max(0, Math.floor(playerHealth))}`;
            shieldLabel.textContent = `${t.shield} ${Math.max(0, Math.floor(playerShield))}`;

            // Update message box (only for Game Over)
            restartButton.textContent = t.restartButton;
            if (messageBox.style.display === 'block' && messageText.dataset.originalMessage) {
                if (messageText.dataset.originalMessage.includes("GAME OVER!")) {
                    messageText.textContent = t.gameOverMessage;
                }
            }

            // Update mobile shoot button
            shootButton.innerHTML = `<i class="fas fa-crosshairs"></i> ${t.shootButton}`;

            // Update settings display to reflect language button selection
            updateSettingsDisplay();
        }


        // Initial setup on window load
        window.onload = function() {
            initThreeJS();
            // Set initial volume for Tone.js
            Tone.Destination.volume.value = (masterVolume * 40) - 40;
            
            // Initialize game elements FIRST, which loads weapons from localStorage
            initializeGameElements();

            // Then, update UI elements based on the initialized game state
            showMainMenu(); // Start with main menu visible
            updateLanguageDisplay(); // Initial display updates based on default language
            updateHealthShieldDisplay(); // Ensure health/shield bars are initialized
            updateSettingsDisplay(); // Ensure settings UI reflects initial values

            // Start the animation loop, but game logic will only run when gameState is 'playing'
            animate();
        };

    </script>
</body>
</html>
